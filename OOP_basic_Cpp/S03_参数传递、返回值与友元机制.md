## 一、构造函数的进阶使用：private构造函数与单例模式

### 1.1 构造函数放在private区域的特殊用途

通常情况下，构造函数放在public区域，允许外界自由创建对象。但有一种特殊设计模式需要将构造函数私有化：**单例模式(Singleton)**。

**为什么需要私有化构造函数？**


```cpp

// 普通的public构造函数 - 任何人都可以创建对象
class NormalClass {
public:
    NormalClass() { 
        cout << "NormalClass对象被创建" << endl; 
    }
};

// 私有构造函数的类
class SingletonClass {
private:
    // 构造函数私有化，禁止外部直接创建对象
    SingletonClass() { 
        cout << "SingletonClass对象被创建" << endl; 
    }
    
    // 拷贝构造函数也私有化，防止通过拷贝创建新对象
    SingletonClass(const SingletonClass&) = delete;
    
public:
    void show() { 
        cout << "我是单例对象" << endl; 
    }
};

int main() {
    NormalClass n1;        // 可以，构造函数是public的
    NormalClass n2 = n1;   // 可以，拷贝构造函数是public的
    
    // SingletonClass s1;  // 错误！构造函数是private的
    // SingletonClass s2(s1); // 错误！拷贝构造函数是private的
    
    return 0;
}
```
### 1.2 单例模式的完整实现

单例模式确保一个类**在整个程序生命周期内只有一个实例**，并提供一个全局访问点。

```cpp

#include <iostream>
using namespace std;

class Singleton {
private:
    // 1. 私有化构造函数和拷贝构造函数
    Singleton() { 
        cout << "Singleton构造函数被调用" << endl; 
    }
    
    Singleton(const Singleton&) = delete;  // C++11起可以用 =delete 明确禁止拷贝
    
    // 2. 私有化赋值运算符（后续课程详细讲解）
    Singleton& operator=(const Singleton&) = delete;
    
    // 3. 静态成员指针，指向唯一的实例
    static Singleton* instance;
    
    // 实例数据
    int data;
    
public:
    // 4. 静态公有方法，提供全局访问点
    static Singleton* getInstance() {
        if (instance == nullptr) {
            instance = new Singleton();
        }
        return instance;
    }
    
    // 5. 获取和设置数据的方法
    int getData() const { return data; }
    void setData(int value) { data = value; }
    
    // 6. 释放资源的方法（可选）
    static void destroy() {
        if (instance != nullptr) {
            delete instance;
            instance = nullptr;
        }
    }
};

// 静态成员必须在类外初始化
Singleton* Singleton::instance = nullptr;

// 使用示例
int main() {
    // 获取单例对象
    Singleton* s1 = Singleton::getInstance();
    s1->setData(100);
    cout << "s1 data: " << s1->getData() << endl;
    
    // 再次获取，得到的是同一个对象
    Singleton* s2 = Singleton::getInstance();
    cout << "s2 data: " << s2->getData() << endl;
    
    // 验证是同一个对象
    s2->setData(200);
    cout << "s1 data after s2修改: " << s1->getData() << endl;
    
    // 释放资源
    Singleton::destroy();
    
    return 0;
}
```
**更现代的C++11实现（使用局部静态变量，线程安全）：**

```cpp

class ModernSingleton {
private:
    ModernSingleton() { cout << "ModernSingleton创建" << endl; }
    ModernSingleton(const ModernSingleton&) = delete;
    ModernSingleton& operator=(const ModernSingleton&) = delete;
    
    int data = 0;
    
public:
    static ModernSingleton& getInstance() {
        static ModernSingleton instance;  // C++11保证这是线程安全的
        return instance;
    }
    
    int getData() const { return data; }
    void setData(int value) { data = value; }
};

// 使用：ModernSingleton::getInstance().setData(42);
```
## 二、const成员函数：常量正确性

### 2.1 const成员函数的基本概念

在成员函数声明后加`const`关键字，表示该函数**不会修改对象的任何数据成员**。

```cpp

class Complex {
private:
    double re, im;
    
public:
    Complex(double r = 0, double i = 0) : re(r), im(i) {}
    
    // const成员函数：承诺不修改对象
    double real() const { 
        return re;  // 只读，不修改
    }
    
    double imag() const { 
        return im;  // 只读，不修改
    }
    
    // 非const成员函数：可能会修改对象
    void setReal(double r) { 
        re = r;  // 修改数据成员
    }
    
    void setImag(double i) { 
        im = i;  // 修改数据成员
    }
    
    // 尝试在const函数中修改数据会导致编译错误
    // double badFunc() const {
    //     re = 0;  // 错误！不能在const函数中修改成员
    //     return re;
    // }
};
```
### 2.2 const对象与const成员函数的关系

```cpp

int main() {
    Complex c1(3, 4);           // 普通对象
    const Complex c2(5, 6);     // const对象（内容不可变）
    
    // const对象可以调用const成员函数
    cout << c2.real() << endl;  // OK，real()是const函数
    cout << c2.imag() << endl;  // OK，imag()是const函数
    
    // const对象不能调用非const成员函数
    // c2.setReal(10);          // 错误！setReal()不是const函数
    
    // 普通对象可以调用所有成员函数
    cout << c1.real() << endl;  // OK
    c1.setReal(10);             // OK
    
    return 0;
}
```
### 2.3 const成员函数的设计原则

1. **任何不修改数据成员的函数都应声明为const**
    
2. **const成员函数可以重载非const版本**
    
3. **在设计类时就应该考虑哪些函数需要const版本**
    

```cpp

class TextBlock {
private:
    std::string text;
    mutable std::size_t accessCount;  // mutable：即使在const函数中也可修改
    
public:
    TextBlock(const std::string& str) : text(str), accessCount(0) {}
    
    // const版本：返回const引用，不能通过它修改text
    const char& operator[](std::size_t position) const {
        accessCount++;  // mutable成员可以在const函数中修改
        return text[position];
    }
    
    // 非const版本：返回普通引用，可以通过它修改text
    char& operator[](std::size_t position) {
        accessCount++;
        return text[position];
    }
    
    std::size_t getAccessCount() const { return accessCount; }
};

int main() {
    TextBlock tb("Hello");
    const TextBlock ctb("World");
    
    tb[0] = 'h';        // OK，调用非const版本的operator[]
    // ctb[0] = 'w';    // 错误！调用const版本，返回const引用，不能赋值
    
    char c1 = tb[0];    // OK，调用非const版本
    char c2 = ctb[0];   // OK，调用const版本
    
    return 0;
}
```
**mutable关键字**：用于标记那些在逻辑上不是对象状态一部分，但需要被const成员函数修改的成员。

## 三、参数传递：值传递 vs. 引用传递

### 3.1 三种参数传递方式对比

|传递方式|语法|特点|适用场景|
|---|---|---|---|
|**传值 (pass by value)**|`void func(Type arg)`|创建参数的完整副本，修改不影响原对象|内置类型、小型对象、需要副本的情况|
|**传引用 (pass by reference)**|`void func(Type& arg)`|传递原对象的别名，修改会影响原对象|需要修改参数的大型对象|
|**传常引用 (pass by const reference)**|`void func(const Type& arg)`|传递只读引用，不能修改原对象|不需要修改的大型对象，避免拷贝开销|

### 3.2 参数传递的选择策略

```cpp

#include <iostream>
#include <string>
#include <vector>

class BigObject {
private:
    std::vector<int> data;  // 假设数据很大
    
public:
    BigObject(int size) : data(size) {
        for (int i = 0; i < size; ++i) {
            data[i] = i;
        }
    }
    
    // 示例函数，展示不同的参数传递方式
    void processData() {
        // 处理数据...
    }
};

// 1. 传值：创建副本（昂贵！）
void processByValue(BigObject obj) {
    obj.processData();  // 处理的是副本
    // 函数结束，副本被销毁
}

// 2. 传引用：直接操作原对象（高效）
void processByReference(BigObject& obj) {
    obj.processData();  // 直接处理原对象
    // 注意：可能会修改原对象
}

// 3. 传常引用：只读访问（高效且安全）
void processByConstReference(const BigObject& obj) {
    // obj.processData();  // 错误！不能调用非const成员函数
    // 只能调用obj的const成员函数
    std::cout << "对象大小: " << sizeof(obj) << std::endl;
}

// 4. 对于内置类型，传值通常更合适
void processInt(int value) {  // 传值开销小
    value = value * 2;
}

// 5. 对于小型结构，传值也可能合适
struct Point {
    double x, y;
};

void processPoint(Point p) {  // Point很小（两个double），传值OK
    p.x += 1.0;
}

int main() {
    BigObject bigObj(1000000);  // 大对象
    
    // 对比不同传递方式的效率
    processByValue(bigObj);           // 昂贵：拷贝100万个int
    processByReference(bigObj);       // 高效：不拷贝
    processByConstReference(bigObj);  // 高效：不拷贝，且安全
    
    int num = 10;
    processInt(num);  // 传值开销小，合适
    
    Point pt = {1.0, 2.0};
    processPoint(pt);  // 传值开销小，合适
    
    return 0;
}
```
### 3.3 复数类中的参数传递设计

```cpp

class Complex {
private:
    double re, im;
    
public:
    // 问题：这里用传值，对于double这样的内置类型可以接受
    // 但如果Complex很大，或者参数类型很复杂，应该用const引用
    Complex(double r = 0, double i = 0) : re(r), im(i) {}
    
    // 正确：使用const引用，避免不必要的拷贝
    Complex& operator+=(const Complex& rhs) {
        re += rhs.re;
        im += rhs.im;
        return *this;
    }
    
    // 正确：输出流操作，第一个参数是非常量引用（需要修改流状态）
    // 第二个参数是const引用（不需要修改复数对象）
    friend std::ostream& operator<<(std::ostream& os, const Complex& c);
    
    // 正确：友元函数，明确区分哪些参数需要修改
    friend Complex& _doapl(Complex* ths, const Complex& r);
};

// 实现
Complex& _doapl(Complex* ths, const Complex& r) {
    ths->re += r.re;  // 直接访问私有成员（因为是友元）
    ths->im += r.im;
    return *ths;
}

std::ostream& operator<<(std::ostream& os, const Complex& c) {
    os << "(" << c.re << ", " << c.im << "i)";
    return os;  // 返回引用以支持链式调用：cout << a << b;
}
```
## 四、返回值传递：值返回 vs. 引用返回

### 4.1 返回值传递的基本原则

```cpp

class Complex {
private:
    double re, im;
    
public:
    Complex(double r = 0, double i = 0) : re(r), im(i) {}
    
    // 情况1：返回引用 - 高效，但必须确保对象在函数结束后仍然存在
    Complex& operator+=(const Complex& rhs) {
        re += rhs.re;
        im += rhs.im;
        return *this;  // 返回当前对象的引用，安全！
    }
    
    // 情况2：返回值 - 安全，但可能有拷贝开销
    Complex operator+(const Complex& rhs) const {
        return Complex(re + rhs.re, im + rhs.im);  // 返回临时对象，必须传值
    }
    
    // 情况3：返回const引用 - 只读访问，高效且安全
    const Complex& getConjugate() const {
        static Complex conjugate;  // 静态对象，生命周期长
        conjugate.re = re;
        conjugate.im = -im;
        return conjugate;  // 安全：返回静态对象的引用
    }
    
    // 情况4：返回内置类型 - 直接传值
    double real() const { return re; }
    
    // 错误示例：返回局部变量的引用
    // Complex& badFunc() {
    //     Complex temp(re, im);  // 局部变量
    //     return temp;           // 错误！temp在函数结束后被销毁
    // }
};
```
### 4.2 何时可以/不可以返回引用

**可以返回引用的情况：**

1. 返回**成员函数所在的对象的引用**（`return *this;`）
    
2. 返回**函数参数中传入的对象的引用**
    
3. 返回**全局或静态对象的引用**
    
4. 返回**动态分配的对象**的引用（但要确保调用者负责释放内存）
    

**不可以返回引用的情况：**

1. 返回**局部变量的引用**（变量在函数结束后被销毁）
    
2. 返回**局部对象的引用**（对象在函数结束后被销毁）
    
3. 返回**函数内创建的临时对象的引用**
    

```cpp

// 正确示例
Complex& addAndReturn(Complex& c1, const Complex& c2) {
    c1 += c2;
    return c1;  // OK：c1是传入的引用，生命周期由调用者管理
}

Complex globalObj;  // 全局对象

Complex& getGlobal() {
    return globalObj;  // OK：返回全局对象的引用
}

Complex& createStatic() {
    static Complex staticObj;  // 静态局部对象
    return staticObj;  // OK：静态对象生命周期持续到程序结束
}

// 错误示例
Complex& createLocal() {
    Complex localObj;  // 局部对象
    return localObj;   // 错误！localObj在函数结束后被销毁
}

Complex& createTemp() {
    return Complex(1, 2);  // 错误！返回临时对象的引用
}
```
### 4.3 操作符重载中的返回值设计

```cpp

class Complex {
private:
    double re, im;
    
public:
    Complex(double r = 0, double i = 0) : re(r), im(i) {}
    
    // 复合赋值操作符：返回引用，支持链式调用
    Complex& operator+=(const Complex& rhs) {
        re += rhs.re;
        im += rhs.im;
        return *this;  // 返回当前对象的引用
    }
    
    Complex& operator-=(const Complex& rhs) {
        re -= rhs.re;
        im -= rhs.im;
        return *this;
    }
    
    // 算术操作符：返回值（新对象），不修改原对象
    Complex operator+(const Complex& rhs) const {
        return Complex(re + rhs.re, im + rhs.im);  // 返回新对象
    }
    
    Complex operator-(const Complex& rhs) const {
        return Complex(re - rhs.re, im - rhs.im);
    }
    
    // 前置++：返回引用
    Complex& operator++() {
        re += 1.0;
        return *this;
    }
    
    // 后置++：返回值（传统做法）
    Complex operator++(int) {  // int参数用于区分前置和后置
        Complex temp = *this;
        ++(*this);
        return temp;  // 返回旧值
    }
};

// 使用示例
int main() {
    Complex a(1, 2), b(3, 4), c(5, 6);
    
    // 链式调用：因为operator+=返回引用
    a += b += c;  // 相当于 a += (b += c);
    
    // 算术运算创建新对象
    Complex d = a + b;  // a和b不变，d是新对象
    
    // 前置++返回引用
    Complex& ref = ++a;  // ref是a的引用
    
    // 后置++返回值
    Complex old = a++;   // old是a增加前的副本
    
    return 0;
}
```
## 五、友元(friend)机制

### 5.1 友元的基本概念

友元是C++提供的一种**打破封装**的特殊机制，允许特定的非成员函数或类访问另一个类的私有成员。

```cpp

class Complex {
private:
    double re, im;
    
public:
    Complex(double r = 0, double i = 0) : re(r), im(i) {}
    
    double real() const { return re; }
    double imag() const { return im; }
    
    // 声明友元函数
    friend Complex operator*(const Complex&, const Complex&);
    friend std::ostream& operator<<(std::ostream&, const Complex&);
    
private:
    // 也可以将函数设为私有，仅供友元调用
    friend Complex& _doapl(Complex*, const Complex&);
};

// 友元函数的定义（不是成员函数！）
Complex operator*(const Complex& x, const Complex& y) {
    // 可以直接访问私有成员
    return Complex(x.re * y.re - x.im * y.im,
                   x.re * y.im + x.im * y.re);
}

std::ostream& operator<<(std::ostream& os, const Complex& x) {
    os << "(" << x.re << ", " << x.im << "i)";
    return os;
}

// 私有友元函数的定义
Complex& _doapl(Complex* ths, const Complex& r) {
    ths->re += r.re;
    ths->im += r.im;
    return *ths;
}
```
### 5.2 相同类的不同对象互为友元

这是C++的一个**重要但常被忽略**的特性：同一个类的不同对象可以直接访问彼此的私有成员。

```cpp

class Complex {
private:
    double re, im;
    
public:
    Complex(double r = 0, double i = 0) : re(r), im(i) {}
    
    // 这个函数可以直接访问参数对象c的私有成员
    // 因为相同类的对象互为友元
    bool isEqual(const Complex& c) const {
        return (re == c.re) && (im == c.im);  // 直接访问c.re和c.im
    }
    
    // 另一个示例
    Complex add(const Complex& other) const {
        // 可以直接访问other的私有成员
        return Complex(re + other.re, im + other.im);
    }
};

// 对比：如果不是相同类的对象，则不能直接访问私有成员
class Stranger {
public:
    void tryAccess(const Complex& c) {
        // double r = c.re;  // 错误！不能访问Complex的私有成员
        double r = c.real();  // 必须通过公有接口
    }
};
```
### 5.3 友元的优缺点与使用建议

**优点：**

1. **提高效率**：避免通过公有接口的间接访问
    
2. **方便操作符重载**：使非成员函数能访问私有数据
    
3. **实现特定协作**：允许紧密协作的类相互访问
    

**缺点：**

1. **破坏封装**：这是最主要的问题
    
2. **增加耦合**：使类之间的关系更紧密
    
3. **降低可维护性**：修改类的私有成员可能影响所有友元
    

**使用建议：**

1. **谨慎使用**：只在真正需要时使用
    
2. **优先考虑公有接口**：能用公有接口实现的就不要用友元
    
3. **用于操作符重载**：`<<`, `>>`, `*`, `/`等操作符重载常用友元
    
4. **用于紧密协作的类**：如容器和迭代器
    

```cpp

// 合理使用友元的示例：矩阵和向量类
class Vector;  // 前置声明

class Matrix {
private:
    double data[4][4];
    
public:
    // 矩阵-向量乘法通常实现为非成员函数，但需要访问私有数据
    friend Vector operator*(const Matrix& m, const Vector& v);
    
    // 提供公有接口用于一般情况
    double get(int i, int j) const { return data[i][j]; }
};

class Vector {
private:
    double data[4];
    
public:
    friend Vector operator*(const Matrix& m, const Vector& v);
    double get(int i) const { return data[i]; }
};

// 友元函数实现
Vector operator*(const Matrix& m, const Matrix& v) {
    Vector result;
    for (int i = 0; i < 4; ++i) {
        result.data[i] = 0;
        for (int j = 0; j < 4; ++j) {
            // 直接访问两个类的私有成员
            result.data[i] += m.data[i][j] * v.data[j];
        }
    }
    return result;
}
```
## 六、综合示例：完整的复数类设计

```cpp

#include <iostream>
#include <cmath>

class Complex {
private:
    double re, im;  // 数据私有化
    
public:
    // 构造函数 - 使用初始化列表
    Complex(double r = 0.0, double i = 0.0) : re(r), im(i) {}
    
    // const成员函数 - 不修改对象
    double real() const { return re; }
    double imag() const { return im; }
    
    // 非const成员函数 - 修改对象
    void setReal(double r) { re = r; }
    void setImag(double i) { im = i; }
    
    // 复合赋值操作符 - 返回引用
    Complex& operator+=(const Complex& rhs) {
        re += rhs.re;
        im += rhs.im;
        return *this;
    }
    
    Complex& operator-=(const Complex& rhs) {
        re -= rhs.re;
        im -= rhs.im;
        return *this;
    }
    
    Complex& operator*=(const Complex& rhs) {
        double new_re = re * rhs.re - im * rhs.im;
        double new_im = re * rhs.im + im * rhs.re;
        re = new_re;
        im = new_im;
        return *this;
    }
    
    // 算术操作符 - 返回值（新对象）
    Complex operator+(const Complex& rhs) const {
        return Complex(re + rhs.re, im + rhs.im);
    }
    
    Complex operator-(const Complex& rhs) const {
        return Complex(re - rhs.re, im - rhs.im);
    }
    
    // 友元函数 - 用于操作符重载
    friend Complex operator*(const Complex& lhs, const Complex& rhs);
    friend Complex operator/(const Complex& lhs, const Complex& rhs);
    
    friend std::ostream& operator<<(std::ostream& os, const Complex& c);
    friend std::istream& operator>>(std::istream& is, Complex& c);
    
    // 相同类对象互为友元 - 直接访问私有成员
    double distanceTo(const Complex& other) const {
        double dx = re - other.re;  // 直接访问other.re
        double dy = im - other.im;  // 直接访问other.im
        return std::sqrt(dx * dx + dy * dy);
    }
    
private:
    // 私有辅助函数 - 仅供内部使用
    double magnitude() const {
        return std::sqrt(re * re + im * im);
    }
};

// 友元函数实现
Complex operator*(const Complex& lhs, const Complex& rhs) {
    return Complex(lhs.re * rhs.re - lhs.im * rhs.im,
                   lhs.re * rhs.im + lhs.im * rhs.re);
}

Complex operator/(const Complex& lhs, const Complex& rhs) {
    double denominator = rhs.re * rhs.re + rhs.im * rhs.im;
    return Complex((lhs.re * rhs.re + lhs.im * rhs.im) / denominator,
                   (lhs.im * rhs.re - lhs.re * rhs.im) / denominator);
}

std::ostream& operator<<(std::ostream& os, const Complex& c) {
    os << "(" << c.re << " + " << c.im << "i)";
    return os;
}

std::istream& operator>>(std::istream& is, Complex& c) {
    char ch;
    is >> ch;  // 读取 '('
    is >> c.re;
    is >> ch;  // 读取 '+'
    is >> c.im;
    is >> ch;  // 读取 'i'
    is >> ch;  // 读取 ')'
    return is;
}

// 使用示例
int main() {
    Complex a(1.0, 2.0);
    Complex b(3.0, 4.0);
    
    // 测试各种操作
    Complex c = a + b;
    Complex d = a * b;
    
    a += b;
    
    std::cout << "a = " << a << std::endl;
    std::cout << "b = " << b << std::endl;
    std::cout << "c = a + b = " << c << std::endl;
    std::cout << "d = a * b = " << d << std::endl;
    
    // 测试距离计算（使用相同类对象互为友元的特性）
    double dist = a.distanceTo(b);
    std::cout << "a到b的距离: " << dist << std::endl;
    
    return 0;
}
```
## 七、关键要点总结

### 7.1 构造函数设计

1. **public构造函数**：常规设计，允许外部创建对象
    
2. **private构造函数**：用于单例模式等特殊场景，限制对象创建
    
3. **const成员函数**：任何不修改对象状态的函数都应声明为const
    
4. **初始化列表**：总是使用初始化列表，特别是对于const成员、引用成员和类对象成员
    

### 7.2 参数传递策略

|情况|推荐方式|原因|
|---|---|---|
|内置类型（int, double等）|传值|开销小，通常小于或等于传引用|
|小型结构（几个基本类型）|传值或const引用|根据是否修改决定|
|大型对象|const引用|避免拷贝开销|
|需要修改的参数|引用|直接修改原对象|
|输出参数|引用|传统C++做法（也可用指针）|

### 7.3 返回值策略

|情况|推荐方式|示例|
|---|---|---|
|返回新创建的对象|传值|`Complex operator+()`|
|返回当前对象|引用|`Complex& operator+=()`|
|返回成员或局部变量|传值|`double real() const`|
|返回静态或全局对象|const引用|`const Complex& getZero()`|

### 7.4 友元使用准则

1. **用于操作符重载**：特别是`<<`, `>>`, `*`, `/`等
    
2. **用于紧密协作的类**：如容器和迭代器
    
3. **避免过度使用**：优先考虑公有接口
    
4. **记住隐式友元**：相同类的对象可以直接访问彼此的私有成员
    

### 7.5 性能与安全的平衡

- **优先考虑正确性**：确保代码正确后再优化
    
- **使用const正确性**：这是免费的性能提升和安全保障
    
- **避免过早优化**：只在性能分析显示瓶颈时进行微优化
    
- **遵循惯例**：C++社区有成熟的模式和实践
    

通过本讲的学习，不想写出拟人代码你就要做到：

1. 合理设计构造函数的访问权限
    
2. 正确使用const成员函数确保常量正确性
    
3. 根据情况选择合适的参数传递方式
    
4. 根据对象生命周期决定返回值传递方式
    
5. 理解并合理使用友元机制
    
6. 设计出高效、安全且易于使用的类接口
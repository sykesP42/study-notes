## 一、操作符重载

### 1. 操作符重载的概念

操作符重载允许我们为自定义类型（如类）定义操作符（如 `+`、`-`、`<<` 等）的行为，使其能够像内置类型一样进行直观的运算。

**为什么需要操作符重载？**

- 提升代码可读性：`c1 + c2` 比 `c1.add(c2)` 更直观
    
- 保持一致性：自定义类型可以与内置类型使用相同的语法
    

---

### 2. 成员函数形式的操作符重载

#### 2.1 隐藏参数 `this` 指针

在类的**成员函数**中，编译器会自动添加一个隐藏的参数——`this` 指针，它指向调用该函数的对象。


```cpp

class Complex {
public:
    Complex& operator+=(const Complex& r);
};

// 调用时：
c2 += c1;  // 实际上被编译为：c2.operator+=(c1);
```
**`this` 指针的特点：**

- 名称由来：“谁调用我，谁就是 `this`”
    
- 在函数体内可使用，但不能在参数列表中显式写出
    
- 编译器自动传递调用对象的地址
    
- 不同编译器可能将 `this` 放在不同参数位置，但对使用者透明
    

---

#### 2. 操作符重载的实现与调用

以 `+=` 为例：

```cpp

class Complex {
private:
    double re, im;
public:
    Complex& operator+=(const Complex& r) {
        this->re += r.re;   // 等效于 re += r.re;
        this->im += r.im;   // 等效于 im += r.im;
        return *this;       // 返回当前对象的引用
    }
};
```
**编译器处理二元操作符的过程：**

1. 将操作符作用在**左操作数**上
    
2. 若左操作数的类定义了该操作符，则调用对应的成员函数
    
3. 例如 `c2 += c1` 编译为 `c2.operator+=(c1)`
    

---

#### 3. 标准库实现的分层设计

在实际的复数类设计中，通常分为两层：

1. **基础操作层**：执行实际的运算
    
    cpp
    
    void doapl(Complex* ths, const Complex& r) {
        ths->re += r.re;
        ths->im += r.im;
    }
    
2. **操作符层**：调用基础操作，保持接口简洁
    
    ```cpp
    
    Complex& operator+=(const Complex& r) {
        doapl(this, r);
        return *this;
    }
	 ```

**复数加法的数学原理：**

- 实部相加：`re = re + r.re`
    
- 虚部相加：`im = im + r.im`
    

---

#### 4. 返回值的巧妙设计

为了支持**连续操作**（链式调用），操作符重载应返回对象的引用。

```cpp

// 支持这样的连续操作：
c3 += c2 += c1;

// 实现方式：
Complex& operator+=(const Complex& r) {
    // ... 执行加法 ...
    return *this;  // 返回当前对象的引用
}
```
**执行顺序：**

- 从右向左执行：`c2 += c1` 先执行，然后 `c3 += (c2 += c1) 的结果`
    
- 前一个操作的返回值作为下一个操作的左操作数
    

---

#### 5. 返回引用的语法分析

```cpp

Complex& operator+=(const Complex& r) {
    // ...
    return *this;  // 返回对象本身，但函数声明为返回引用
}
```
**语法特点：**

- 函数返回对象值（`*this`）
    
- 但声明为返回引用（`Complex&`）
    
- 这种写法合法且常见
    

**优势：**

- 传递者无需知道接收者是以引用还是值形式接收
    
- 保持接口的灵活性
    

**效率考量：**

- 用引用接收可避免拷贝，提升性能
    
- 用值接收则产生拷贝，但调用方代码无需修改
    

---

### 3. 例题解析

#### 例题1：类体外的函数定义

```cpp

// 成员函数（带类名前缀）
Complex& Complex::operator+=(const Complex& r) { ... }

// 全局函数（无类名前缀）
double imag(const Complex& x) { return x.imag(); }
```
**设计规范：**

- 类外函数应尽量使用 `const` 引用参数提高效率
    
- 全局函数通过调用公开成员函数获取类私有数据
    

---

#### 例题2：类模板简介

```cpp

template<typename T>
class Complex {
private:
    T re, im;  // 使用模板类型 T
public:
    Complex(T r = 0, T i = 0) : re(r), im(i) {}
};
```
**头文件结构：**

1. 包含防护宏：`#ifndef COMPLEX_H`
    
2. 前置声明
    
3. 类声明
    
4. 类定义
    

**友元函数：**

```cpp

friend Complex& doapl(Complex*, const Complex&);
```
友元函数可以访问类的私有成员 `re` 和 `im`。

---

#### 例题3：返回值传递方式

**两种方式对比：**

|方式|优点|缺点|适用场景|
|---|---|---|---|
|**return by value**|安全，返回副本|可能有拷贝开销|必须返回新对象时|
|**return by reference**|高效，无拷贝|需注意对象生命周期|返回已存在对象时|

**设计原则：**

- 非修改操作返回 `const` 引用（如 `const Complex&`）
    
- 修改操作返回非 `const` 引用（如 `Complex&`）
    
- 输出流重载返回 `ostream&` 以支持链式输出
    

---

### 4. 非成员函数形式的操作符重载

#### 4.1 为什么需要非成员函数？

成员函数版本默认有 `this` 指针指向左操作数，而非成员函数需要两个显式参数。

**必要性：**  
为了支持数学运算的多种组合方式：

1. 复数 + 复数
    
2. 复数 + 实数
    
3. 实数 + 复数
    

```cpp

// 成员函数只能处理：复数 + 复数
Complex operator+(const Complex& r) const;

// 需要非成员函数处理：
Complex operator+(const Complex& x, const Complex& y);
Complex operator+(const Complex& x, double y);
Complex operator+(double x, const Complex& y);
```
---

#### 4.2 临时对象与返回值

**<span style="color: #e74c3c;">重要原则：局部对象不能返回引用！</span>**

```cpp

// 错误示例：返回局部对象的引用
const Complex& operator+(const Complex& x, const Complex& y) {
    Complex result(x.re + y.re, x.im + y.im);  // 局部对象
    return result;  // 错误！result 在函数结束时销毁
}

// 正确示例：返回值
Complex operator+(const Complex& x, const Complex& y) {
    return Complex(x.re + y.re, x.im + y.im);  // 返回临时对象
}
```
**原因：**

- 这些函数内部必须创建临时对象存放计算结果
    
- 该对象在函数结束时销毁
    
- 若返回引用会导致“悬垂引用”（引用指向已销毁的对象）
    

**必须返回对象的情况：**

- 数学运算符（`+`、`-`、`*`、`/` 等）
    
- 创建新对象的操作符（如负号 `-`）
    
- 任何需要返回新计算结果的操作
    

---

#### 4.3 临时对象的语法与特性

**创建语法：**

```cpp

Complex(2, 1)      // 创建临时复数对象
int(7)             // 创建临时整数（类似语法）
```
**特性：**

1. **匿名性**：没有变量名
    
2. **短暂生命周期**：生存期仅到包含它的表达式结束
    
3. **常见用途**：适合只需短暂存在的中间结果
    

**示例：**

```cpp

// 临时对象在表达式结束后立即销毁
c3 = c1 + c2;  // operator+ 返回的临时对象在赋值后销毁
```
---

### 5. 正负操作符的重载

#### 5.1 正号重载

```cpp

// 正号：直接返回参数本身
const Complex& operator+(const Complex& x) {
    return x;  // 可返回引用，因为不创建新对象
}
```
**优化建议**：可改为返回 `const Complex&` 提高效率。

#### 5.2 负号重载

```cpp

// 负号：必须创建新对象
Complex operator-(const Complex& x) {
    return Complex(-x.re, -x.im);  // 必须返回值
}
```
**编译器识别：**

- 单参数：一元操作符（正/负号）
    
- 双参数：二元操作符（加法等）
    

---

### 6. 应用案例

#### 6.1 复数相等比较

需要为三种情况单独编写全局函数：

```cpp

bool operator==(const Complex& x, const Complex& y);
bool operator==(const Complex& x, double y);
bool operator==(double x, const Complex& y);
```
**设计考量：**

- 参数全部使用 `const` 引用传递
    
- 直接返回 `bool` 值而非引用
    
- 使用 `inline` 提高效率
    

#### 6.2 复数不等比较

```cpp

bool operator!=(const Complex& x, const Complex& y) {
    return !(x == y);  // 复用相等操作符
}
```
**注意事项：**

- 使用逻辑非（`!`）而非重新判断
    
- 同样需要三种重载形式
    

#### 6.3 共轭复数设计

```cpp

// 全局函数形式
Complex conj(const Complex& x) {
    return Complex(x.real(), -x.imag());
}
```
**数学定义**：实部不变，虚部取反。

#### 6.4 输出操作符（`<<`）重载

**<span style="color: #e74c3c;">必须设计为全局函数</span>**，因为左操作数是 `ostream`，我们无法修改标准库。

```cpp

ostream& operator<<(ostream& os, const Complex& x) {
    return os << '(' << x.real() << ',' << x.imag() << ')';
}
```
**参数设计：**

1. 第一个参数：`ostream&` 类型（不可加 `const`，因为输出会改变流状态）
    
2. 第二个参数：`const Complex&` 类型
    

**返回值设计：**

- 必须返回 `ostream&` 以支持链式调用：`cout << c1 << c2;`
    
- 返回引用而非值拷贝
    
- 不能使用 `void` 返回类型
    

**输出格式**：通常采用数学标准格式 `(实部, 虚部)`

---

## 二、复数类的完整设计

### 1. 类的分类

根据是否包含指针成员，类可分为：

1. **不带指针的类**：如复数类
    
2. **带指针的类**：需要特别注意内存管理
    

### 2. 复数类的声明与设计

#### 2.1 头文件结构（complex.h）

```cpp

#ifndef __COMPLEX__
#define __COMPLEX__

#include <iostream>

// 前置声明
class Complex;

// 基础操作函数声明
Complex& doapl(Complex* ths, const Complex& r);

class Complex {
private:
    double re, im;  // 私有数据
    
    // 友元声明
    friend Complex& doapl(Complex*, const Complex&);
    
public:
    // 构造函数
    Complex(double r = 0, double i = 0) : re(r), im(i) {}
    
    // 取值函数（const 成员函数）
    double real() const { return re; }
    double imag() const { return im; }
    
    // 操作符重载（成员函数形式）
    Complex& operator+=(const Complex&);
    
    // 更多成员函数...
};

// 全局函数声明（非成员操作符重载）
Complex operator+(const Complex&, const Complex&);
Complex operator+(const Complex&, double);
Complex operator+(double, const Complex&);

bool operator==(const Complex&, const Complex&);
bool operator!=(const Complex&, const Complex&);

ostream& operator<<(ostream&, const Complex&);

#endif
```
#### 2.2 访问级别规范

|访问级别|内容|示例|
|---|---|---|
|**公有接口**|构造函数、操作符重载、取值函数|`real()`, `imag()`, `operator+=`|
|**私有数据**|类的内部数据成员|`re`, `im`|
|**友元函数**|特殊操作函数|`doapl()`|

#### 2.3 类设计要点

1. **初始化列表**：必须掌握的高效初始化方式
    
2. **const 修饰**：不改动对象状态的成员函数必须加 `const`
    
3. **参数传递**：优先使用 pass by reference，必要时加 `const`
    
4. **返回值**：根据情况选择 return by value 或 by reference
    
5. **封装性**：数据成员应设为 private，接口函数设为 public
    
6. **函数定义**：简单函数可直接在类内定义，复杂函数在外部定义
    

---

## 三、知识小结

### 核心知识点速查表

|知识点|核心内容|考试重点/易混淆点|难度系数|
|---|---|---|---|
|**操作符重载**|C++允许重新定义操作符功能，复数类通过重载实现数学运算|成员函数与非成员函数两种实现方式差异|★★★★★|
|**复数类设计**|标准库复数类的简化实现，包含实部/虚部操作|临时对象创建语法 `ClassName()` 与命名对象区别|★★★|
|**this指针机制**|所有成员函数隐含的 `this` 参数指向调用对象|编译器自动处理指针传递，不可显式声明|★★★|
|**引用传递优化**|参数传递优先使用 `const` reference 提升效率|pass by reference 与返回值引用陷阱（局部对象禁止返回引用）|★★★|
|**运算符返回类型**|链式操作要求返回非 `void` 类型（如 `cout << a << b`）|加等运算符必须返回引用以支持连续赋值|★★★|
|**友元函数应用**|输出运算符 `<<` 必须设计为全局函数|标准库 `ostream` 无法修改导致不能使用成员函数重载|★★★|
|**临时对象管理**|复数运算时通过 `Complex(r,i)` 创建匿名对象|生命周期仅限当前表达式，必须按值返回|★★★|
|**常量正确性**|成员函数 `const` 修饰保证对象状态不被修改|输出运算符因改变流状态禁止 `const` 修饰参数|★★★|

---

## 四、常见问题与注意事项

### 1. 什么时候用成员函数？什么时候用非成员函数？

- **成员函数**：当操作会修改左操作数时（如 `+=`、`-=`）
    
- **非成员函数**：
    
    - 当左操作数不是自定义类时（如 `<<`）
        
    - 当需要支持对称操作时（如 `实数+复数` 和 `复数+实数`）
        
    - 当操作不会修改操作数时（如 `+`、`==`）
        

### 2. 返回引用 vs 返回值

**<span style="color: #e74c3c;">黄金法则</span>**：

- 如果返回的是**函数内创建的局部对象** → 必须返回值
    
- 如果返回的是**已存在的对象**（如 `*this`）→ 可以返回引用
    

### 3. const 的正确使用

```cpp

// 正确示例：
double real() const { return re; }  // 不修改对象，加 const
Complex& operator+=(const Complex&); // 修改对象，不加 const

// 输出运算符不能加 const：
ostream& operator<<(ostream& os, const Complex& x);  // os 不能加 const
```
### 4. 效率优化技巧

1. 参数传递尽量使用 `const` 引用
    
2. 简单函数使用 `inline`
    
3. 构造函数使用初始化列表
    
4. 能返回引用时尽量返回引用
    
5. 使用临时对象避免不必要的命名变量
    

---

## 五、练习与思考

### 思考题

1. 为什么 `operator+` 不能返回引用，而 `operator+=` 可以？
    
2. 如果忘记在成员函数后加 `const` 会有什么后果？
    
3. 为什么 `cout << c1 << c2;` 能正常工作？画出函数调用链。
    
4. 如何实现一个支持 `c1 = c2 + 3 + 4.5 + c3` 的复数类？
    

### 扩展练习

1. 实现完整的复数类，支持所有基本运算
    
2. 为复数类添加乘法、除法运算
    
3. 实现一个简单的三维向量类，重载 `+`、`-`、`*`（点积）、`<<` 等操作符
    
4. 思考：如果复数类使用指针存储实部和虚部，设计需要做哪些改变？
    

---

通过本笔记的学习，你应该能够：

1. 理解操作符重载的基本概念和两种实现方式
    
2. 掌握 `this` 指针的工作原理
    
3. 区分何时使用成员函数 vs 非成员函数
    
4. 理解临时对象的生命周期和正确使用方法
    
5. 设计一个完整的自定义类并重载常用操作符
    
6. 避免常见的引用和常量错误
    

记住：**操作符重载的目的是让自定义类型用起来像内置类型一样自然直观**，但永远不要为了重载而重载，保持代码的清晰和正确性永远是第一位的。
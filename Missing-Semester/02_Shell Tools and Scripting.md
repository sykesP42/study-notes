*所有实例运行在Linux上的bash*

## shell (bash)
#### "空格"很重要

```bash
#✅
foo=bar

#❌
foo = bar 
```

#### 定义字符串

- **方法一**：使用==`'`==
- **方法二**：使用==`"`==

| 对于      | 纯文本 | 使用$  |
| ------- | --- | ---- |
| ==`'`== | 无差异 | 不会替换 |
| ==`"`== | 无差异 | 会替换  |
```bash
foo=bar

echo "Val is $foo"
#Val is bar

echo 'Val is $foo'
#Val is $foo
```

#### 定义函数

- 实例`mcd`函数：
```bash
vim mcd.sh

mcd () {
	mkdir -p "$1"
	cd "$1"
}
```

- **==`$1`==** ：特殊变量。bash特性，类似于其他脚本语言的 **==`agrv`==**，此处为访问第一个参数。
	- 此外还有很多保留关键字，如：
		- `$0` ：脚本的名称
		- `$2` 到 `$9` ：依次为bash脚本接收的第二到第九个参数。
		- `$?` ：获取上一个命令的错误代码。
		- `$_` ：获取上一个命令的最后一个参数。
		- `$#`：命令的参数数量。
		- `$$`：该命令的进程ID（PID）。
		- `#@`：展开为所有的参数。

- **==`mkdir -p`==** ：递归创建多级目录。

##### 加载脚本 ==`source`==
```bash
source mcd.sh
#载入mcd.sh

mcd test
#目录移动到test，成功运行脚本
```

-

#### 常用命令：

##### **==`!!`== 会替换成上一次的命令**
*当尝试创建某些东西但没有权限的时候很有用*

```bash
mkdir /mnt/new
#提示无权限

sudo !!
#创建成功
```

##### **==`;`== 连接到同一行**
```bash
false ; echo "12345"
#12345
```

#### 标准错误流

##### 错误代码

- 例子：
```bash
echo "123"
#123

echo $?     #显示错误代码
#0          #0表示没有错误

grep foobar mcd.sh
echo $?
#1          #"mcd.sh"中没有"foobar"字符串，grep不会输出任何内容，返回错误代码1
```


- **==`true`==** ：错误代码始终为0
- **==`false`==** ：错误代码始终为1

#### 逻辑表达式

##### OR ||

```bash
command1 || command2
```

- 在这个 **逻辑或表达式** 中，会先执行第一个命令，如果第一个命令失败了，则会执行第二个命令。
- 如果第一个命令失败，则会直接跳过第二个命令。称为 ==**`短路`**==

```bash
false || echo "Oops fail"
#Oops fail

true || echo "Oops fail"
#(不输出)
```

##### AND &&

```bash
command1 && command2
```
- 同理，**逻辑与表达式** 中只有在第一个命令没错的情况下才会执行第二个命令。
- 如果第一个命令失败，则不会执行第二个命令。

```bash
false || echo "Things went well"
#(不输出)

true || echo "Things went well"
#Things went well
```

#### 输出存储到变量

```bash
foo=$(pwd)        #存储当前位置路径

echo $foo
#(当前位置路径)
```

#### 命令替换

- 一种在Unix、Linux和类Unix操作系统中常见的技术，用于在一个命令的输出中嵌套另一个命令。

```bash
echo "We are in $(pwd)"
#We are in (当前位置路径)
```

#### 进程替换

```bash
cat <(ls) <(ls ..)
```
- 此命令会内部执行，然后将输出放在一个类临时文件的东西中，并将文件标识符提供给**最左边的命令**。
- 增加了便利性。因为一些命令不是从标准输入流中输入的，可能是<font color="#245bdb">从某个文件获取</font>。
- 最终得到了**两个命令连接在一起的输出**。


#### **Unix/Linux 的三个标准流**

每个程序运行时都有三个默认的输入/输出通道：
```
标准输入 (stdin)   -- 文件描述符 0  -- 键盘输入
标准输出 (stdout)  -- 文件描述符 1  -- 正常输出到屏幕
标准错误 (stderr)  -- 文件描述符 2  -- 错误信息输出到屏幕
```
就像人有两只手，程序也有"两只输出手"：

- 左手（标准输出）：输出正常结果
- 右手（标准错误）：输出错误信息

##### **那么 `2>` 呢？**
`2>` 就是"专门引导错误信息的管道"！

- `>` 或 `1>` 重定向 **标准输出**（文件描述符1）
    
- `2>` 重定向 **标准错误**（文件描述符2）

例子对比：
```bash
# 情景：假设当前目录有一个文件 a.txt，没有 b.txt

# 正常执行，两种输出都会显示
grep "hello" a.txt b.txt

# 输出示例：
# a.txt:hello world  ← 这是标准输出（找到的结果）
# grep: b.txt: No such file or directory ← 这是标准错误（错误信息）

# 只重定向标准输出（错误信息还会显示）
grep "hello" a.txt b.txt > results.txt
# 屏幕会显示错误，但正常结果保存到 results.txt

# 只重定向标准错误（正常结果还会显示）
grep "hello" a.txt b.txt 2> errors.txt
# 屏幕会显示找到的结果，但错误信息保存到 errors.txt
```


- 这个命令做了两件事：
```bash
grep foobar "$file" > /dev/null 2> /dev/null
```

1. `> /dev/null` → 把**正常输出**（找到的结果）丢弃到"黑洞" `/dev/null`
    
2. `2> /dev/null` → 把**错误信息**也丢弃到"黑洞" `/dev/null`
    

**就像这样：**


```text

          grep命令
          /       \
         /         \
  标准输出(左手)    标准错误(右手)
        ↓               ↓
    到黑洞/null      到黑洞/null
    
结果：用户什么都看不到，完全安静地执行
```
##### 实际应用场景

**为什么需要这样？**
```bash

# 在脚本中检查某个文件是否包含特定内容，不关心输出内容，只关心是否找到
if grep foobar "$file" > /dev/null 2> /dev/null; then
    echo "找到了！"
else
    echo "没找到或文件不存在"
fi
```
如果不加 `2> /dev/null`：
- 如果文件不存在，会显示错误信息"没有那个文件或目录"
- 加了之后，文件不存在的错误信息也被"吞掉"，脚本更干净
##### 常见变体
```bash
# 把两种输出合并后重定向（标准错误合并到标准输出）
command > output.txt 2>&1
# 或更现代的写法：
command &> output.txt

# 分别重定向到不同文件
command > output.txt 2> errors.txt

# 只丢弃错误信息，保留正常输出
command 2> /dev/null

# 丢弃所有输出（你的例子）
command > /dev/null 2> /dev/null
```
##### 记忆技巧

1. **数字记忆法**：
    - `1` = 标准输出（通常省略）
    - `2` = 标准错误
2. **比喻法**：
    - 把程序想成一个有两个出口的水管
    - `>` 是堵住主水管（标准输出）
    - `2>` 是堵住漏水的副水管（标准错误）
3. **位置关系**：

```bash

# 总是先写文件描述符数字，再写重定向符号
2>   # 正确
>2   # 错误！（这会创建名为"2"的文件）
```

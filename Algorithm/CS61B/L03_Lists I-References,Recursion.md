# 引用、递归与链表
## 一、引用 vs. 基本类型：核心区别

### 1.1 从“海象”例题说起

想象一个`Walrus`类，它有`weight`和`tuskSize`两个属性。


```java

Walrus a = new Walrus(1000, 8.3);
Walrus b = a; // 关键在此行
b.weight = 5;
```
**问题**：`a.weight`现在是多少？

**答案**：是`5`。因为`b = a`复制的是**引用**（内存地址），而不是对象本身。`a`和`b`如同两张指向**同一个宝箱**的藏宝图，无论用哪张图找到宝箱并修改其中的宝物，另一张图指向的依旧是那个被修改了的宝箱。

> **💡 核心比喻**：
> 
> - **基本类型**（如`int`）：变量是**保管箱**。`int y = x;`是把`x`保管箱里的**值**（例如数字5）**复制一份**，放到`y`的新保管箱里。修改`x`，`y`不变。
>     
> - **引用类型**（如`Walrus`）：变量是**藏宝图**。`Walrus b = a;`是把藏宝图`a`**复印一份**得到`b`，两张图指向**同一个宝箱**。通过任何一张图修改宝箱里的东西，另一张图看到的也是修改后的结果。
>     

### 1.2 “等号”（`=`）的黄金法则

无论对于基本类型还是引用类型，`=` 的操作在底层是**统一**的：

> **将等号右边变量代表的那些二进制位 (bits)，原样复制到等号左边变量代表的内存位置中。**

区别在于这些“位”所代表的**意义**：

- **基本类型**：这些位直接代表**数值本身**。
    
- **引用类型**：这些位代表一个**内存地址**（即“引用”）。
    

```java

// 基本类型示例
int x = 5; // 变量x的“位”存储的是二进制形式的5
int y = x; // 将表示5的位复制给y
x = 2;     // 修改x的位为2，y的位仍是5，不受影响。

// 引用类型示例
Walrus a = new Walrus(); // 变量a的“位”存储的是对象在内存中的地址，比如“0x7a3f”
Walrus b = a; // 将地址“0x7a3f”复制给b。现在a和b指向内存中同一个对象。
```
### 1.3 参数传递同样是“复制位”

Java中的参数传递**严格遵循“按值传递”**，即“复制位”的黄金法则。

java

public static void doSomething(Walrus walrus, int x) {
    walrus.weight = 5; // 这会影响外部的实际对象，因为传入的walrus是外部引用的副本，但指向同一对象。
    x = 10;            // 这不会影响外部的x，因为传入的x是外部值的副本。
}

记住：传递引用类型时，传递的是**引用的副本**，而非对象本身的副本。

## 二、数组与链表的起点

### 2.1 Java数组的本质

在Java中，**数组也是对象**，属于引用类型。

```java

int[] x; // 1. 声明：仅为引用变量x分配空间（64位，用于存放地址），此时如同空藏宝图。
x = new int[]{0, 1, 2, 95, 4}; // 2. 实例化：创建数组对象，并将它的地址赋给x。
```
- 数组对象在内存中连续存储。

- 如果数组元素是基本类型（如`int[]`），则连续存储**值**。

- 如果数组元素是引用类型（如`String[]`），则连续存储**引用（地址）**。


### 2.2 为什么需要链表？

Java原生数组有一个**固有缺陷：大小固定**。`new int[5]`一旦创建，容量就永远是5。链表（Linked List）就是为了实现**动态扩容**而设计的基础数据结构。

## 三、链表的定义与构建 (IntList)

### 3.1 IntList：一个最简单的链表

链表由“节点”串联而成。`IntList`是课程自定义的整数链表节点类：

```java

public class IntList {
    public int first;      // 当前节点存储的值
    public IntList rest;   // 指向下一个节点的引用

    public IntList(int f, IntList r) {
        first = f;
        rest = r;
    }
}
```
**关键理解**：

- 每个`IntList`对象是一个“节点”。

- `rest`成员变量是一个**引用**，它指向**另一个`IntList`节点对象**。

- 最后一个节点的`rest`应为`null`，表示链表结束。


### 3.2 构建链表的两种方式

**方式一：正向拼接 (繁琐)**

```java

IntList L = new IntList(); // 假设有无参构造
L.first = 5;
L.rest = new IntList();
L.rest.first = 10;
L.rest.rest = new IntList();
L.rest.rest.first = 15; // L: 5 -> 10 -> 15 -> null
```
这种方式在链表长时代码会非常冗长。

**方式二：递归/反向构建 (优雅)**  
这是更常见和简洁的方式，利用了构造器：

```java

// 从尾部开始构建：先创建最后一个节点，然后让前一个节点指向它
IntList L = new IntList(15, null);    // 节点3: (15, null)
L = new IntList(10, L);               // 节点2: (10, ->节点3)
L = new IntList(5, L);                // 节点1: (5, ->节点2)
// 最终 L: 5 -> 10 -> 15 -> null
```
## 四、链表的核心操作：递归与迭代

### 4.1 计算链表长度：`size()`

这是展示**递归思维**的绝佳例子。

**递归实现**：

```java

public int size() {
    // 1. 基准情况：如果后面没有节点了，那么当前链表就只有自己这一个节点
    if (rest == null) {
        return 1;
    }
    // 2. 递归情况：当前链表长度 = 1 (自己) + 后面子链表的长度
    return 1 + this.rest.size();
}
```
**递归过程图解** (`L: 5 -> 10 -> 15 -> null`)：

```text

L.size()
= 1 + (10->15->null).size()
= 1 + (1 + (15->null).size())
= 1 + (1 + (1))  // (15->null)遇到基准情况，返回1
= 3
```
**迭代实现**：  
对于初学者，迭代（循环）有时更直观。

```java

public int iterativeSize() {
    IntList p = this; // 创建一个指针p，初始指向当前节点
    int totalSize = 0;
    while (p != null) { // 只要p指向一个真实节点就继续
        totalSize += 1;
        p = p.rest; // 将指针p移动到下一个节点
    }
    return totalSize;
}
```
### 4.2 获取第 i 个元素：`get(int i)`

同样可以用递归优雅解决。

```java

public int get(int i) {
    // 基准情况：想要第0个元素，就是当前节点的值
    if (i == 0) {
        return this.first;
    }
    // 递归情况：当前节点的第i个元素，就是剩余链表的第(i-1)个元素
    return this.rest.get(i - 1);
}
```
**示例**：`L.get(2)` 求 `5 -> 10 -> 15 -> null` 中索引为2的元素。

```text

L.get(2)
= L.rest.get(1)   // i=2，所以在剩余链表(10->15->null)上找第(2-1)=1个
= L.rest.rest.get(0) // i=1，所以在剩余链表(15->null)上找第(1-1)=0个
= 15 // 遇到基准情况 i==0，返回15
```
## 五、知识小结与思维提升

|知识点|核心内容|初学易混淆点|
|---|---|---|
|**引用 vs 基本类型**|引用是内存地址，基本类型是直接值。`=` 统一复制“位”。|误以为 `b = a` 会为对象创建副本。应牢记：**复制的是引用，而非对象**。|
|**参数传递**|Java严格“按值传递”，即传递的是变量值的副本。对于引用类型，传递的是地址副本。|误以为是“按引用传递”。实际上，在方法内让形参引用新对象，**不会影响**实参的引用。|
|**链表节点**|节点包含数据(`first`)和指向下一个节点的引用(`rest`)。`null`表示链表结束。|混淆节点对象和节点的引用。`rest`是一个“盒子”，里面装的是下一个节点的**地址**。|
|**递归思维**|1. 找**基准情况**（最简单、可直接求解的情况）。  <br>2. 将大问题分解为结构相同的**更小问题**（递归情况）。|1. 缺少基准情况导致无限递归。  <br>2. 递归“跳跃”太大，难以跟踪。建议画图或使用小例子手动模拟。|
|**递归 vs 迭代**|递归代码简洁，贴近数学定义；迭代性能稍好，更易理解流程控制。|对于链表的简单操作，两种方式都应掌握。递归是理解后续复杂数据结构（树、图）的关键。|

### 5.1 思维练习

1. **`incrList`方法**：写一个方法，传入一个`IntList`和一个整数`x`，返回一个**新的**链表，其中所有元素值都增加了`x`。**原链表不应被修改**。
    
2. **`dincrList`方法**：写一个方法，功能同上，但直接**修改原链表**，不创建任何新节点。
    

通过解决这两个问题，你能深刻理解**通过引用修改对象**与**创建新对象**的区别，这是掌握引用和链表操作的重要一步。
# 💻 软件工程 I（Software Engineering I）—— 从代码到系统：复杂性、策略与版本控制

> 本文是 CS61B Spring 2024 Lecture 27 的详细笔记，主题从“写代码”转向“工程化编程”，探讨软件工程中的核心挑战：**复杂性管理**、**战略 vs 战术编程**、**模块化设计**、**测试策略**以及**版本控制与发布分析**。通过真实案例（Retool、Spotify、Windows、Git 图分析）和理论结合，帮助你建立工业级软件开发的思维方式。

---

## 🧭 一、引言：从 61A 到 61B 的转变

### 1.1 61A 与 61B 的区别

- **61A**：关注程序的**正确性**——你的代码能否按预期运行？
    
- **61B**：关注**工程选择**——在多种实现方式中，根据**权衡（tradeoffs）**做出决策。
    
    - 例如：`ArrayList` vs `LinkedList`，`TreeMap` vs `HashMap`，不同的数据结构在不同场景下各有优劣。
        
- 工程项目规模增大，但仍有规范限制（如函数接口、运行时间复杂度）。
    
- **项目 3（Project 3）**：你将自主构建一个世界，体验大规模项目设计，自己定义任务，而非遵循固定规格。
    

### 1.2 工程限制的本质

传统工程受物理限制（如材料强度、温度），而**软件工程的限制来自设计选择**，而非计算能力。

- 阿波罗登月任务的总计算能力小于现代手机，但他们仍然完成了任务。
    
- 关键转变：从“能做什么”到“选择做什么”。
    

### 1.3 计算能力的发展与影响

- **ENIAC（1946）**：占地整个房间，使用真空管，被认为是超级计算机（比同期快 1000 倍）。
    
- **RollerCoaster Tycoon（1999）**：99% 用汇编编写，1% 用 C，针对 66 MHz 的 Pentium CPU 优化。开发极其困难，需直接操作 CPU 和内存。
    
- **现代游戏（如 Minecraft）**：最低要求 2GB 内存、3.2GHz 处理器，而 1996 年普通电脑只有 8-16MB 内存。
    
- **启示**：平均软件产品不需要用尽全部计算能力，因此我们可以用更高级的语言（如 Java、Python）编写，牺牲一点性能换取开发效率和可维护性。
    

---

## 🧩 二、软件复杂性（Software Complexity）

### 2.1 复杂性的定义

> **“任何与软件系统结构相关，使其难以理解和修改的东西。”**  
> —— John Ousterhout，《A Philosophy of Software Design》

- 与运行时复杂度（时间复杂度）不同，这里关注的是**代码的组织结构**。
    
- 随着功能增加，复杂度自然上升，但我们的目标是**保持简单**。
    

### 2.2 复杂性的代价

- **理解困难**：解释一段复杂代码可能需要 5-10 分钟。
    
- **调试困难**：难以定位需要修改的部分。
    
- **扩展困难**：存在“未知的未知”——你不知道自己需要知道什么。
    

### 2.3 例子：Spotify 的代码复杂性

（图示略）想象一个大型音乐服务，功能繁多（播放、歌单、推荐、社交等），代码相互依赖，一个小小的改动可能影响全局。复杂性管理成为重中之重。

### 2.4 复杂性的分类

- **必要复杂性**：功能本身固有的复杂度（如音乐播放器必须有播放/暂停功能）。
    
- **可避免复杂性**：由设计决策导致的不必要的复杂度。
    
    - 应对方法：
        
        - **代码简化**：使用清晰的变量名、结构（如 Project 1 中的哨兵节点简化链表操作）。
            
        - **模块化**：通过抽象隐藏实现细节（如 Java 的 `Map` 接口，用户无需知道底层是 `TreeMap` 还是 `HashMap`）。
            

### 2.5 复杂性管理的普适性

- **软件工程**：大型系统开发（如 Spotify）
    
- **数据科学**：数据管道构建与洞察提取
    
- **机器学习**：复杂模型与版本控制
    
- **人机交互**：功能增加时的界面设计
    
- **业务分析**：多分析师协作时的功能协调
    

任何涉及“功能及其交互”的领域都需要管理复杂性。

---

## ⚔️ 三、战术编程 vs 战略编程

### 3.1 战术编程（Tactical Programming）

**核心特征**：专注于快速实现功能，常采用大量变通方案和快捷方式。

**典型表现**：

- 通过添加嵌套 `if` 语句处理各种特殊情况。
    
- 代码难以解释和维护（例如：不断添加 `if` 修复测试失败，却导致其他测试失败）。
    

**适用场景**：

- 原型开发
    
- 概念验证（PoC）
    
- 需要快速演示的场合（如向投资人融资）
    

**潜在问题**：

- 设计时间投入不足。
    
- 代码复杂度随变通方案增加而上升。
    
- 重构困难，可能需要完全重写（例如 Project 2 中忽略运行时要求，导致构造函数需要重做）。
    

**现实案例**：

- 微软 Windows 系统中的遗留代码（新旧控制面板并存）。
    
- 初创公司早期代码最终被部署到生产环境，成为技术债务。
    

### 3.2 战略编程（Strategic Programming）

**核心理念**：强调长期战略而非快速修复，以规划时间为代价编写优雅代码。

**关键特征**：

- **可维护性**：代码应易于更新、修复 bug 和修改。
    
- **简洁性**：他人能够理解并接手维护。
    
- **未来适应性**：设计能持续数十年的代码。
    

**与学术项目的区别**：

- 课程项目有明确截止日期，完成后可丢弃。
    
- 实际项目（研究模型、公司产品等）需要长期维护。
    

**实施要点**：

- 允许策略调整（不要求初始策略完美）。
    
- 通过设计文档预先规划（如 Project 2B/2C 的设计文档要求）。
    

**行业案例**：

- 流媒体服务（如 Spotify）需要考虑长期功能演进。
    
- 银行系统维护数十年的代码库。
    

---

## 🛠️ 四、资源配置与测试：Retool 案例研究

### 4.1 Retool 是什么？

Retool 帮助开发者快速构建内部工具，通过连接 API 和数据库简化开发流程。  
用户只需编写查询语句并链接到拖放组件，无需维护前后端基础设施。

**例子**：制作一个调查问卷结果展示页面。传统方式需要开发网站、服务器、数据库，而 Retool 可一站式解决。

### 4.2 资源配置的挑战

最初，Retool 为每个资源（如 Google Sheets、MySQL、PostgreSQL 等）单独开发配置页面。问题：

- **维护困难**：修改 54+ 个集成点时，工作量大。
    
- **一致性问题**：不同页面的文案、logo 可能不一致。
    
- **破坏性变更**：接口变更（如 `List.size()` 改为 `length`）需全局修改。
    
- **新增复杂**：添加新资源需要大量复制粘贴，易出错。
    

### 4.3 解决方案：模块化设计

Retool 引入了 **ResourceConfig 接口**，描述资源的通用属性（如主机名、端口、路径等）。通过传入配置参数，自动生成配置表单。

- **模式复用**：数据库类资源共享 `host/port/name` 等通用字段。
    
- **灵活扩展**：非数据库资源可接受自定义属性。
    

### 4.4 验证函数与缺失字段

- 每个资源配置内置**验证函数**，类似 Java 编译器检查类型错误。调用者无需知道具体资源类型，即可验证配置是否有效。
    
- **用户需求**：不仅告知验证失败，还需明确缺失的具体字段（如“Google Sheets URL 不能为空”）。不清晰的错误提示可能导致客户流失。
    
- 解决方案：重构验证逻辑，返回**缺失字段列表**，验证通过 ⇔ 列表为空。
    

### 4.5 测试的重要性

- Retool 为通用数据库资源编写**模式化测试**，覆盖所有输入输出组合。
    
- 建立**模拟资源（样本数据库）**验证查询功能。
    
- 对特殊资源（如 Elasticsearch）手动编写关键测试用例。
    
- **持续集成**：所有变更都运行完整测试套件，确保全局一致性。
    
- **商业影响**：客户支付百万美元服务费时，测试失败直接等于收入损失。
    

---

## 🔀 五、版本控制与发布策略：Git 图分析问题

### 5.1 问题背景

在大型软件开发中，我们需要回答：**某个代码变更（commit）被包含在哪些发布的版本中？**  
例如：

- 验证某个 bug 修复是否通过了质量保证测试。
    
- 比较不同版本的用户采用率。
    

**发布限制**：

- 移动设备不会接收所有更新（用户可能几个月才更新一次）。
    
- 内部代码提交与用户端版本发布存在明显延迟（如 Apple 每年一次大版本更新，中间只推送少量次要更新）。
    

### 5.2 Git 图的基本概念

- 每个 **commit** 是图中的一个节点。
    
- 边从 commit 指向其**父提交**（有向边）。
    
- 普通 commit 有 1 个父节点，**合并 commit** 可能有多个父节点。
    
- 绿色标记的提交表示**已部署给用户**的版本。
    

### 5.3 问题示例：找出包含 commit C 的部署提交

给定 Git 图（如下示意）：

text

A ← B ← C ← D ← E ← G
      ↖           ↗
        F ←─── H

绿色提交：C, D, G（假设）。问：哪些部署提交包含 C 的变更？

**解法**：从 C 开始，沿正向（子节点方向）找所有后代，筛选出绿色的。

- 后代：D, E, G, H（注意 H 也是 C 的后代吗？从图看，H 的父节点是 F 和 E？需具体分析）。但实际答案：C, D, G（假设 H 不是部署提交）。
    

**易错点**：

- 不要包含非部署提交（如 E、F）。
    
- 需要包含变更源提交本身（C），如果它也是部署提交。
    

### 5.4 两种方法：反向工作 vs 正向工作

#### 反向工作（从后向前）

Git 原生设计支持：通过 `git log` 等命令可以知道每个 commit 的父节点。从最新提交开始逆向追踪，回溯历史。  
✅ 符合直觉，易实现。

#### 正向工作（从前向后）

从右侧最新提交开始，通过检查每个 commit 的父节点关系正向推进。  
❌ 难点：

- 需要获取所有终端提交（各分支最新）。
    
- 必须检查每个 commit 的时间戳。
    
- 遇到目标 commit C 时停止，但需回溯到所有父节点时间戳均早于 C 时才能终止。
    
- 分支多时极其复杂，维护成本高。
    

**结论**：反向工作更优。

### 5.5 改进方案：构建 commit-child 映射

Git 只存储父节点信息（因为子节点是“未来”的，创建时未知）。但我们可以通过一次遍历，构建**从父节点到子节点列表的映射**（即邻接表）。

- **构建图**：反向读取所有 commit，建立 `parent → list of children`。
    
- **生成已部署集合**：用 `HashSet` 存储所有绿色部署提交（O(1) 查找）。
    
- **BFS 搜索**：从目标 commit 开始 BFS，遍历所有后代，检查是否在部署集合中。
    

**优势**：

- BFS 直观，且可复用构建好的图。
    
- 多人查询时，只需执行第三步。
    
- 时间复杂度：构建图 O(N)，BFS O(后代数)，整体分钟级或高秒级，远优于人工处理。
    

---

## 📦 六、解决方案总结

|步骤|操作|数据结构|复杂度|
|---|---|---|---|
|1. 构建提交图|反向遍历所有 commit，记录每个节点的子节点|邻接表（`Map<Commit, List<Commit>>`）|O(总提交数)|
|2. 收集已部署提交|将绿色提交存入集合|`HashSet<Commit>`|O(部署数)|
|3. BFS 搜索|从目标 commit 开始 BFS，检查每个访问节点是否在部署集合中|队列 + 标记数组|O(后代数)|

**关键思想**：用空间换时间，预处理图结构，使查询高效。

---

## 🧠 七、知识点总结（彩色标记）

|主题|核心内容|<span style="color:red">重点/易错点</span>|
|---|---|---|
|软件复杂性|任何使系统难以理解和修改的结构特性，需通过模块化、简化管理|<span style="color:red">区分必要复杂性与可避免复杂性；复杂性 ≠ 运行时复杂度</span>|
|战术编程|快速实现功能，常用变通方案，适用于原型开发|<span style="color:red">长期维护困难，易产生技术债务</span>|
|战略编程|注重长期可维护性，提前设计，代码简洁|<span style="color:red">需要前期投入，但降低后期成本</span>|
|模块化设计|通过抽象接口隐藏实现细节，降低耦合|<span style="color:red">例如 `ResourceConfig` 统一配置表单生成</span>|
|测试策略|模式化测试 + 模拟资源 + 持续集成|<span style="color:red">测试失败直接经济损失；需明确错误字段</span>|
|Git 图分析|构建 commit-child 映射，用 BFS 查找包含某变更的部署版本|<span style="color:red">反向工作更直观；邻接表存储子节点</span>|
|发布策略|内部提交与用户版本存在延迟，需追踪变更包含情况|<span style="color:red">移动设备更新周期长，不能假设所有提交都会立即发布</span>|

---

## 💡 八、思考题与答案

### 1. 为什么软件工程的“复杂性”与算法课的“时间复杂度”不同？

**答案**：时间复杂度是衡量程序运行快慢的数学概念，而软件复杂性指代码结构的混乱程度，影响的是人类理解、修改和扩展的成本。两者都很重要，但管理复杂性是长期维护的关键。

### 2. 战术编程在什么情况下是合理的？

**答案**：

- 快速原型验证想法。
    
- 向投资人展示概念。
    
- 一次性脚本或工具。
    
- 但一旦代码要投入生产长期使用，就必须转向战略编程，偿还技术债务。
    

### 3. Retool 的资源配置器如何体现模块化设计？

**答案**：通过定义 `ResourceConfig` 接口，将所有资源的通用属性抽象出来，并内置验证方法。新增资源只需实现接口，配置表单自动生成，无需为每个资源单独开发页面。这降低了耦合，提高了可维护性。

### 4. 在 Git 图分析中，为什么构建 commit-child 映射比每次从父节点搜索更好？

**答案**：Git 本身只存储父节点，若要正向查找所有后代，需要遍历整个图多次。而预先构建 child 映射后，只需一次 BFS 就能得到所有后代，且可复用，适合频繁查询的场景。

### 5. 如果图中有合并提交（多个父节点），BFS 查找后代时需要注意什么？

**答案**：合并提交有多个父节点，但子节点列表仍然正常。在 BFS 时，从目标 commit 出发，沿着 child 边前进，合并提交本身也是一个节点，它的子节点就是它的后代。无需特殊处理，因为 child 映射已经包含了所有子节点。

### 6. 为什么已部署提交要用 `HashSet` 而不是 `List`？

**答案**：查找一个 commit 是否已部署是核心操作，`HashSet` 提供 O(1) 平均时间，而 `List` 需要 O(n) 扫描。且部署提交集合无需保持顺序，也不允许重复，`HashSet` 天然合适。

### 7. 在 Retool 的验证函数中，为什么需要返回缺失字段列表，而不是简单的布尔值？

**答案**：用户体验要求：当配置无效时，用户需要知道具体哪里错了，才能快速修正。模糊的“验证失败”会导致客户困惑，甚至流失。明确缺失字段能提升产品易用性。
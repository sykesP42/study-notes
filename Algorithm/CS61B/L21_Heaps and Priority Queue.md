# 📚 堆与优先队列（Heaps and Priority Queue）—— 从抽象数据类型到高效实现

> 本文是 CS61B Spring 2024 Lecture 21 的详细笔记，全面讲解优先队列的概念、应用场景、多种实现的对比，以及**二叉堆**这一经典数据结构的原理、操作、实现细节与复杂度分析。通过大量示例和思考题，帮助你彻底掌握堆与优先队列。

---

## 🧭 一、优先队列（Priority Queue）概述

### 1.1 什么是优先队列？

**优先队列**是一种抽象数据类型（ADT），它与普通队列（FIFO）不同，**每次出队的是当前优先级最高（或最低）的元素**。通常我们讨论**最小优先队列（MinPQ）**：可以高效获取和删除最小的元素。

#### 核心接口（MinPQ）

```java

public interface MinPQ<Item> {
    void add(Item x);          // 添加一个元素
    Item getSmallest();        // 返回当前最小的元素（不删除）
    Item removeSmallest();     // 移除并返回最小的元素
    int size();                // 返回队列中的元素个数
}
```
- 用户**只能与最小元素交互**，无法直接访问其他元素。
    
- 适用于需要动态追踪“最佳”、“最急迫”元素的场景。
    

### 1.2 典型应用场景

#### 场景1：记录最高能量的粒子

假设有一个粒子探测器，每天记录大量粒子的能量，我们只关心能量最高的 M 个粒子。

- **朴素方法**：存储所有粒子，最后排序取前 M 个 → 空间 O(N)，时间 O(N log N)。
    
- **使用优先队列优化**：维护一个大小为 M 的**最小堆**（MinPQ），每次加入新粒子，如果堆大小超过 M，就移除当前最小的（即最差的），最终堆中留下的就是 M 个能量最高的粒子。
    
    - 空间复杂度 O(M)，每个粒子处理时间 O(log M)。
        

#### 场景2：任务调度、Dijkstra 算法、Huffman 编码等

这些算法都需要动态获取当前优先级最高的元素，优先队列是核心工具。

---

## 🧪 二、优先队列的几种糟糕实现

在介绍堆之前，我们先看看如果用已经学过的数据结构来实现优先队列，会有什么问题。

### 2.1 有序数组（Ordered Array）

- **实现**：维护一个始终排序的数组（如升序）。
    
- **add**：需要找到插入位置并移动元素 → **O(N)**
    
- **getSmallest**：直接取第一个元素 → **O(1)**
    
- **removeSmallest**：移除第一个元素，后面所有元素前移 → **O(N)**
    

**问题**：插入和删除太慢。

### 2.2 平衡二叉搜索树（如 LLRB、2-3树）

- **add**：O(log N)
    
- **getSmallest**：一直往左子树找 → O(log N)（如果维护最小指针可做到 O(1)）
    
- **removeSmallest**：删除最小节点 → O(log N)
    
- **主要问题**：
    
    - 处理重复优先级非常麻烦（BST 通常假设键唯一）。
        
    - 实现复杂，需要保持平衡。
        

### 2.3 哈希表

- **add**：平均 O(1)
    
- **getSmallest / removeSmallest**：必须扫描所有桶才能找到最小值 → **O(N)**
    
- **根本缺陷**：哈希表无序，不适合需要按优先级访问的场景。
    

### 2.4 小结：理想优先队列的期望特性

- add, getSmallest, removeSmallest 都达到 **O(log N)** 或更好
    
- 优雅处理重复优先级
    
- 实现简单，内存高效
    

---

## 🌲 三、二叉堆（Binary Heap）的诞生

**二叉堆**是一种专门为优先队列设计的数据结构，它是一棵**完全二叉树**，同时满足**堆序性**（这里以最小堆为例）。

### 3.1 堆的两个关键性质

#### 1. 最小堆性质（Min-Heap Property）

> 每个节点的值**小于等于**它的两个子节点的值。

- 因此，**根节点是整个堆中最小的元素**。
    
- 允许重复值（这与 BST 不同，BST 通常不允许重复或处理麻烦）。
    

#### 2. 完全性（Completeness）

> 除了最底层，其他层都是满的；最底层的节点尽可能靠左排列。

- 这意味着堆可以用**数组紧凑表示**，无需显式指针。
    

#### 示例：一个合法的最小堆

```text

        1
      /   \
     3     5
    / \   /
   7   9 8
```
- 每个节点 ≤ 子节点。
    
- 底层靠左，没有空隙。
    

### 3.2 判断是否为最小堆（思考题）

给出四个树结构，判断哪些是合法的最小堆。

**选项**：  
A. 0 个 B. 1 个 C. 2 个 D. 3 个 E. 4 个

（原笔记中有四个图，我们抽象描述）

1. **全8树**：所有节点都是8 → 满足堆性质（相等是允许的），也满足完全性 → **合法**。
    
2. **中间缺失树**：某层中间有空缺，不满足完全性 → **非法**。
    
3. **5-4冲突树**：父节点5大于子节点4 → 违反堆性质 → **非法**。
    
4. **两节点树**：根1，子2 → 满足完全性和堆性质 → **合法**。
    

**答案**：C（2个合法）。

---

## 🔧 四、堆的基本操作

### 4.1 getSmallest()

- 直接返回根节点元素 → **O(1)**
    

### 4.2 插入（add）

**步骤**：

1. 将新元素添加到堆的**末尾**（保持完全性）。
    
2. 然后让该元素**上浮（swim）**：与父节点比较，如果比父节点小，就交换，重复直到满足堆性质。
    

**示例**：在堆 `[1,3,5,7,9,8]` 中插入 `2`。

- 初始堆（数组表示，索引从0或1开始）：
    
    ```text
    
          1
         / \
        3   5
       / \ /
      7  9 8
    ```
- 末尾添加2 → 放在8的右边？实际上数组表示是在最后追加，插入后树为：
    
    ```text
    
          1
         / \
        3   5
       / \ / \
      7  9 8  2
    ```
- 2 的父节点是5，2<5，交换：
    
    ```text
    
          1
         / \
        3   2
       / \ / \
      7  9 8  5
    ```
- 2 的新父节点是1，2>1，停止。插入完成。
    

**时间复杂度**：最坏情况从叶子到根，交换次数 ≤ 树高 = **O(log N)**。

### 4.3 删除最小（removeSmallest）

**步骤**：

1. 将根节点（最小元素）移除。
    
2. 把**最后一个元素**移到根节点位置（保持完全性）。
    
3. 然后让该元素**下沉（sink）**：与两个子节点中较小的那个比较，如果比它大，就交换，重复直到满足堆性质。
    

**示例**：删除上面堆的根（1）：

- 将最后一个元素5移到根：
    
    ```text
    
          5
         / \
        3   2
       / \ /
      7  9 8
    ```
- 5 与较小子节点2比较，5>2，交换：
    
    ```text
    
          2
         / \
        3   5
       / \ /
      7  9 8
    ```
- 5 与它的子节点（8）比较，5<8，停止。删除完成。
    

**时间复杂度**：同样 O(log N)。

---

## 💾 五、堆的数组实现

### 5.1 完全二叉树的数组表示

因为堆是完全二叉树，我们可以用**数组**来紧凑存储，无需显式指针。

**父子索引关系**（设根索引为0）：

- 父节点索引 = `(k - 1) / 2`
    
- 左子节点 = `2*k + 1`
    
- 右子节点 = `2*k + 2`
    

如果让根索引从1开始（第0位留空），计算更简单：

- 父节点 = `k / 2`
    
- 左子 = `2*k`
    
- 右子 = `2*k + 1`
    

**优点**：节省内存（约比链表实现少1/3内存），且缓存友好。

### 5.2 上浮与下沉的代码实现（伪代码）

#### 上浮（swim）

```java

private void swim(int k) {
    while (k > 0 && heap[k] < heap[(k-1)/2]) {
        swap(k, (k-1)/2);
        k = (k-1)/2;
    }
}
```
#### 下沉（sink）

```java

private void sink(int k) {
    while (2*k+1 < size) {  // 有左子
        int j = 2*k+1;       // 左子索引
        if (j+1 < size && heap[j+1] < heap[j]) j++; // 取较小的子节点
        if (heap[k] <= heap[j]) break;
        swap(k, j);
        k = j;
    }
}
```
### 5.3 扩容问题

堆底层数组也需要动态扩容（类似 ArrayList），但扩容的均摊成本不高，因此插入的均摊时间复杂度仍是 O(log N)。

---

## 📊 六、各种实现对比总结

|操作 \ 实现|有序数组|平衡BST|哈希表|**二叉堆**|
|---|---|---|---|---|
|add|Θ(N)|Θ(log N)|Θ(1)|**Θ(log N)**|
|getSmallest|Θ(1)|Θ(log N)|Θ(N)|**Θ(1)**|
|removeSmallest|Θ(N)|Θ(log N)|Θ(N)|**Θ(log N)**|
|重复值处理|容易|困难|容易（但无序）|**容易**|
|内存效率|中等|低（指针）|中等|**高（数组）**|

**堆的优势**：

- 三个主要操作都在对数时间或常数时间。
    
- 天然支持重复值。
    
- 实现简单，内存紧凑。
    

---

## 🧠 七、深入思考题与答案

### 1. 为什么堆比二叉搜索树更适合实现优先队列？

**答案**：

- 堆专门为优先队列设计，只关心最小/最大元素，不需要维护全序，因此操作更简单。
    
- 堆允许重复值，而 BST 通常需要额外处理重复（如计数或允许重复节点），实现复杂。
    
- 堆的完全性使得它可以用数组紧凑存储，内存效率高，且缓存友好。
    
- BST 如果不用平衡树，可能退化为链表；平衡树（如红黑树）实现复杂。
    

### 2. 在堆中插入一个元素，最坏情况下需要多少次比较？平均呢？

**答案**：

- 最坏情况：新元素比所有祖先都小，需要一直上浮到根，比较次数 = 树高 ≈ log₂N。
    
- 平均情况：由于新元素随机，平均上浮高度约为 log₂N 的一半左右？实际上仍是 O(log N)，但常数较小。
    

### 3. 如何用最小堆实现最大堆？

**答案**：

- 方法一：在插入时取负值（如果元素是数值），这样最小堆就变成了最大堆（取负后的最小对应原最大）。
    
- 方法二：在比较器上做文章，提供自定义 Comparator 反转大小关系。
    

### 4. 在堆排序中，建堆的时间复杂度为什么是 O(N)？

**答案**：

- 从最后一个非叶子节点开始向下调整（下沉），每个节点调整的代价与其高度成正比，总代价可以证明是 O(N)。（具体推导：调整次数总和 ≤ N）
    

### 5. 为什么堆的删除操作要拿最后一个元素补根？

**答案**：

- 为了保持完全二叉树的性质，只能用最后一个元素填补根的位置，否则会产生空洞，破坏数组表示的紧凑性。虽然这样可能破坏堆序，但通过下沉操作可以恢复，且保证 O(log N) 时间。
    

### 6. 如果堆中所有元素都相等，插入和删除的时间复杂度是多少？

**答案**：

- 插入：新元素等于所有元素，上浮比较时父节点不大于它？不，相等时我们通常停止（或可以选择继续，但没必要）。如果停止，则插入 O(1)（直接放在末尾，不上浮）。如果继续交换，则会交换到某个位置，但最终所有元素相等，交换也不改变顺序，但会消耗时间。通常实现中当新元素小于父节点时才交换，相等时不交换，所以插入 O(1)。
    
- 删除：将最后一个元素移到根，然后下沉，因为所有元素相等，下沉时不会交换（因为不大于子节点），所以删除也是 O(1)（仅一次比较）。但要注意如果实现中当相等时也交换，则会变成 O(log N)。通常实现是当父节点大于子节点时才交换，相等不交换，所以 O(1)。
    

---

## 🏗️ 八、堆的 Java 实现与接口设计

### 8.1 接口 MinPQ

```java

public interface MinPQ<Item> {
    void add(Item x);
    Item getSmallest();
    Item removeSmallest();
    int size();
}
```
### 8.2 基于数组的堆实现（简化版）

```java

public class ArrayMinPQ<Item extends Comparable<Item>> implements MinPQ<Item> {
    private Item[] heap;
    private int size;
    private static final int DEFAULT_CAPACITY = 16;
    public ArrayMinPQ() {
        heap = (Item[]) new Comparable[DEFAULT_CAPACITY];
        size = 0;
    }
    private void resize(int capacity) {
        Item[] newHeap = (Item[]) new Comparable[capacity];
        System.arraycopy(heap, 0, newHeap, 0, size);
        heap = newHeap;
    }
    @Override
    public void add(Item x) {
        if (size == heap.length) resize(heap.length * 2);
        heap[size] = x;
        swim(size);
        size++;
    }
    @Override
    public Item getSmallest() {
        if (size == 0) throw new NoSuchElementException();
        return heap[0];
    }
    @Override
    public Item removeSmallest() {
        if (size == 0) throw new NoSuchElementException();
        Item min = heap[0];
        swap(0, size-1);
        heap[size-1] = null; // 避免内存泄漏
        size--;
        sink(0);
        if (size > 0 && size == heap.length / 4) resize(heap.length / 2);
        return min;
    }
    @Override
    public int size() { return size; }
    // 辅助方法
    private void swim(int k) {
        while (k > 0 && heap[k].compareTo(heap[(k-1)/2]) < 0) {
            swap(k, (k-1)/2);
            k = (k-1)/2;
        }
    }
    private void sink(int k) {
        while (2*k+1 < size) {
            int j = 2*k+1;
            if (j+1 < size && heap[j+1].compareTo(heap[j]) < 0) j++;
            if (heap[k].compareTo(heap[j]) <= 0) break;
            swap(k, j);
            k = j;
        }
    }
    private void swap(int i, int j) {
        Item temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    }
}
```
### 8.3 关于比较器的设计

如果需要支持自定义优先级（例如最大堆），可以允许传入 `Comparator<Item>`。

---

## 📈 九、堆的性能与扩展

### 9.1 摊还分析

由于底层数组可能需要扩容，插入的均摊时间仍是 O(log N)，因为扩容次数有限。

### 9.2 其他变种

- **d-ary 堆**：每个节点有 d 个孩子，降低树高，但增加每次比较的子节点数。
    
- **二项堆、斐波那契堆**：支持更高效的合并操作。
    

### 9.3 堆排序

利用堆可以原地排序：建堆（O(N)）然后不断删除最大元素放到数组末尾，得到升序序列。

---

## 🔗 十、数据结构统一视角：搜索问题

所有数据结构本质上都在解决**搜索问题**：管理数据集合，并提供高效检索。

|数据结构|存储操作|检索操作|组织方式|
|---|---|---|---|
|List|add(key), insert|get(index)|按索引顺序|
|Map|put(key, value)|get(key)|键值映射|
|Set|add(key)|contains(key)|无重复集合|
|Priority Queue|add(key)|getSmallest()|按优先级|
|Disjoint Sets|connect(a,b)|isConnected(a,b)|连通关系|

堆是优先队列的最经典实现，完美平衡了增、删、查最小值的效率。

---

## 📚 十一、知识点总结（颜色标记）

|主题|核心内容|<span style="color:red">重点/易错点</span>|
|---|---|---|
|优先队列 ADT|支持添加、获取/移除最小元素|<span style="color:red">用户只能与最小元素交互，不能直接访问其他元素</span>|
|二叉堆定义|完全二叉树 + 最小堆性质（父 ≤ 子）|<span style="color:red">必须同时满足完全性和堆序性；允许重复值</span>|
|插入操作|末尾添加，然后上浮（与父比较交换）|<span style="color:red">上浮终止条件：新元素 ≥ 父节点；不要交换过头</span>|
|删除最小操作|用最后一个元素替换根，然后下沉（与较小子节点比较交换）|<span style="color:red">下沉时一定要与较小的子节点交换；不能只与一个子节点比较</span>|
|数组实现|索引0为根，父子关系：parent=(k-1)/2, left=2k+1, right=2k+2|<span style="color:red">注意索引越界；从1开始索引可简化计算，但浪费一个位置</span>|
|时间复杂度|getSmallest O(1), add O(log N), removeSmallest O(log N)|<span style="color:red">均为最坏情况；扩容不影响均摊</span>|
|与其他实现对比|有序数组（插入慢）、BST（重复值麻烦）、哈希表（无法直接找最小）|<span style="color:red">堆是专门为优先队列设计的，综合性能最好</span>|
|应用场景|Top M 问题、Dijkstra、Huffman 编码等|<span style="color:red">最小堆实现最大堆可通过取负或自定义比较器</span>|

---

## 🧩 十二、思考题与答案（详细版）

### 1. 堆的插入操作中，如果新元素和父节点相等，应该上浮吗？

**答案**：通常**不上浮**。因为相等时，放在子节点位置并不会破坏堆性质（父 ≤ 子，相等满足）。上浮反而会增加不必要的交换，且可能导致相等元素的相对顺序改变（如果在意稳定性）。所以一般实现中，当新元素 **小于** 父节点时才交换。

### 2. 如何用最小堆实现一个最大优先队列？

**答案**：

- 方法一：在插入时，将元素的值取负（`add(-x)`），那么最小堆中的最小元素就是原最大元素的负值。获取时再取负。
    
- 方法二：在堆的构造函数中传入一个自定义的 `Comparator`，使其按照降序比较。这样堆实际上变成了最大堆（即“最小”元素是最大的那个）。
    

### 3. 堆的删除操作中，为什么必须用最后一个元素来填补根？

**答案**：因为要维持完全二叉树的性质。如果删除根后随便拿一个节点填补，可能会造成树中出现空洞，破坏完全性，导致无法用数组紧凑表示。最后一个元素是唯一能保持完全性的选择（因为它是树中最右下角的节点，填补后树仍然连续）。

### 4. 如果堆中所有元素都相同，插入一个新相同元素需要多少次操作？

**答案**：

- 插入：新元素放到末尾，然后上浮。因为父节点不小于它（相等），所以不会交换，直接结束 → **O(1)**。
    
- 删除：将最后一个元素移到根，然后下沉。因为根与子节点相等，不会交换（除非实现中要求严格小于才交换），所以也是 **O(1)**。但如果实现中当相等也交换，则会继续下沉，但最终所有元素相等，交换无意义，但会消耗 O(log N) 时间。通常实现避免这种情况。
    

### 5. 为什么堆排序中建堆的时间复杂度是 O(N)？

**答案**：建堆通常采用从最后一个非叶子节点开始向下调整（sink）。每个节点调整的代价与其高度成正比。可以证明所有节点调整代价的总和是 O(N)。具体来说，高度为 h 的节点最多有 N/2^(h+1) 个，每个调整代价 O(h)，求和后收敛于 O(N)。（详细推导可参考算法导论）

### 6. 堆的数组实现中，为什么通常预留索引0不用，从1开始？

**答案**：为了简化父子索引计算。从1开始时，父节点 = k/2，左子 = 2k，右子 = 2k+1，都是整数运算，比 (k-1)/2 和 2k+1 更直观且效率略高。虽然浪费了一个数组位置，但带来的简洁性值得。

### 7. 二叉堆和二叉搜索树（BST）在结构上的根本区别是什么？

**答案**：

- 二叉堆是**完全二叉树**，而 BST 可以是任意形状（只要满足左小右大）。
    
- 二叉堆只要求父 ≤ 子（局部有序），而 BST 要求全局有序（左子树所有节点 < 根 < 右子树）。
    
- 因此，堆更适合需要快速获取极值的场景，而 BST 更适合需要范围查询、有序遍历等场景。
    

### 8. 实现优先队列时，如果既要支持最小又要支持最大，如何设计？

**答案**：可以设计一个双端优先队列（如使用两个堆，一个最小堆一个最大堆，并相互交叉引用），但实现复杂。简单做法是传入一个 Comparator，让同一个堆既可以作为最小堆也可以作为最大堆。
# 🌐 图遍历与实现（Graph Traversals and Implementations）—— 从表示到搜索，深入理解图的核心算法

> 本文是 CS61B Spring 2024 Lecture 23 的详细笔记，全面讲解图的基本表示方法（邻接矩阵、邻接表）、深度优先搜索（DFS）与广度优先搜索（BFS）的实现原理、路径记录、时间复杂度分析，以及不同表示法对算法性能的影响。通过大量示例、代码片段和思考题，帮助你彻底掌握图的核心遍历技巧。

---

## 🧱 一、图的表示方法（Graph Representations）

在实现图算法之前，首先需要决定如何在内存中存储图。不同的表示方法对空间和时间复杂度有显著影响。

### 1.1 图 API 设计（以 Princeton 教材为例）


```java

public class Graph {
    public Graph(int V)                 // 创建包含 V 个顶点（无标签）的空图
    public void addEdge(int v, int w)    // 添加一条边 v-w
    public Iterable<Integer> adj(int v)  // 返回顶点 v 的所有邻接顶点
    public int V()                        // 返回顶点数
    public int E()                        // 返回边数
}
```
**设计特点**：

- 顶点用整数编号（0 到 V-1），如果需要通过标签查找顶点，可以使用 `Map<Label, Integer>` 进行映射。
    
- 不支持顶点或边上的权重（带权图需要扩展）。
    
- 不直接提供获取顶点度数的方法，用户可以自己通过 `adj(v)` 的迭代器大小计算。
    

这种 API 的优点是将图的存储与算法解耦，算法只需依赖 `adj` 方法即可遍历图。

### 1.2 三种常见的图表示法

#### 1.2.1 邻接矩阵（Adjacency Matrix）

- **实现**：一个 `V × V` 的二维布尔数组（或整型数组，用于带权图）。`matrix[v][w] = true` 表示存在边 v-w。
    
- **无向图**：矩阵对称，`matrix[v][w] = matrix[w][v]`。
    
- **有向图**：矩阵不对称，`matrix[v][w]` 表示 v → w 的边。
    

**优点**：

- 检查边是否存在：**O(1)**
    
- 实现简单直观
    

**缺点**：

- 空间复杂度 **Θ(V²)**，对于稀疏图（边数远小于 V²）浪费巨大
    
- 遍历某个顶点的所有邻接点需要扫描一整行（或列），耗时 **Θ(V)**
    

#### 1.2.2 边集（Edge Set）

- **实现**：用一个集合（如 `HashSet<Edge>`）存储所有边，其中 `Edge` 是包含两个顶点序偶的对象。
    
- **示例**：`{(0,1), (0,2), (1,2)}`
    

**特点**：

- 很少使用，因为查询某个顶点的邻接点需要遍历所有边，效率低下。
    
- 教授调侃：“我从未见人真正用过这种方法。”
    

#### 1.2.3 邻接表（Adjacency Lists）—— ✅ 最常用

- **实现**：维护一个长度为 V 的数组，每个元素是一个链表（或动态数组），存储与该顶点相邻的所有顶点。
    
- **示例**：
    
    ```text
    
    0 → [1, 2]
    1 → [2]
    2 → []
    ```

**优点**：

- 空间复杂度 **Θ(V + E)**，对稀疏图非常友好。
    
- 遍历顶点 v 的所有邻接点只需 **Θ(degree(v))** 时间。
    
- 添加边也很容易（链表头插 O(1)）。
    

**缺点**：

- 检查边 v-w 是否存在需要遍历 v 的邻接表（最坏 O(degree(v))），但通常不需要频繁检查。
    

**推荐**：邻接表是实际工程和算法竞赛中最常用的图表示法。

### 1.3 表示法的对比总结

| 表示法  | 空间复杂度  | 检查边是否存在      | 遍历 v 的邻接点    | 适用场景        |
| ---- | ------ | ------------ | ------------ | ----------- |
| 邻接矩阵 | Θ(V²)  | O(1)         | Θ(V)         | 稠密图（E ≈ V²） |
| 边集   | Θ(E)   | 需遍历边集        | Θ(E)（需全局扫描）  | 几乎不用        |
| 邻接表  | Θ(V+E) | O(degree(v)) | Θ(degree(v)) | 稀疏图（绝大多数情况） |

---

## 🔍 二、深度优先搜索（DFS）—— 探索图的“深渊”

深度优先搜索是一种递归的图遍历算法，它从起点出发，尽可能深入每个分支，直到无法继续，然后回溯。

### 2.1 基本思想与标记

- 从起点 s 开始，标记 s 为“已访问”。
    
- 对于 s 的每个未访问的邻居 w，递归地执行 DFS(w)。
    
- **必须标记**，否则会陷入无限循环（尤其在有环图中）。
    

### 2.2 记录路径：`edgeTo` 数组

在 DFS 过程中，我们可以用一个数组 `edgeTo[w]` 记录**从哪个顶点到达 w**（即 w 的前驱）。这样，当需要找到从 s 到任意顶点 v 的路径时，只需从 v 开始沿着 `edgeTo` 回溯到 s。

### 2.3 DFS 的两种顺序：前序与后序

- **前序**：在递归调用邻居之前执行操作（如记录 `edgeTo`）。前序顺序对应 **DFS 调用顺序**。
    
- **后序**：在递归调用邻居之后执行操作。后序顺序对应 **DFS 返回顺序**。
    

**示例**（对下图从 0 开始 DFS）：

```text

0 -- 1 -- 2 -- 5 -- 8
|    |    |
3 -- 4 -- 6 -- 7
```
一种可能的 DFS 调用顺序（前序）：`0 1 2 5 8 4 3 6 7`  
返回顺序（后序）：`8 5 2 7 6 4 3 1 0`

### 2.4 DepthFirstPaths 实现（Java 风格）

```java

public class DepthFirstPaths {
    private boolean[] marked;   // marked[v] = 是否存在从 s 到 v 的路径
    private int[] edgeTo;       // edgeTo[v] = 从 s 到 v 路径上的前一个顶点
    private final int s;        // 起点
    public DepthFirstPaths(Graph G, int s) {
        marked = new boolean[G.V()];
        edgeTo = new int[G.V()];
        this.s = s;
        dfs(G, s);
    }
    private void dfs(Graph G, int v) {
        marked[v] = true;
        for (int w : G.adj(v)) {
            if (!marked[w]) {
                edgeTo[w] = v;          // 前序操作：记录前驱
                dfs(G, w);
            }
        }
        // 这里可以添加后序操作（例如输出 v）
    }
    public boolean hasPathTo(int v) {
        return marked[v];
    }
    public Iterable<Integer> pathTo(int v) {
        if (!hasPathTo(v)) return null;
        Deque<Integer> path = new ArrayDeque<>();
        for (int x = v; x != s; x = edgeTo[x]) {
            path.push(x);               // 从 v 回溯到 s，逆序压栈
        }
        path.push(s);
        return path;
    }
}
```
### 2.5 DFS 的时间复杂度（邻接表）

- 每个顶点恰好被访问一次 → **Θ(V)**
    
- 每条边恰好被检查两次（无向图）或一次（有向图） → **Θ(E)**
    
- 初始化 `marked` 和 `edgeTo` 数组也需要 **Θ(V)** 时间
    
- **总时间**：**Θ(V + E)**
    

若使用邻接矩阵，遍历每个顶点的邻接点需要 Θ(V) 时间，总时间退化为 **Θ(V²)**。

---

## 🌊 三、广度优先搜索（BFS）—— 按层探索最短路径

广度优先搜索从起点出发，先访问所有距离为 1 的顶点，然后距离为 2 的顶点，以此类推。它天然适合求解**无权图的最短路径**问题。

### 3.1 核心思想：使用队列

- 将起点 s 入队并标记。
    
- 只要队列不空：
    
    - 出队一个顶点 v。
        
    - 对于 v 的每个未标记的邻居 w：
        
        - 标记 w，记录 `edgeTo[w] = v` 和 `distTo[w] = distTo[v] + 1`。
            
        - 将 w 入队。
            

**为什么用队列？**  
队列的 FIFO 特性保证了先入队的顶点（距离近）先被处理，从而按层遍历。

### 3.2 BFS 示例（同前图，起点 0）

队列变化与访问顺序：

- 初始：队列 [0]
    
- 处理 0，将其邻居 1,3 入队 → 队列 [1,3]
    
- 处理 1，将其未标记邻居 2,4 入队 → 队列 [3,2,4]
    
- 处理 3，将其未标记邻居 4?（4 已标记？本例中 4 已从 1 标记，跳过） → 队列 [2,4]
    
- 处理 2，将 5 入队 → 队列 [4,5]
    
- 处理 4，将 6 入队 → 队列 [5,6]
    
- 处理 5，将 8 入队 → 队列 [6,8]
    
- 处理 6，将 7 入队 → 队列 [8,7]
    
- 处理 8，无新邻居
    
- 处理 7，结束
    

**BFS 顺序**：`0 1 3 2 4 5 6 8 7` （按距离分层）

### 3.3 BreadthFirstPaths 实现

```java

public class BreadthFirstPaths {
    private boolean[] marked;
    private int[] edgeTo;
    private int[] distTo;       // 记录到起点的距离
    private final int s;
    public BreadthFirstPaths(Graph G, int s) {
        marked = new boolean[G.V()];
        edgeTo = new int[G.V()];
        distTo = new int[G.V()];
        this.s = s;
        bfs(G, s);
    }
    private void bfs(Graph G, int s) {
        Queue<Integer> queue = new LinkedList<>();
        marked[s] = true;
        distTo[s] = 0;
        queue.add(s);
        while (!queue.isEmpty()) {
            int v = queue.remove();
            for (int w : G.adj(v)) {
                if (!marked[w]) {
                    marked[w] = true;
                    edgeTo[w] = v;
                    distTo[w] = distTo[v] + 1;
                    queue.add(w);
                }
            }
        }
    }
    // hasPathTo 和 pathTo 与 DFS 相同
}
```
### 3.4 BFS 的性质

- 对于任意可达顶点 v，`distTo[v]` 就是从 s 到 v 的**最短路径长度**（边数）。
    
- BFS 同样需要 **Θ(V + E)** 时间（邻接表），空间 **Θ(V)**。
    

---

## ⚖️ 四、DFS 与 BFS 对比

|特性|DFS|BFS|
|---|---|---|
|数据结构|栈（递归调用栈）|队列|
|遍历顺序|深度优先，先探索一条分支到尽头|广度优先，按距离分层|
|最短路径|不保证最短|保证无权图最短路径（第一次到达即最短）|
|应用场景|连通性检测、拓扑排序、寻找路径（任意一条）|最短路径、社交网络“六度空间”、层序遍历|
|空间复杂度（最坏）|O(V)（递归栈深度可能达 V）|O(V)（队列可能存储一层所有节点）|
|是否适合递归|天然递归，但需注意栈溢出|通常迭代实现，递归不适合（深度不明）|

---

## ⏱️ 五、图表示法对算法运行时间的影响

### 5.1 打印所有边的例子

考虑以下代码（打印图中所有边）：

```java

for (int v = 0; v < G.V(); v++) {
    for (int w : G.adj(v)) {
        System.out.println(v + "-" + w);
    }
}
```
- **邻接表**：内层循环的总迭代次数 = 每条边被打印两次（无向图）→ **Θ(E)**，外层循环 V 次 → 总时间 **Θ(V + E)**。
    
- **邻接矩阵**：`adj(v)` 需要遍历整个数组（Θ(V)），总时间 **Θ(V²)**。
    

### 5.2 DFS/BFS 的复杂度总结

- 邻接表：**Θ(V + E)**
    
- 邻接矩阵：**Θ(V²)**
    

**关键**：对于稀疏图（E ≈ V），邻接表远快于邻接矩阵；对于稠密图（E ≈ V²），两者渐进相同，但邻接矩阵常数更小。

---

## 📊 六、图问题总结表

|问题|描述|经典算法|时间复杂度（邻接表）|
|---|---|---|---|
|s-t 路径|判断 s 到 t 是否有路径，并输出一条路径|DFS|O(V+E)|
|最短路径（无权图）|找到 s 到所有顶点的最短路径长度及路径|BFS|O(V+E)|
|连通分量|找出图中所有连通块|DFS / 并查集|O(V+E)|
|环检测|判断图中是否有环|DFS（借助递归栈）|O(V+E)|
|拓扑排序|有向无环图的线性排序|DFS 后序 / Kahn|O(V+E)|

---

## 🧠 七、思考题与答案

### 1. 为什么 DFS 必须用标记数组？如果不标记会发生什么？

**答案**：如果不标记已访问顶点，在有环图中，DFS 会沿着环无限递归（或无限循环），导致栈溢出或死循环。标记确保每个顶点只处理一次。

### 2. BFS 为什么能保证找到最短路径？

**答案**：BFS 按距离起点的远近逐层扩展，第一次到达某个顶点时，一定是经过最少的边数（因为所有更短的路径都已经被探索过）。队列的 FIFO 特性保证了这一点。

### 3. 对于稀疏图，邻接表比邻接矩阵好在哪里？

**答案**：

- 空间：邻接表 O(V+E)，邻接矩阵 O(V²)。当 E 远小于 V² 时，邻接表节省大量空间。
    
- 时间：遍历所有邻接点，邻接表总时间 O(V+E)，邻接矩阵 O(V²)。
    

### 4. 如何用 DFS 检测有向图中的环？

**答案**：在 DFS 递归过程中，除了标记已访问（`marked`），还需要一个额外的“递归栈上”标记（`onStack`）。当遇到一个邻居既在递归栈上，又未被标记完成，则说明存在环。具体实现可参考拓扑排序部分。

### 5. 打印图时，如果使用邻接表，时间复杂度是 Θ(V+E)；如果使用邻接矩阵，是 Θ(V²)。请解释为什么不能将邻接矩阵的时间简化为 Θ(E)？

**答案**：因为即使 E 很小，邻接矩阵的 `adj(v)` 方法仍需要遍历整个长度为 V 的数组才能找出所有邻接点（为了满足 `Iterable` 接口，必须检查每个位置）。所以无论图有多稀疏，扫描矩阵的每一行都要花费 Θ(V) 时间，总时间固定为 Θ(V²)。

### 6. 在 BFS 中，为什么使用队列而不是栈？

**答案**：队列保证先入队的节点（距离近）先被处理，从而实现按层遍历。如果使用栈（LIFO），则相当于深度优先，无法保证最短路径。

### 7. 如果图用邻接表表示，那么 `degree(v)` 操作的时间复杂度是多少？

**答案**：`degree(v)` 即顶点 v 的邻接链表长度，可以通过遍历 `adj(v)` 计数，时间 O(degree(v))。也可以预先维护一个 `degree[]` 数组，在添加边时更新，这样查询为 O(1)。

---

## 📌 八、核心知识点总结（彩色标记）

|知识点|核心内容|<span style="color:red">重点/易错点</span>|
|---|---|---|
|图的表示|邻接矩阵（稠密）、邻接表（稀疏）|<span style="color:red">邻接表是最常用表示；矩阵适合边数接近 V² 的稠密图</span>|
|图 API|固定顶点数，`addEdge`, `adj`, `V()`, `E()`|<span style="color:red">用整数编号顶点，标签需外部映射；不提供度数方法</span>|
|DFS 核心|递归 + 标记数组，`edgeTo` 记录前驱|<span style="color:red">必须标记；前序/后序区别；递归栈深度可能导致溢出</span>|
|BFS 核心|队列 + 标记，`distTo` 记录距离，`edgeTo` 记录路径|<span style="color:red">队列保证按层遍历；第一次到达即为最短路径</span>|
|时间复杂度|邻接表下 DFS/BFS 均为 O(V+E)；邻接矩阵下为 O(V²)|<span style="color:red">不能只看 E，初始化数组和扫描邻接点都需要时间</span>|
|路径重建|从目标点沿 `edgeTo` 回溯到起点|<span style="color:red">注意路径顺序需反转（用栈或列表头插）</span>|
|应用区分|DFS 适合连通性、拓扑排序；BFS 适合最短路径、层序遍历|<span style="color:red">DFS 不保证最短，BFS 保证无权图最短</span>|
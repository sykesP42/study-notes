# 🌲 最小生成树（Minimum Spanning Trees）—— 从 Dijkstra 收尾到 Prim 算法，全面理解 MST

> 本文是 CS61B Spring 2024 Lecture 25 的详细笔记，内容包括 Dijkstra 算法的正确性证明收尾、负权边的失效分析、A* 算法的引入、环检测的两种方法、生成树的定义与性质、切割属性及其证明、通用 MST 算法，以及 Prim 算法的概念版。通过详尽解释和思考题，帮助你彻底掌握最小生成树的核心思想。

---

## 🔚 一、Dijkstra 算法收尾

### 1.1 最优性保证的再证明

在前一讲中，我们通过归纳法证明了 Dijkstra 算法的正确性。这里我们用一个更直观的方式再次强调**关键性质**：

- 当顶点 `v` 从优先队列中被取出时，`distTo[v]` 已经是最短距离。
    
- 此后，任何指向 `v` 的边（即从某个未取出的顶点 `p` 到 `v` 的边）的松弛操作都会失败。
    

**为什么？**  
因为所有未取出的顶点 `p` 的当前距离 `distTo[p]` 都 ≥ `distTo[v]`，而边权 `w ≥ 0`，所以 `distTo[p] + w ≥ distTo[v]`。因此不可能找到一条更短的路径到达 `v`。

这个论证对任何顶点 `p` 都成立，无论它有多深。因此，已经取出的顶点不会再被更新，保证了算法的正确性。

### 1.2 负权边的失效

Dijkstra 算法依赖“已访问顶点不会被更新”这一性质，但**当图中存在负权边时，这一性质不再成立**。

**反例**：

text

      X (dist 82)
      ↑
      | -67
      |
      Y (dist 101)

假设当前已访问 X（白色），其距离为 82。Y 尚未被访问，距离为 101。考虑边 Y → X，权重 -67。那么 `distTo[Y] + (-67) = 101 - 67 = 34 < 82`，这意味着我们可以通过 Y 找到一条更短的路径到 X，但 X 已经被访问，按照 Dijkstra 的规则不会再被更新，因此算法会错误地保留 82 作为 X 的最短距离。

**根本原因**：Dijkstra 按距离递增顺序访问顶点，但负权边可能使一个距离较大的顶点通过负权边“缩短”到某个已访问顶点的距离，从而破坏已访问顶点的最优性。

**结论**：Dijkstra 算法**不能处理负权边**。对于负权图，需要使用 Bellman-Ford 等算法。

### 1.3 运行时间分析（二叉堆实现）

Dijkstra 算法的主要操作都围绕优先队列：

|操作|次数|每次代价|总代价|
|---|---|---|---|
|PQ add|V|O(log V)|O(V log V)|
|PQ removeSmallest|V|O(log V)|O(V log V)|
|PQ changePriority|E|O(log V)|O(E log V)|

总运行时间 = O(V log V + V log V + E log V) = **O((V+E) log V)**。对于连通图，通常 E ≥ V，因此可简化为 **O(E log V)**。

**注意**：changePriority 操作在二叉堆中需要 O(log V) 时间，如果使用斐波那契堆可以降至 O(1) 均摊，但实际中较少使用。

---

## 🎯 二、单目标最短路径与 A* 算法

### 2.1 问题：我们只需要到单个目标的最短路径

在实际应用中（如导航），我们往往只关心从起点到某一个特定终点的最短路径，而不需要到所有点的距离。Dijkstra 算法会探索整个图，做了许多无用功。

**如何改进？**  
可以引入一个**启发式函数**，引导搜索向目标方向进行。这就是 *_A_ 算法**。

### 2.2 A* 算法的基本思想

A* 算法的优先级计算公式为：

text

priority(v) = distTo[v] + h(v, goal)

其中：

- `distTo[v]` 是从起点到 v 的当前已知最短距离（同 Dijkstra）。
    
- `h(v, goal)` 是从 v 到目标顶点的**估计距离**（启发式函数）。
    

算法流程与 Dijkstra 完全相同，只是优先队列的排序依据变成了 `distTo[v] + h(v, goal)`。

**直观理解**：我们优先考虑那些“离起点近且离目标也近”的顶点。

### 2.3 启发式函数示例

假设我们有一个地图，要计算从丹佛到纽约的最短路径。我们可以用**直线距离（欧氏距离）**作为启发式：

- 对于顶点 v，`h(v, NYC)` = v 与纽约的直线距离（英里）。
    

这个估计值通常小于实际道路距离，但能有效引导搜索。

**不精确的启发式**：

- 如果 `h(v, goal) = 0`，A* 退化为 Dijkstra，探索整个图。
    
- 如果 `h(v, goal) = 10000`（一个巨大的常数），则所有顶点都被严重惩罚，算法会先探索起点附近，但最终仍可能探索很多区域，且可能错过最优路径（如果启发式不一致且过大，可能导致非最优解）。
    

### 2.4 A* 的正确性条件

为了保证 A* 找到最短路径，启发式函数必须满足**可采纳性（admissible）**：`h(v, goal)` 必须 ≤ 从 v 到 goal 的实际最短距离。  
可采纳性确保算法不会因高估而错过最优路径。

此外，如果启发式还满足**一致性（consistent）**（即三角不等式：`h(v, goal) ≤ w(v,u) + h(u, goal)`），则算法可以更高效，且保证每个顶点只处理一次。

### 2.5 A* 的终止条件

当我们从优先队列中取出**目标顶点**时，就可以终止算法。此时 `distTo[goal]` 就是最短距离，因为所有可能更短的路径都已经考虑过（得益于可采纳性）。

**注意**：A* 只保证到目标的最短路径正确，到其他顶点的距离可能不正确。

---

## 🔍 三、环检测（Cycle Detection）

在讨论最小生成树之前，我们先看一个相关的基础问题：如何判断一个无向图是否有环？

### 3.1 方法一：基于 DFS

从任意顶点开始 DFS，维护一个 `parent` 数组记录当前顶点的父节点。当遇到一个已访问的顶点且它不是当前顶点的父节点时，说明存在环。

**伪代码**：

java

boolean hasCycle(Graph G) {
    boolean[] marked = new boolean[G.V()];
    for (int v = 0; v < G.V(); v++) {
        if (!marked[v]) {
            if (dfs(v, v, marked)) return true;
        }
    }
    return false;
}
boolean dfs(int v, int parent, boolean[] marked) {
    marked[v] = true;
    for (int w : G.adj(v)) {
        if (!marked[w]) {
            if (dfs(w, v, marked)) return true;
        } else if (w != parent) {
            return true; // 发现环
        }
    }
    return false;
}

**时间复杂度**：O(V + E)。

### 3.2 方法二：基于并查集（Union-Find）

- 初始化一个并查集，每个顶点自成一个集合。
    
- 遍历每条边 (u, v)：
    
    - 如果 u 和 v 已经在同一集合中，则说明存在环（因为这条边连接了两个已经连通的顶点）。
        
    - 否则，将 u 和 v 所在的集合合并。
        

**伪代码**：

java

boolean hasCycle(Graph G) {
    UnionFind uf = new UnionFind(G.V());
    for (Edge e : G.edges()) {
        int u = e.u, v = e.v;
        if (uf.connected(u, v)) return true;
        uf.union(u, v);
    }
    return false;
}

**时间复杂度**：O((V+E) α(V))，其中 α 是反阿克曼函数，近似常数。

**优点**：简单且高效，尤其适合边集已知的情况。

---

## 🌳 四、生成树与最小生成树

### 4.1 生成树（Spanning Tree）的定义

给定一个无向连通图 G = (V, E)，它的一个**生成树** T 是 G 的子图，满足：

1. T 包含 G 的所有顶点。
    
2. T 是连通的。
    
3. T 无环。
    

因此，生成树是一棵包含所有顶点的树，边数为 |V| - 1。

### 4.2 最小生成树（Minimum Spanning Tree, MST）

在**带权无向连通图**中，所有生成树中**边权和最小**的那一棵称为最小生成树。

**应用场景**：

- 设计通信网络，用最低成本连接所有城市。
    
- 电路布线，最小化导线长度。
    
- 聚类分析，如生物信息学中识别细胞核排列。
    

### 4.3 判断生成树的练习

给定几个子图，判断哪些是生成树：

- **A**：不连通 → 不是生成树。
    
- **B**：有环 → 不是生成树。
    
- **C**：连通且无环 → 是生成树。
    

---

## ✂️ 五、切割属性（Cut Property）

### 5.1 切割的定义

将图的顶点集 V 划分为两个非空集合 S 和 V\S，称为一个**切割**。连接 S 和 V\S 的边称为**横跨边（crossing edges）**。

### 5.2 切割属性

> 对于任意一个切割，其中**权重最小的横跨边**一定属于某个最小生成树。

**证明（反证法）**：  
假设最小横跨边 e 不在某棵 MST T 中。将 e 加入 T，则 T ∪ {e} 中必然形成一个环。由于 e 是横跨边，环中必然存在另一条横跨边 f（否则无法从 S 回到 V\S）。因为 e 是最小横跨边，所以 weight(e) ≤ weight(f)。若 weight(e) < weight(f)，则用 e 替换 f 得到的新生成树 T' 的总权更小，与 T 是 MST 矛盾。若 weight(e) = weight(f)，则 T' 也是 MST，因此 e 属于某棵 MST。

**重要前提**：若图中存在相同权重的边，则最小横跨边可能不唯一，但至少有一条属于某棵 MST。

### 5.3 切割属性的应用

切割属性是证明许多 MST 算法正确性的核心，例如 Prim 算法和 Kruskal 算法。

---

## 🛠️ 六、通用最小生成树算法

基于切割属性，我们可以得到如下通用算法：

1. 初始时，MST 为空，所有顶点各自为一个集合（或看作一个空的树）。
    
2. 只要 MST 中边数小于 V-1：
    
    - 找到一个当前 MST 未使用任何边的切割（即 MST 中的边都不跨越该切割）。
        
    - 找到该切割的最小横跨边，加入 MST。
        
3. 重复直到获得 V-1 条边。
    

这个通用算法是抽象的，因为如何高效地找到切割和最小边是关键。接下来介绍两种具体实现：**Prim 算法**（本节）和 **Kruskal 算法**（后续课程）。

---

## 🌱 七、Prim 算法（概念版）

### 7.1 算法思想

Prim 算法从任意一个顶点开始，逐步扩展 MST，每一步都选择一条**连接已选顶点集与未选顶点集的最小权重边**加入 MST。

**与 Dijkstra 的类比**：

- Dijkstra 维护 `distTo`，表示从起点到各顶点的最短路径。
    
- Prim 维护的是从各顶点到当前 MST 的**最小边权重**（或称为“到树的最短距离”）。
    

### 7.2 算法步骤（概念版）

1. 初始化：
    
    - 选择任意起始顶点，将其加入集合 A（已选顶点集）。
        
    - 其他顶点在集合 B（未选顶点集）。
        
2. 重复直到 A 包含所有顶点：
    
    - 在**所有跨越 A 和 B 的边**中，选择权重最小的边 e = (u, v)，其中 u ∈ A，v ∈ B。
        
    - 将 e 加入 MST，并将 v 从 B 移到 A。
        

### 7.3 正确性证明

每次选择的边都是当前切割的最小横跨边，根据切割属性，它必然属于某棵 MST。由于我们始终维护一个连通的无环子图，最终得到一棵 MST。

### 7.4 效率问题

概念版需要每次遍历所有跨越边，最坏情况 O(V²)。我们可以用优先队列优化，类似 Dijkstra 的实现，得到 O(E log V) 的版本。这将在后续课程中详细介绍。

---

## 📌 八、知识点总结（彩色标记）

|知识点|核心内容|<span style="color:red">重点/易错点</span>|
|---|---|---|
|Dijkstra 最优性|已访问顶点不会再被更新，因为所有未访问顶点距离 ≥ 它，加上非负权后更大。|<span style="color:red">证明依赖非负权；负权边会破坏</span>|
|负权边问题|存在负权边时，已访问顶点可能被更短路径更新，Dijkstra 失效。|<span style="color:red">需改用 Bellman-Ford 算法</span>|
|Dijkstra 运行时间|O((V+E) log V)，连通图中简化为 O(E log V)|<span style="color:red">主要操作是优先队列的 add、remove、changePriority</span>|
|A* 算法|优先级 = distTo + h(v, goal)，用启发式引导搜索|<span style="color:red">h 必须可采纳（低估），否则可能非最优</span>|
|环检测（DFS）|DFS 中遇到已访问的非父节点即存在环|<span style="color:red">注意排除父节点</span>|
|环检测（并查集）|遍历边，若两端点已在同一集合则存在环|<span style="color:red">适合边集已知的情况</span>|
|生成树定义|连通、无环、包含所有顶点|<span style="color:red">边数 = V-1</span>|
|最小生成树|边权和最小的生成树|<span style="color:red">可能不唯一（权重相等时）</span>|
|切割属性|任意切割的最小横跨边必属于某棵 MST|<span style="color:red">证明用反证法 + 替换边</span>|
|通用 MST 算法|不断找切割的最小横跨边加入|<span style="color:red">抽象框架，具体实现需优化</span>|
|Prim 算法（概念版）|从一点开始，每次加入连接已选与未选的最小边|<span style="color:red">与 Dijkstra 类似但优先级含义不同</span>|

---

## 🧠 九、思考题与答案

### 1. 为什么 Dijkstra 算法中，已经访问过的顶点不会再被更新？如果存在负权边，这个结论还成立吗？

**答案**：因为所有未访问顶点的距离都 ≥ 已访问顶点的距离，加上非负权边后，任何通过未访问顶点到达已访问顶点的路径都不小于当前距离。负权边可能使这个推理失效，导致已访问顶点被更短路径更新。

### 2. 在 A* 算法中，如果启发式函数 h(v, goal) 始终为 0，会发生什么？

**答案**：A* 退化为 Dijkstra 算法，会探索所有顶点，找到的是正确的最短路径，但效率较低。

### 3. 如果启发式函数 h(v, goal) 始终大于实际距离（高估），A* 还能保证找到最短路径吗？

**答案**：不能。高估可能导致算法错过最优路径，因为它会优先考虑那些被低估的顶点，而真正的最优路径可能被推迟甚至忽略。

### 4. 用 DFS 检测无向图环时，为什么需要排除父节点？

**答案**：因为无向图中，从当前顶点 v 到其父节点 p 的边是双向的，DFS 从 p 来到 v，在 v 处看到邻接点 p 时，p 已被标记，但这是合法的回溯，不应视为环。只有遇到一个已标记且不是父节点的顶点时，才说明存在环。

### 5. 用并查集检测环时，为什么如果两个端点已在同一集合就说明有环？

**答案**：并查集记录了顶点之间的连通关系。如果两个端点已经在同一集合，说明它们之间已经有一条路径相连，再加入这条边就会形成环。

### 6. 一个连通图一定存在生成树吗？

**答案**：是的，任何连通图都至少有一棵生成树（可以通过不断删除环中的一条边得到）。

### 7. 最小生成树是否唯一？

**答案**：不一定。当图中存在多条权重相同的边时，可能有多棵不同的最小生成树。

### 8. 切割属性中，为什么最小横跨边一定属于某棵 MST？请简要复述证明。

**答案**：假设最小横跨边 e 不在 MST T 中，将 e 加入 T 形成环，环中必有另一横跨边 f。由于 e 是最小的，weight(e) ≤ weight(f)。若 e < f，则用 e 替换 f 得到更小的生成树，矛盾；若 e = f，则得到另一棵包含 e 的 MST。因此 e 必属于某棵 MST。

### 9. Prim 算法概念版中，如何保证每次加入的边不会形成环？

**答案**：因为每次加入的边连接的是已选顶点集和未选顶点集，而已选顶点集内部已经是一棵树（无环），加入这条边只会连接一个新顶点，不会在已选集中形成环。

### 10. 如果图中有负权边，Prim 算法还能正确求出 MST 吗？

**答案**：能。MST 的定义不涉及边的正负，Prim 算法只关心边的权重，不涉及路径求和，因此负权边不影响其正确性。但注意，如果图中有负权边，生成树可能总权重更小，但 Prim 算法仍能正确找到。
## 一、数组和列表

### 1. 上节回顾：双向链表

在上一讲中，我们通过使用哨兵节点（sentinel node）优化了双向链表，使得以下操作都变得快速：

- **添加操作**：`addFirst`、`addLast`
    
- **获取操作**：`getFirst`、`getLast`
    
- **删除操作**：`removeFirst`、`removeLast`
    
- 其他操作：`size`方法
    

**哨兵节点**：作为一个不存储实际数据的中间节点，它连接了链表的头尾，使得在链表两端进行操作时无需处理特殊情况，从而简化了代码并提高了效率。

**项目实践**：这个结构将在项目1A中实现，它是一个包含前后指针的双向链表结构。

---

### 2. 告别链表

#### 2.1 链表随机访问的局限性

虽然链表在两端操作上很快，但当我们想要实现`get(int i)`（返回列表中第i个元素）时，链表就暴露了它的缺点。

**性能缺陷**：

- `get(int i)`需要从哨兵节点开始逐个遍历
    
- 对于长列表（例如100万项）中的中间项（例如第50万项），必须扫描50万次
    
- 时间复杂度为O(n)，随着列表长度线性增加
    

**对比优势**：

- 与`getLast()`等端部操作相比，随机访问效率显著降低
    
- 仅当访问位置靠近哨兵节点时才表现良好
    

#### 2.2 解决方案探索

**远期方案**：期中考试后将讨论通过改变链接设计来优化访问速度，可能涉及更复杂的指针结构或索引机制。

**当前方案**：放弃链表结构，改用数组实现（即`ArrayList`）。数组支持直接索引访问，时间复杂度为O(1)，可以避免指针遍历带来的性能损耗。

#### 2.3 链表总结

**适用场景**：

- 适合频繁在两端进行增删操作的情况
    
- 不适合需要频繁随机访问的场景
    

**转型原因**：

- 数组可以解决链表随机访问慢的根本问题
    
- 对于大规模数据，数组的连续内存访问模式更高效
    

**项目关联**：链表知识仍会在项目1A和考试中出现。

---

### 3. 随机访问

**数组的随机访问**：

- 从数组的任何位置检索数据都非常快，且与数组大小无关
    
- 硬件原理：这种超快速访问源于内存单元（memory boxes）大小相同的硬件特性（具体在61C课程中讲解）
    
- 实际应用：在本课程中可以假设数组访问总是瞬时完成的
    

---

### 4. 数组基础特性

**内存分配**：当声明一个包含五个元素的数组时，Java会分配五个相邻的内存盒来存储这些元素。

**固定大小**：数组长度在创建时就固定，无法动态扩展。如果声明了五个元素的数组，就只会获得五个内存盒，不能后续请求更多空间。

---

### 5. 数组与列表的转换

**设计挑战**：需要利用固定长度的数组结构来实现可无限扩展的列表功能。

**核心矛盾**：列表应该允许用户无限次调用`addLast()`方法，而数组的固定长度特性与此需求相矛盾。

---

### 6. Alist实现原理

**设计类比**：就像汽车维修时更换燃油管路为电池，我们保持用户操作方式不变，但彻底改变底层实现机制。

**公共方法**：`Alist`需要提供与`SLList`相同的公共接口方法，包括`addLast()`、`getLast()`、`removeLast()`等。

**实现差异**：虽然用户接口相同，但底层实现将从链表结构转变为基于数组的实现。

---

### 7. 我们的目标

#### 7.1 列表操作方法

**方法签名**：

- `addLast(int x)`：将元素x插入到列表末尾
    
- `getLast()`：获取列表末尾元素
    
- `get(int i)`：获取第i个元素（从0开始计数）
    
- `size()`：返回列表元素数量
    

#### 7.2 实例变量

**存储结构**：使用数组作为底层存储结构，声明为`private int[] items`

**封装性**：设为`private`是因为数组实现是内部细节，使用者不需要关心具体实现方式

**辅助变量**：同时声明`private int size`用于记录当前列表元素数量

**必要性**：需要单独维护`size`变量来准确跟踪实际存储的元素个数

#### 7.3 初始化列表

**数组初始化**：在构造函数中创建初始容量为100的整型数组

**容量选择**：暂时选择100作为初始容量，后续会讨论动态调整策略

**size初始化**：新建空列表时`size`应初始化为0

**封装原则**：初始化操作完全封装在构造函数中，使用者只需调用`new Alist()`即可获得一个初始化的空列表

#### 7.4 添加元素操作

**构造函数**：


```java

public Alist() {
    items = new int[100];
    size = 0;
}

**addLast方法实现**：

java

public void addLast(int x) {
    items[size] = x;
    size += 1;
}
```
**操作模式**：

- 每次添加元素时，新元素总是放在数组的`size`索引位置
    
- 添加完成后`size`自动加1
    

**示例过程**：

- 初始状态：`size=0`，数组全0
    
- `addLast(5)`：`items[0]=5`，`size=1`
    
- `addLast(2)`：`items[1]=2`，`size=2`
    
- `addLast(7)`：`items[2]=7`，`size=3`
    
- `addLast(6)`：`items[3]=6`，`size=4`
    

**关键发现**：`size`既表示当前元素数量，也指向下一个插入位置（插入位置索引总是等于当前`size`值）

#### 7.5 获取最后一个元素操作

**索引位置**：最后一个元素的位置是`size-1`而不是`size`，因为数组索引从0开始

**示例说明**：当列表中有8个元素时，最后一个元素位于索引7的位置（即8-1=7）

**方法实现**：

```java

public int getLast() {
    return items[size - 1];
}
```
#### 7.6 基本列表操作实现

**get方法**：

```java

public int get(int i) {
    return items[i];
}
```
**size方法**：

```java

public int size() {
    return size;
}
```
#### 7.7 不变式（Invariants）

**不变式定义**：

- 插入位置：新元素总是插入在`size`位置
    
- 大小关系：`size`始终等于列表中元素数量
    
- 末尾位置：最后一个元素总是位于`size-1`位置
    

**实现意义**：这些不变式是代码运行过程中始终保持为真的条件，帮助简化代码编写过程

**错误检查**：可以添加边界检查，如`get(int i)`方法中检查索引是否越界

#### 7.8 用户视角与实现者视角

**用户视角**：只关心列表的抽象概念，如`{5,3,1,7,22,-1}` → `{5,3,1,7,22}`，不关心底层实现细节

**实现者视角**：需要维护具体实现，如100个元素的数组，并确保底层操作正确反映用户期望的抽象行为

**柏拉图的洞穴寓言**：用户如同洞穴中的囚徒，只看到投影（抽象接口）；实现者如同操纵投影的人，负责创建用户看到的"现实"

**设计哲学**：通过抽象隐藏实现细节，简化用户使用体验，允许用户专注于他们需要解决的问题，而不必关心底层实现

#### 7.9 删除列表项操作

**删除操作分析**：

- 当调用`removeLast()`方法时，需要考虑哪些内存单元需要改变？
    

**选项分析**：  
a) 仅改变`size`  
b) 改变`size`和`items`引用  
c) 改变`size`和某个`items[i]`  
d) 改变`size`、`items`引用和某个`items[i]`  
e) 改变`size`、`items`引用和多个`items[i]`

**Alist不变式**：

- 下一个插入项的位置始终是`size`
    
- `size`始终表示Alist中的项目数量
    
- 列表中的最后一项始终位于位置`size-1`
    

**内存修改原理**：

- `size`必须改变：因为删除操作会减少列表中的项目数量，根据不变式`size`必须相应减小
    
- `items`引用不需改变：删除操作不需要改变数组的引用位置，底层数组保持不变
    
- 数组元素不需清零：被删除的元素可以保留在数组中，只要保证`size`正确反映有效元素数量即可
    

**返回值处理**：需要返回被删除的元素，可以通过`getLast()`获取该元素值

**实现细节**：

- 只需将`size`减1即可完成删除操作
    
- 不需要显式清除数组中的元素
    

**代码实现**：

```java

public int removeLast() {
    int returnItem = getLast();
    size = size - 1;
    return returnItem;
}
```
#### 7.10 关于get()方法边界情况的处理

**边界情况**：当`get`索引越界时没有指定行为

**最佳实践**：建议抛出异常

**设计原则**：具体实现只要与用户心智模型匹配即可，需要明确告知用户Alist的行为规范

#### 7.11 Alist的强大功能与潜在问题

**基本功能**：支持`addLast`、`getLast`、`removeLast`等操作，使用数组作为底层存储而非链表

**潜在问题**：当添加项目超过数组初始容量（100）时会出现问题。用户期望列表可以无限扩展，但底层数组大小固定

---

### 8. 数组扩容问题与解决方案

**问题场景**：当Alist中项目数达到数组容量上限时如何继续添加？

**解决方案**：

1. 创建新数组（大小为`size+1`）
    
2. 将旧数组内容复制到新数组
    
3. 更新引用指向新数组
    

**实现原理**：

- 虽然Java数组大小固定，但可以通过创建新数组"模拟"扩容
    
- 旧数组会被垃圾回收器回收
    

#### 8.1 数组扩容的具体实现

**具体步骤**：

1. 创建新数组：`int[] a = new int[size + 1];`
    
2. 使用`System.arraycopy`复制旧数组内容
    
3. 将`items`引用指向新数组：`items = a;`
    
4. 增加`size`值
    

**垃圾回收**：旧数组失去引用后被垃圾回收

**性能考虑**：创建新数组和复制操作会有性能开销

#### 8.2 添加元素操作与数组扩容

**基础实现**：Alist使用数组存储元素，初始容量为100，`size`记录当前元素数量

**addLast方法**：

- 基本操作：将元素x放入`items[size]`位置，然后`size`加1
    
- 扩容触发条件：当`size`等于`items.length`时表示数组已满
    
- 扩容过程：创建新数组，使用`System.arraycopy`复制元素，最后将`items`引用指向新数组
    

**扩容策略**：

- 新数组大小：通常设置为`size+1`，但允许自定义容量
    
- 复制过程：`System.arraycopy(items, 0, a, 0, size)`将原数组元素完整复制到新数组
    
- 引用更新：`items = a`使原引用指向新数组，旧数组被垃圾回收
    

#### 8.3 方法优化：拆分resize逻辑

**优势**：将`resize`逻辑从`addLast`中分离，使每个方法功能单一

**测试便利性**：可以单独测试`resize`和`addLast`的正确性

**可读性**：代码更短小精悍，易于理解和维护

**resize方法**：

- 参数设计：接受`capacity`参数，提供更大的灵活性
    
- 实现细节：内部创建新数组并完成数据迁移
    

#### 8.4 代码编写与测试的重要性

**增量开发**：

- 最佳实践：编写少量代码后立即测试，而非一次性完成大段代码
    
- 调试优势：问题范围小，容易定位错误
    
- 心理优势：频繁获得正向反馈，保持开发动力
    

**测试策略**：

- 单元测试：为每个独立功能编写测试用例
    
- 边界测试：特别关注数组端、空等边界情况
    
- 性能测试：验证扩容操作的时间复杂度
    

---

### 9. 数组扩容的效率分析

**场景描述**：当数组已满（`size=100`）时连续调用两次`addLast`

**扩容过程**：

1. 第一次`addLast`：创建101大小的新数组，复制100个元素
    
2. 第二次`addLast`：创建102大小的新数组，复制101个元素
    

**效率问题**：每次扩容都需要完整复制所有元素，时间复杂度为O(n)

**优化方向**：考虑倍增扩容策略，减少复制操作次数

#### 9.1 扩容操作的内存消耗计算

**扩容机制**：当数组满时调用`addLast`会触发`resize`操作，创建新数组并复制所有元素

**计算示例**：初始100容量的数组连续两次`addLast`：

- 第一次：创建101容量新数组（101次内存操作）
    
- 第二次：创建102容量新数组（102次内存操作）
    
- 总操作量：101 + 102 = 203次内存操作
    

#### 9.2 大规模扩容的时间复杂度分析

**问题场景**：从100容量扩容到1000容量，每次扩容仅增加1容量（`size+1`策略）

**计算原理**：总操作量 = 101 + 102 + ... + 1000 = 约500,000次操作

**数学证明**：通过配对求和（首尾相加等于N+1），共N/2个这样的配对

#### 9.3 性能对比实验

**SLList表现**：插入100,000项耗时约0.05秒，每次操作时间复杂度为O(1)

**Alist表现**：插入相同数量项需要约50亿次操作，呈现二次方级增长（O(N²)）

**性能差异原因**：

- 链表只需修改指针（恒定时间）
    
- 数组需要反复创建和复制（累积时间）
    

---

### 10. 速度测试

**测试方法**：通过创建包含100万项的Alist和SLList进行性能对比测试

**测试指标**：记录添加操作完成所需时间，比较两种数据结构的效率差异

**测试结果**：

- SLList表现：添加100万项仅需0.069秒，性能优异
    
- Alist表现：相同操作需要16秒以上，存在明显性能瓶颈
    

**对比结论**：链表结构(SLList)在大量添加操作时显著优于数组结构(Alist)

---

### 11. Alist添加操作变慢的原因

**根本原因**：每次数组扩容时采用线性增长策略（`size+1`）

**性能影响**：导致每次扩容操作耗时递增，形成O(n²)时间复杂度

**具体表现**：添加100,000项需要约50亿次容器创建操作

---

### 12. 修复方案：调整数组扩容策略

**初步改进**：将`size+1`改为`size+10`的固定增量策略

**效果验证**：100,000项操作时间降至0.3秒，但百万级操作仍需16秒

**缺点**：数据量增大时性能问题重现，无法根本解决问题

#### 12.1 几何级扩容（倍增策略）

**实现方式**：当数组满时，创建比当前容量大一倍的新数组（即`size * 2`）

**核心优势**：随着数组增大，扩容操作频率指数级下降

**数学原理**：均摊分析(Amortized Analysis)证明其O(1)均摊时间复杂度

**实际应用**：Python列表等主流动态数组均采用此策略

**内存考量**：虽然可能造成暂时性内存浪费，但性能提升显著

---

### 13. 应用案例：插入删除千万级项目

**场景描述**：先添加10亿项，后删除9.9亿项

**存在问题**：底层数组仍保持最大容量，造成内存浪费

**解决方案**：添加缩容机制，当使用率低于阈值时按比例缩小数组

**实现建议**：可设置25%使用率阈值触发缩容为当前大小的一半

---

### 14. 内存效率

**使用率定义**：定义使用率R = size / items.length，表示数组实际使用比例

**典型解决方案**：当R < 0.25时将数组大小减半，避免内存浪费

**缩容场景**：当底层数组过大（如100项）而实际使用很少（如4项）时，需要缩容

**实现方式**：创建更小数组，复制有效项，丢弃原大数组

**优势**：避免存储大量无用零值，节省内存空间

**动态调整**：空间不足时扩容，空间利用率过低时缩容

---

### 15. 泛型Alists的介绍

**泛型优势**：使Alist不仅能处理整数，还能处理任意类型对象

**类型参数**：使用尖括号声明类型参数（如`<Glop>`），创建时指定具体类型

**应用示例**：可创建`Alist<String>`处理字符串，或`Alist<Planet>`处理行星对象

#### 15.1 泛型Alists的创建

**Java限制**：不能直接实例化泛型数组（如`new Glorp[8]`）

**解决方案**：使用Object数组并强制转型：`(Glorp[]) new Object[8]`

**编译器警告**：会产生"unchecked cast"警告，但这是Java泛型的限制，必须忽略

#### 15.2 泛型Alists的特殊语法

**数组创建语法**：必须使用`(Glorp[]) new Object[cap]`这种特殊形式

**转型必要性**：这是Java泛型系统的限制，称为"类型擦除"

**内存管理**：与基本类型Alist不同，删除项时需要显式设为`null`

**避免loitering**：不置`null`会导致Java无法回收无引用的大对象，造成内存浪费

#### 15.3 loitering问题

**loitering定义**：保留对已删除对象的引用，阻止垃圾回收

**解决方案**：在`removeLast()`中将删除位置显式设为`null`

**重要性**：对于大对象（如图片）尤为重要，可及时释放内存

**基本类型区别**：基本类型Alist不需要此操作，因为存储的是值而非引用

---

## 二、知识小结

|知识点|核心内容|考试重点/易混淆点|难度系数|
|---|---|---|---|
|**数组与链表对比**|链表操作速度快但随机访问慢，数组随机访问快但需要处理扩容问题|链表随机访问需遍历节点 vs 数组直接索引访问|★★★☆|
|**ArrayList实现原理**|使用动态扩容数组作为底层存储，通过复制迁移实现容量扩展|扩容策略选择(加法扩容低效 vs 乘法扩容高效)|★★★★☆|
|**时间复杂度分析**|链表添加操作O(1)恒定 vs 数组最差情况O(N)扩容开销|百万级数据量时性能差异显著|★★★★☆|
|**泛型实现技巧**|使用Object[]转型解决Java泛型数组限制，注意类型擦除问题|类型安全警告不可避免但可忽略|★★★★☆|
|**内存管理优化**|对象数组需要显式置null避免内存泄漏(loitering问题)|基本类型数组vs对象数组的内存处理差异|★★★☆|
|**不变式(Invariants)维护**|size与数组长度的关系：新元素位置=size，未元素位置=size-1|边界条件处理(空列表/满列表)|★★★☆|
|**设计哲学**|用户心智模型与底层实现分离(洞穴寓言隐喻)|抽象屏障的重要性|★★☆|
|**性能优化策略**|2倍扩容的均摊时间复杂度优化(后续课程证明)|空间换时间权衡|★★★★☆|

---

## 三、关键代码实现总结

### 1. 基本Alist实现（整数版本）

```java

public class Alist {
    private int[] items;
    private int size;
    
    public Alist() {
        items = new int[100];
        size = 0;
    }
    
    public void addLast(int x) {
        if (size == items.length) {
            resize(size + 1); // 简单扩容策略
        }
        items[size] = x;
        size++;
    }
    
    public int getLast() {
        return items[size - 1];
    }
    
    public int get(int i) {
        return items[i];
    }
    
    public int removeLast() {
        int item = getLast();
        size--;
        return item;
    }
    
    public int size() {
        return size;
    }
    
    private void resize(int capacity) {
        int[] a = new int[capacity];
        System.arraycopy(items, 0, a, 0, size);
        items = a;
    }
}
```
### 2. 优化后的Alist（倍增策略）

```java

private void resize(int capacity) {
    // 使用几何增长策略
    int newCapacity = items.length * 2;
    if (newCapacity < capacity) {
        newCapacity = capacity;
    }
    int[] a = new int[newCapacity];
    System.arraycopy(items, 0, a, 0, size);
    items = a;
}
```
### 3. 泛型Alist实现

```java

public class Alist<ItemType> {
    private ItemType[] items;
    private int size;
    
    public Alist() {
        items = (ItemType[]) new Object[100];
        size = 0;
    }
    
    public void addLast(ItemType x) {
        if (size == items.length) {
            resize(size * 2); // 倍增策略
        }
        items[size] = x;
        size++;
    }
    
    public ItemType getLast() {
        return items[size - 1];
    }
    
    public ItemType removeLast() {
        ItemType item = getLast();
        items[size - 1] = null; // 避免loitering
        size--;
        return item;
    }
    
    // 其他方法类似...
}
```
---

## 四、常见问题与解决方案

### 1. 为什么数组访问比链表快？

- **连续内存**：数组元素在内存中连续存储，CPU缓存可以预取相邻元素
    
- **直接计算地址**：访问`array[i]`可以通过`基地址 + i * 元素大小`直接计算，无需遍历
    

### 2. 何时使用链表？何时使用数组？

- **使用链表**：
    
    - 需要频繁在两端添加/删除元素
        
    - 不需要随机访问
        
    - 内存分配不确定或频繁变化
        
- **使用数组（ArrayList）**：
    
    - 需要频繁随机访问元素
        
    - 主要在末尾添加/删除元素
        
    - 内存使用可预测
        

### 3. 如何选择扩容因子？

- **2倍扩容**：最常用，均摊时间复杂度O(1)
    
- **1.5倍扩容**：更节省空间，但性能略低于2倍
    
- **固定增量**：简单但性能差，不适合大规模数据
    

### 4. 如何处理缩容？

- **阈值策略**：当使用率低于25%时缩容一半
    
- **避免抖动**：添加延迟缩容机制，避免频繁扩容缩容
    
- **考虑场景**：根据实际使用模式调整阈值
    

---

## 五、性能对比表

|操作|链表（SLList）|数组（Alist）|备注|
|---|---|---|---|
|`addFirst`|O(1)|O(n)|数组需要移动所有元素|
|`addLast`|O(1)|O(1)（均摊）|数组可能触发扩容|
|`getFirst`|O(1)|O(1)||
|`getLast`|O(1)|O(1)||
|`get(i)`|O(n)|O(1)|数组的直接访问优势|
|`removeFirst`|O(1)|O(n)|数组需要移动所有元素|
|`removeLast`|O(1)|O(1)||
|内存使用|每个元素额外两个指针|可能浪费部分空间|数组可能有未使用空间|

---

通过本讲的学习，你应该能够：

1. 理解链表和数组的优缺点及适用场景
    
2. 掌握使用数组实现动态列表（ArrayList）的基本原理
    
3. 理解并实现数组的动态扩容策略
    
4. 分析不同扩容策略的时间复杂度
    
5. 实现泛型版本的ArrayList并处理内存管理问题
    
6. 理解用户视角与实现者视角的区别，掌握抽象设计思想
    

**记住**：没有完美的数据结构，只有最适合特定场景的数据结构。在实际编程中，应根据具体需求选择最合适的数据结构。
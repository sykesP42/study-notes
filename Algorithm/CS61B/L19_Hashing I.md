# 哈希表（Hashing I）—— 从零开始彻底理解哈希表

> 本文是 CS61B Spring 2024 Lecture 19 的详细笔记，由浅入深带你掌握哈希表的来龙去脉、设计思想、实现细节及 Java 中的应用。无论你是初学者还是想巩固基础，这篇笔记都能帮你构建完整的知识体系。

---

## 📌 一、集合与映射 ADT 回顾

### 1.1 集合与映射的基本操作

- **集合（Set）**：存储不重复的元素，支持添加（add）和包含检查（contains）。
    
- **映射（Map）**：存储键值对，支持根据键查找值，同样需要 add 和 contains 功能。
    

这两种抽象数据类型（ADT）的核心操作都是 **添加** 和 **查询**。

### 1.2 已有实现的性能对比

| 实现方式        | contains 最坏时间复杂度 | add 最坏时间复杂度 | 特点与局限                     |
| ----------- | ---------------- | ----------- | ------------------------- |
| `ArraySet`  | Θ(N)             | Θ(N)        | 简单，但每次都要线性扫描              |
| BST（二叉搜索树）  | Θ(N)             | Θ(N)        | 随机插入时平均 Θ(log N)，但可能退化成链表 |
| 2-3 树       | Θ(log N)         | Θ(log N)    | 保证平衡，但实现非常复杂              |
| LLRB（左倾红黑树） | Θ(log N)         | Θ(log N)    | 与 2-3 树一一对应，实现依然复杂        |
|             |                  |             |                           |

**关键结论**：

- 基于比较的树结构（如 BST、2-3 树）要求元素必须可比较（例如整数、字符串可以比较大小），但现实中很多对象无法直接比较（如“苹果”和“橙子”）。
    
- Θ(log N) 已经非常优秀，但有没有可能 **比 Θ(log N) 更快**？
    

---

## 🧠 二、从生活场景推导哈希表

### 2.1 初始想法：WriteOnTheWallSet（写在墙上的集合）

想象一面墙，你可以用铅笔在上面任意位置写数字。

- **添加**：直接找个空位写上去，O(1)
    
- **查找**：必须扫视整个墙面，O(N)
    

✅ 优点：添加极快，且不关心数据类型（汉字、符号都能写）  
❌ 缺点：查找太慢

### 2.2 改进：BobaCounterSet（奶茶店分类法）

奶茶店取餐时，店员根据订单号的 **末位数字** 将做好的奶茶放在对应编号的格子里（0~9）。  
顾客取餐时只需检查自己订单号对应的格子，不用翻遍所有格子。

#### 应用到集合：

- 将墙面分成 10 个区域（桶），每个区域对应一个数字（0~9）
    
- **添加**：计算数字的末位，放入对应区域 → O(1)
    
- **查找**：只检查末位对应的区域 → 理想情况下 Θ(N/10)，但可能分布不均（比如所有数字都以 0 结尾）
    

#### 暴露的问题：

- 空间浪费：即使某个区域没有元素，也要预留空间
    
- 分布不均：实际数据可能集中在某几个数字上，导致这些区域的查找变成线性
    
- 无法直接处理字符串：如何将字符串映射到 0~9？
    

### 2.3 动态链表数组：DynamicArrayOfListsSet

为了解决空间浪费和分布不均，我们让每个区域 **动态增长**，比如用链表来存储每个桶中的元素。

- **添加**：找到桶号，将元素插入链表头部/尾部
    
- **查找**：只遍历对应桶内的链表
    

此时，如果元素均匀分布，每个桶平均有 **N/M** 个元素（N 总元素数，M 桶数），查找时间 Θ(N/M)。  
如果 M 是常数，那么 N/M 仍会随着 N 增长而增长，最终退化为 Θ(N)。

#### 解决方案：让 M 随 N 增长

只要保证 **N/M ≤ 常数**（即平均每个桶的元素个数不超过某个阈值），那么查找就是常数时间。

---

## 🧮 三、缩减函数（Reduction Function）

如何将任意对象映射到 0 ~ M-1 的桶号？  
最自然的选择：**模运算（mod）**。

- 对整数：`index = value % M`
    
- 对字符串：先转化为整数，再取模
    

模运算的优点：

- 适用于任意 M
    
- 对随机输入能均匀分布
    
- 改变 M 时，只需重新计算所有元素的桶号
    

---

## 📈 四、动态扩容策略

### 4.1 扩容时机

当 **负载因子（load factor）** `N/M` 超过某个阈值（例如 1.5）时，就需要增加桶的数量。

### 4.2 如何增加 M

- **算术增长**：每次加一个固定常数 → 每次扩容都要 O(N) 时间，均摊后仍是 O(N)
    
- **几何增长**：每次乘以一个常数（如翻倍） → 均摊后能达到 O(1)
    

✅ 几何增长（翻倍）是哈希表常用的扩容策略，类似 `ArrayList` 的扩容。

### 4.3 扩容示例

设阈值 `N/M ≥ 1.5` 时翻倍 M。

初始 M=4，添加 7,16,3,11,20,13：

- 添加 7（7%4=3），16（16%4=0），3（3%4=3），11（11%4=3），20（20%4=0），13（13%4=1）
    
- 此时 N=6，M=4，负载因子 6/4=1.5 → 触发扩容，M 翻倍为 8
    
- 重新计算所有元素的桶号（rehashing）
    

---

## 🧵 五、字符串如何变成整数？

### 5.1 简单想法：字母位置求和

将 a=0, b=1, ..., z=25，把单词中每个字母的值加起来。  
例如 "cat" = 2+0+19=21  
❌ 问题：不同单词可能和相同（如 "act" 也是 21），且短单词集中在小区间。

### 5.2 更优：二十六进制

将单词看成以 26 为基数的数：

```text

"cat" = 2×26² + 0×26¹ + 19×26⁰ = 1371

```
- 字母 a=1, b=2, ..., z=26（注意 a≠0，否则 "a" 和 "aa" 都会变成 0）
    
- 这种编码能保证每个小写单词得到唯一整数，只要基数 ≥ 26。
    

### 5.3 扩展到所有 ASCII 字符

ASCII 中可打印字符范围 33~126，最大 126。  
因此可以用 **126 为基数**，将每个字符的 ASCII 码作为位值。  
例如 "bea" = 98×126² + 101×126¹ + 101×126⁰。

#### Java 实现示例

```java

public static int asciiToInt(String s) {
    int intRep = 0;
    for (int i = 0; i < s.length(); i++) {
        intRep = intRep * 126;
        intRep = intRep + s.charAt(i);
    }
    return intRep;
}
```
### 5.4 扩展到 Unicode

如果要支持中文等更多字符，基数需要提高到最大码点（如 40959），这样计算出的整数会极大，很快超出 Java 的 `int` 范围（最大 2,147,483,647）。

---

## ⚠️ 六、整数溢出与哈希码

### 6.1 Java 的 int 溢出

```java

int x = 2147483647;
System.out.println(x + 1); // 输出 -2147483648
```
超过最大值后会绕回最小值，产生负数。

### 6.2 哈希码（hashCode）的必然碰撞

由于 `int` 只有约 40 亿个可能值，而字符串的可能种类无限，**碰撞不可避免**。  
Java 的 `String.hashCode()` 采用基数 31（而非 126 或 40959），既能较快计算，又能分散结果。

### 6.3 为什么用 31？

- 31 是质数，乘法可以用移位减优化：`31 * i = (i << 5) - i`
    
- 能产生较均匀的分布，且碰撞概率在实际中可接受
    

#### String.hashCode() 示例

```java

"横田誠司".hashCode(); // 可能得到 839611422
```
尽管有无数其他字符串也会映射到同一个哈希码，但只要分布均匀，哈希表依然高效。

---

## 🧱 七、哈希表（Hash Table）最终结构

### 7.1 定义

哈希表是一个包含 **M 个桶（bucket）** 的数组，每个桶通常是一个链表（分离链接法）。  
通过 **哈希函数** 将键转换为整数（哈希码），再通过取模得到桶下标，将键值对存入对应桶。

### 7.2 操作流程

1. **添加**：计算键的哈希码 `h = key.hashCode()`，桶号 `i = h % M`，将键值对插入桶 `i` 的链表（若键已存在则更新）。
    
2. **查找**：同样计算桶号，然后遍历该桶的链表，用 `equals` 比较找到目标。
    
3. **扩容**：当负载因子超过阈值（如 0.75），将 M 翻倍，并重新哈希所有元素。
    

### 7.3 时间复杂度

- 理想情况（均匀分布，每个桶大小 O(1)）：**平均 O(1)**
    
- 最坏情况（所有键映射到同一桶）：**O(N)**（链表长度 N）
    

### 7.4 Java 中的实现

- `HashMap` / `HashSet` 正是基于哈希表
    
- 默认初始桶数 16，负载因子 0.75
    
- 当链表过长时（≥8）会转为红黑树（Java 8+ 优化）
    

---

## 🎯 八、均匀分布的重要性

哈希表性能的关键在于 **哈希函数能否让键均匀分布到各个桶**。  
即使负载因子相同，若数据倾斜，某些桶过长，查找就会退化为线性。

#### 如何设计好的哈希函数？

- 对于整数：直接取模，但注意负数的处理（`Math.floorMod` 或 `(h & 0x7fffffff) % M`）
    
- 对于字符串：采用类似 `s[0]*31^(n-1) + s[1]*31^(n-2) + ...` 的算法
    
- 对于自定义类：组合各个域的哈希码，如 `Objects.hash(field1, field2)`
    

---

## 📊 九、知识总结与对比

|知识点|核心内容|重点/易混淆点|难度|
|---|---|---|---|
|哈希表基础|一种用数组+链表实现的 ADT，平均 O(1) 操作|与树结构对比：哈希表平均更快，但不保证顺序；需要好的哈希函数|⭐⭐⭐|
|哈希函数设计|将任意对象转为 int，常用模运算缩减|注意负数的处理；String 用 31 为基数；自定义类要均匀组合|⭐⭐⭐⭐|
|动态扩容|负载因子超阈值时翻倍数组，重新哈希所有元素|算术增长导致 O(N) 均摊，几何增长保证 O(1) 均摊|⭐⭐⭐|
|冲突解决|分离链接法（链表）、开放寻址法（线性探测等）|课程重点讲链表法；实际工程中可能用更复杂方法（如红黑树优化长链表）|⭐⭐|
|均匀分布|哈希函数必须让键均匀分布到桶中，否则性能退化|即使负载因子小，数据倾斜也会导致线性查找|⭐⭐⭐|
|Java 实现细节|`hashCode()` 与 `equals()` 必须一致；默认负载因子 0.75；负数取模需注意|`String.hashCode()` 可能产生负数；`Math.floorMod` 可得到正确正余数|⭐⭐⭐⭐|

---

## 🔍 十、深入扩展：更多哈希知识（选读）

### 10.1 开放寻址法

- 不用链表，所有元素直接存在数组中
    
- 发生冲突时，按某种规则寻找下一个空槽（线性探测、二次探测、双重哈希）
    
- 优点：空间利用率高，缓存友好
    
- 缺点：删除麻烦，容易产生聚集
    

### 10.2 完美哈希

- 对于静态集合，可以构造一个无冲突的哈希函数
    
- 常用于编译器关键字表
    

### 10.3 一致性哈希

- 分布式系统中常用，当节点增减时只需重新映射部分键
    

---

## 💻 附录：手写一个极简哈希表（Java 伪代码）

```java

public class SimpleHashMap<K, V> {
    private static class Node<K, V> {
        K key;
        V value;
        Node<K, V> next;
        // constructor
    }
    private Node<K, V>[] buckets;
    private int size;
    private static final double LOAD_FACTOR = 0.75;
    public SimpleHashMap() {
        buckets = new Node[16];
        size = 0;
    }
    private int hash(K key) {
        return (key.hashCode() & 0x7fffffff) % buckets.length;
    }
    public void put(K key, V value) {
        int index = hash(key);
        Node<K, V> head = buckets[index];
        // 查找是否已存在
        for (Node<K, V> node = head; node != null; node = node.next) {
            if (node.key.equals(key)) {
                node.value = value;
                return;
            }
        }
        // 头插法
        Node<K, V> newNode = new Node<>(key, value, head);
        buckets[index] = newNode;
        size++;
        if (size > buckets.length * LOAD_FACTOR) {
            resize();
        }
    }
    public V get(K key) {
        int index = hash(key);
        for (Node<K, V> node = buckets[index]; node != null; node = node.next) {
            if (node.key.equals(key)) {
                return node.value;
            }
        }
        return null;
    }
    private void resize() {
        Node<K, V>[] old = buckets;
        buckets = new Node[old.length * 2];
        size = 0;
        for (Node<K, V> head : old) {
            for (Node<K, V> node = head; node != null; node = node.next) {
                put(node.key, node.value); // 重新哈希
            }
        }
    }
}
```
---

## ✅ 总结

哈希表通过巧妙的 **空间换时间** 和 **动态扩容**，实现了平均 O(1) 的插入和查找，是现代编程语言中字典、集合的核心实现。  
理解哈希表的关键在于：

- 哈希函数的设计（均匀、快速）
    
- 冲突解决策略
    
- 负载因子与扩容机制
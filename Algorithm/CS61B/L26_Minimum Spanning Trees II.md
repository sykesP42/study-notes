# 🌲 最小生成树（续）与有向无环图 —— Prim 算法优化、Kruskal 算法、拓扑排序全解析

> 本文是 CS61B Spring 2024 Lecture 26 的详细笔记，内容包括 Prim 算法的优先队列优化实现、Kruskal 算法的完整描述与复杂度分析、两种 MST 算法的对比、有向无环图（DAG）的定义、拓扑排序的 DFS 实现及其应用。通过详尽解释、代码示例和思考题，帮助你彻底掌握这些核心算法。

---

## 🔁 一、Prim 算法回顾与优化实现

### 1.1 Prim 算法概念回顾

Prim 算法是一种构建**最小生成树**的贪心算法，其核心思想是：

- 从任意一个顶点开始，逐步扩展生成树。
    
- 每一步都选择一条**连接已在树中的顶点与不在树中的顶点**的**权重最小**的边，将该边和对应的新顶点加入树中。
    
- 重复直到所有顶点都在树中（即获得了 V-1 条边）。
    

**正确性依据**：每一步选择的边都是当前切割的最小横跨边，根据**切割属性**，它必然属于某棵最小生成树。

### 1.2 朴素实现的低效性

概念版 Prim 算法需要每次遍历所有跨越切割的边来找到最小值，这在稠密图中复杂度为 O(V²)。对于稀疏图，我们希望更高效的方法。

### 1.3 优先队列优化版本（类似 Dijkstra）

我们可以用**优先队列**来维护每个不在树中的顶点到当前树的最小距离，从而快速选出下一个要加入的顶点。

#### 数据结构

- `distTo[v]`：顶点 `v` 到当前 MST 的最短距离（即通过某条边直接连接到树的最小权重）。
    
- `edgeTo[v]`：记录这个最短距离对应的边（用于最终构建 MST）。
    
- 优先队列 `pq`：存储所有**不在树中**的顶点，按 `distTo` 值排序。
    

#### 算法步骤

1. **初始化**：
    
    - 选择一个起始顶点 `s`，将其 `distTo[s] = 0`，其余顶点的 `distTo` 设为 `∞`。
        
    - 将所有顶点插入优先队列（或开始时只插入 `s`，然后在松弛时插入新顶点）。
        
2. **主循环**（类似 Dijkstra）：
    
    - 从优先队列中取出 `distTo` 最小的顶点 `v`（此时 `v` 被加入 MST）。
        
    - 对于 `v` 的每条邻接边 `v-w`，权重 `weight`：
        
        - 如果 `w` 尚未在树中（即还在优先队列中）且 `weight < distTo[w]`，则更新 `distTo[w] = weight`，`edgeTo[w] = v`，并调整优先队列中 `w` 的优先级。
            

#### 松弛操作的区别（与 Dijkstra 对比）

- **Dijkstra**：`newDist = distTo[v] + weight`，考虑路径累加和。
    
- **Prim**：`newDist = weight`，只考虑当前边直接连接树的代价。
    

#### 示例演示（假设图）

text

     2       3
  A --- B --- C
  |     |     |
 1|    4|     |5
  |     |     |
  D --- E --- F
     6       7

从 A 开始：

- 初始：distTo[A]=0, 其余 ∞。PQ = [A(0), B(∞), ...]
    
- 取出 A，松弛 A-B(2) → distTo[B]=2，A-D(1) → distTo[D]=1，更新 PQ。
    
- 取出 D（距离 1），松弛 D-E(6) → distTo[E]=6，更新 PQ。
    
- 取出 B（距离 2），松弛 B-C(3) → distTo[C]=3，B-E(4) → 4 < 6 ？否，不更新。
    
- 取出 C（距离 3），松弛 C-F(5) → distTo[F]=5。
    
- 取出 F（距离 5），松弛 F-E(7) → 7 < 5？否。
    
- 取出 E（距离 6），结束。  
    MST 边：A-B(2), A-D(1), B-C(3), C-F(5), 以及 E？实际上 E 被加入时没有更新更小的边，但最终 E 的 edgeTo 可能是 B？需要检查是否通过 B-E(4) 更新了 E？在 B 取出时，E 还在队列中且 distTo[E]=6，4<6 所以应该更新！因此 distTo[E] 最终为 4，edgeTo[E]=B。所以 MST 边还包括 B-E(4)。总边数 = 5（V=6），正确。
    

#### 时间复杂度

- 每个顶点入队一次，出队一次：O(V log V)
    
- 每条边最多导致一次 `decreaseKey` 操作（实际可用插入新节点代替，次数 ≤ E）：O(E log V)
    
- 总复杂度：**O((V+E) log V)**，对于连通图通常简写为 **O(E log V)**。
    

---

## ⚖️ 二、Prim 与 Dijkstra 的对比

|特性|Dijkstra|Prim|
|---|---|---|
|目的|单源最短路径|最小生成树|
|距离定义|到源点的最短路径长度|到当前 MST 的最小边权重|
|松弛公式|`distTo[w] = distTo[v] + weight`|`distTo[w] = weight`|
|结果结构|最短路径树（不一定包含所有顶点）|最小生成树（包含所有顶点）|
|适用图|非负权有向/无向图|任意权无向图（负权不影响）|
|正确性依赖|三角不等式、非负权|切割属性|

**重要**：Prim 算法可以处理负权边，因为它的目标是最小化边权和，负权边只会使树更小，不会影响算法正确性。

---

## 🔨 三、Kruskal 算法

### 3.1 算法思想

Kruskal 算法是另一种构造 MST 的贪心算法，它直接对边进行操作：

- 将图中所有边按权重**从小到大排序**。
    
- 初始化一个空的 MST 集合。
    
- 按顺序遍历每条边，如果这条边连接的两个顶点**不在同一个连通分量中**（即加入后不会形成环），则将其加入 MST，并合并这两个分量。
    
- 重复直到 MST 包含 V-1 条边。
    

### 3.2 数据结构

- **优先队列**（或排序数组）用于按权重取边。
    
- **并查集（Union-Find）** 用于高效判断两个顶点是否连通，以及合并分量。
    

### 3.3 算法步骤（示例）

假设图有 7 个顶点，边按权重排序如下：

text

A-C(1), C-E(1), D-G(1), F-G(1), A-B(2), E-B(3), D-E(3), G-E(3), E-F(4), B-C(5), B-D(11), C-F(15)

过程：

1. 初始化并查集，每个顶点独立。
    
2. 取最小边 A-C(1)：A 和 C 不连通 → 加入 MST，合并 {A,C}。
    
3. 取 C-E(1)：C 和 E 不连通 → 加入，合并 {A,C,E}。
    
4. 取 D-G(1)：D 和 G 不连通 → 加入，合并 {D,G}。
    
5. 取 F-G(1)：F 和 G 不连通 → 加入，合并 {D,G,F}。
    
6. 取 A-B(2)：A 和 B 不连通 → 加入，合并 {A,C,E,B}。
    
7. 取 E-B(3)：E 和 B 已在同一集合 → 跳过（否则会形成环 A-C-E-B-A）。
    
8. 取 D-E(3)：D 和 E 不连通 → 加入，合并 {A,C,E,B} 与 {D,G,F} 成为全连通。
    
9. 此时 MST 已有 6 条边（V-1），算法可终止。
    

### 3.4 环检测原理

并查集维护每个连通分量的代表元。对于边 `(u,v)`：

- 如果 `find(u) == find(v)`，则 u 和 v 已连通，加入此边会形成环，应跳过。
    
- 否则，执行 `union(u,v)`，将两个分量合并。
    

### 3.5 时间复杂度分析

|操作|次数|每次代价|总代价|
|---|---|---|---|
|插入所有边到 PQ|E|O(log E)|O(E log E)|
|删除最小边|E|O(log E)|O(E log E)|
|union|≤ V-1|O(α(V))|O(V α(V))|
|find（isConnected）|E|O(α(V))|O(E α(V))|

总复杂度：**O(E log E + E α(V))**。由于 α(V) 极小，主要项为 O(E log E)。又因为 E ≤ V²，log E ≤ 2 log V，所以也可表示为 **O(E log V)**。

**优化**：如果边已经预排序，则可以直接用数组遍历，省去优先队列操作，时间复杂度降为 **O(E α(V))**，即接近线性。

### 3.6 正确性证明

Kruskal 算法同样基于**切割属性**：当按权重递增顺序考虑边时，当前考虑的边 `e` 一定是某个切割的最小横跨边（该切割的一侧是 `e` 连接的两个分量当前所在的集合）。因为所有比 `e` 权重小的边都已被考虑过且未连接这两个分量，所以 `e` 就是当前切割的最小边，因此属于某棵 MST。

---

## ⚔️ 四、Prim 与 Kruskal 对比

|方面|Prim 算法|Kruskal 算法|
|---|---|---|
|生长方式|从单点逐步扩展|多棵子树合并|
|数据结构|优先队列（顶点）、distTo 数组|优先队列（边）、并查集|
|依赖|图需支持邻接表/矩阵遍历|需要边集|
|时间复杂度|O(E log V)（二叉堆）|O(E log E) = O(E log V)|
|适用场景|稠密图（邻接矩阵时可用 O(V²) 版本）|稀疏图（边已排序时可达近似线性）|
|实现复杂度|中等，与 Dijkstra 类似|简单，主要依靠并查集|

**注意**：两者在理论复杂度上界相同，但常数和实际性能可能因图结构而异。

---

## 🔄 五、MST 算法历史拾趣

- 1975年：Yao 提出 O(E log log V) 算法。
    
- 1984年：Fredman-Tarjan 提出 O(E log* V) 算法（使用斐波那契堆）。
    
- 1986年：Gabow 等改进到 O(E log log* V)。
    
- 1997-2000年：Chazelle 提出 O(E α(V)) 算法（α 为反阿克曼函数）。
    
- 2002年：Pettie-Ramachandran 提出最优算法，但常数巨大，实际很少使用。
    

目前仍未证明是否存在**线性时间**的确定性 MST 算法。

---

## 📐 六、有向无环图（DAG）与拓扑排序

### 6.1 DAG 的定义

**有向无环图**（Directed Acyclic Graph, DAG）是一种有向图，其中不存在任何有向环。这意味着无法从某个顶点出发沿有向边回到自身。

**应用**：

- 任务调度（如课程先修关系）
    
- 工程流程（如编译依赖）
    
- 数据流分析
    

### 6.2 拓扑排序

**拓扑排序**是 DAG 的顶点的一种线性排序，使得对于每条有向边 `u → v`，顶点 `u` 在排序中都出现在 `v` 之前。直观上，它表示任务的先后顺序。

**存在性**：一个图有拓扑排序当且仅当它是 DAG（无环）。

### 6.3 基于 DFS 的拓扑排序算法

#### 算法思想

对图进行深度优先搜索（DFS），在递归返回时记录顶点（即后序顺序）。最后将后序列表反转即得到拓扑排序。

**为什么后序反转有效？**  
因为 DFS 会先探索深层节点，当某个节点的所有后继都被访问完后才将其加入后序列表，所以后序中越靠前的节点实际上是依赖链的末端。反转后，起点（无依赖的节点）就会出现在前面。

#### 步骤

1. 从所有**入度为 0** 的顶点开始 DFS（注意：需要遍历所有顶点，因为图可能不连通）。
    
2. 维护一个 `marked` 数组防止重复访问。
    
3. 在 DFS 递归返回时，将当前顶点压入一个栈（或列表末尾）。
    
4. 完成所有 DFS 后，栈中从顶到底的顺序（或列表反转后）即为拓扑排序。
    

**伪代码**：

java

Stack<Integer> reversePost = new Stack<>();
boolean[] marked = new boolean[V];
void dfs(Graph G, int v) {
    marked[v] = true;
    for (int w : G.adj(v)) {
        if (!marked[w]) dfs(G, w);
    }
    reversePost.push(v);
}
void topologicalSort() {
    for (int v = 0; v < V; v++) {
        if (!marked[v]) dfs(v);
    }
    while (!reversePost.isEmpty()) {
        System.out.print(reversePost.pop() + " ");
    }
}

#### 为什么要从入度为 0 的顶点开始？

- 从任意顶点开始 DFS 也可以，但可能得到多个后序序列，只要最后整体反转即可。但为了保证算法能访问所有顶点，我们需要对所有未访问顶点调用 DFS。实际上，从入度为 0 的顶点开始并不是必须的，但有助于理解：入度为 0 的顶点没有前驱，自然应该排在前面。
    

#### 处理不连通图

算法中通过循环对所有未访问顶点调用 DFS，自然可以处理多个连通分量。

#### 示例

考虑课程依赖图：A（CS61A）→ B（CS61B）→ C（CS61C），以及另一条链 D（Math）→ E（Physics）。DFS 从 A 开始，深入 B、C，记录 C、B、A；然后从 D 开始，记录 E、D。最终后序栈（从底到顶）为 [C, B, A, E, D]，反转得 [A, B, C, D, E] 即拓扑排序（注意 D 在 E 前，因为 D→E）。

### 6.4 拓扑排序的应用

#### 1. 任务调度与课程安排

直接使用拓扑排序得到合理的执行顺序。

#### 2. DAG 上的最短路径（可以处理负权边）

由于 DAG 无环，我们可以按**拓扑顺序**处理顶点，从而在 **O(V+E)** 时间内求出从源点到所有点的最短路径（即使边权为负）。算法：

- 对图进行拓扑排序。
    
- 初始化 distTo[s]=0，其余为 ∞。
    
- 按拓扑顺序遍历每个顶点 v，对 v 的每条出边 v→w 进行松弛：`if (distTo[v] + weight < distTo[w]) update`。
    

因为拓扑顺序保证了在到达 v 时，所有能到达 v 的路径都已经考虑过（没有环，所以不会出现更晚的顶点更新 v），因此可以正确求出最短路径。这比 Dijkstra 更通用（支持负权），但要求图无环。

---

## 🔍 七、知识点总结（彩色标记）

|知识点|核心内容|<span style="color:red">重点/易错点</span>|
|---|---|---|
|Prim 算法优化|用优先队列维护顶点到 MST 的距离，类似 Dijkstra 但松弛公式不同|<span style="color:red">distTo 记录的是边权，不是路径和；与 Dijkstra 区分</span>|
|Kruskal 算法|按权重递增顺序加边，用并查集避免环|<span style="color:red">需先排序边；环检测用并查集</span>|
|切割属性|任意切割的最小横跨边必属于某棵 MST|<span style="color:red">证明用反证法；是 Prim 和 Kruskal 正确性的基础</span>|
|Prim vs Kruskal|Prim 从点扩展，Kruskal 从边合并；复杂度均为 O(E log V)|<span style="color:red">Prim 适合稠密图，Kruskal 适合稀疏图（边已排序时更快）</span>|
|DAG 定义|有向无环图|<span style="color:red">无环是拓扑排序的前提</span>|
|拓扑排序（DFS 后序反转）|从所有入度为 0 的顶点开始 DFS，记录后序，反转即得|<span style="color:red">后序反转的原因：深层节点先记录，反转后浅层在前</span>|
|DAG 上的最短路径|按拓扑顺序松弛所有边，可处理负权，O(V+E)|<span style="color:red">与 Dijkstra 对比：不需要优先队列，但要求无环</span>|
|环检测|DFS 中遇到已访问的非父节点（无向）或用并查集（有向需额外处理）|<span style="color:red">无向图环检测用 DFS 或并查集；有向图需用 DFS 标记栈</span>|

---

## 🧠 八、思考题与答案

### 1. Prim 算法优化版中，`distTo[v]` 表示什么？它与 Dijkstra 中的 `distTo` 有何不同？

**答案**：`distTo[v]` 表示顶点 v 到当前最小生成树的最短距离，即连接 v 与树中某顶点的最小边权。Dijkstra 中的 `distTo` 表示从源点到 v 的当前最短路径长度（可能经过多个顶点）。Prim 的松弛只考虑当前边的权重，而 Dijkstra 的松弛累加路径和。

### 2. 为什么 Kruskal 算法中要用并查集？如果不使用并查集，还能实现吗？

**答案**：并查集能高效判断两个顶点是否连通（接近常数时间）。如果不使用并查集，可以在加入边前对当前 MST 进行 DFS 判断是否形成环，但每次 O(V+E) 太慢。所以并查集是 Kruskal 高效的关键。

### 3. 如果图中有负权边，Prim 算法还能正确求出 MST 吗？Kruskal 呢？

**答案**：能。MST 的定义只关心边权和，不涉及路径，负权边只会使总权更小，不会破坏贪心选择性质。Prim 和 Kruskal 依然正确。

### 4. 拓扑排序中，为什么必须从入度为 0 的顶点开始 DFS？如果从任意顶点开始，结果会怎样？

**答案**：不一定必须从入度为 0 的顶点开始，但为了确保所有顶点都被访问，我们需要对每个未访问顶点调用 DFS。如果从任意顶点开始，最终的后序反转仍然能得到正确的拓扑排序，因为 DFS 会自动处理依赖关系。但入度为 0 的顶点是自然的起点，可以帮助理解。

### 5. 如何判断一个有向图是否有环？给出一种基于 DFS 的方法。

**答案**：在 DFS 中，维护一个递归栈数组 `onStack`，当访问一个顶点时将其标记为在栈上，递归返回时取消标记。如果遇到一个已在栈上的邻接点，则说明存在环（有向图中）。这与无向图的环检测不同（无向图需排除父节点）。

### 6. 为什么 DAG 上的最短路径算法可以处理负权边，而 Dijkstra 不能？

**答案**：DAG 无环，因此按拓扑顺序处理顶点时，每个顶点被处理时所有到达它的路径都已经考虑过（因为没有环导致后续更新）。负权边不会引起无限下降或延迟更新。Dijkstra 依赖非负权来保证已处理顶点不再被更新，而 DAG 算法通过拓扑顺序避免了这个问题。

### 7. 对于一个有 1000 个顶点、10000 条边的稀疏图，你会选择 Prim 还是 Kruskal？为什么？

**答案**：两者渐进复杂度相同，但实际可考虑：如果边已经预排序，Kruskal 可以更快（省去优先队列）。否则，Prim 可能稍快，因为它只操作顶点，且现代计算机对数组访问更友好。但通常选择实现简单的那个，两者都是好选择。

### 8. 证明：如果图的所有边权都不相等，则最小生成树唯一。

**答案**：假设有两棵不同的 MST T1 和 T2，考虑它们中权值最小的边 e 只在其中一棵中（如 T1 中有，T2 中无）。将 e 加入 T2 会形成环，环中必有一条边 f 不在 T1 中且权重大于 e（因为 e 最小）。用 e 替换 f 得到更小的生成树，矛盾。因此权值互异时 MST 唯一。
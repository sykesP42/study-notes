# 🧭 最短路径（Shortest Paths）—— 从 BFS 到 Dijkstra

> 本文是 CS61B Spring 2024 Lecture 24 的**超详细笔记**，目标是通过极其详尽的讲解，让你即使不看视频也能彻底掌握 Dijkstra 最短路径算法。我们将从最基础的问题定义开始，逐步剖析算法的每个细节，包括错误算法的反例、正确算法的逐步推导、数据结构的选择、松弛操作的原理、正确性的严格证明、时间复杂度的详细计算，以及大量思考题和答案。

---

## 📌 一、问题定义：什么是最短路径？

### 1.1 单源单目标最短路径（Single Source Single Target Shortest Path）

**问题描述**：给定一个**带权有向图**（或无向图）G=(V,E)G=(V,E)，每条边 ee 有一个**非负权重** w(e)w(e)（通常表示距离、时间、成本等）。给定一个**源顶点** ss 和一个**目标顶点** tt，求从 ss 到 tt 的**总权重最小**的路径。

**例子**：

```text

      2       3
  0 ───→ 1 ───→ 4
  │       │       │
5 │       │ 1     │ 4
  ↓       ↓       ↓
  2 ───→ 5 ───→ 3
      6       1

```
从 0 到 5 的路径：

- 0→1→4→5：2 + 3 + 4 = 9
    
- 0→2→5：5 + 6 = 11
    
- 0→1→5？没有直接边 1→5。
    
- 0→1→4→3→5？4→3 权 4，3→5 权 1，总长 2+3+4+1=10，大于 9。
    

所以最短路径是 0→1→4→5，长度为 9。

**重要性质**：如果所有边权为正，那么最短路径一定是**简单路径**（不含环）。因为如果路径中有环，去掉环后的路径总权更小（环权为正）。这个性质是后面算法设计的基础。

### 1.2 单源最短路径（Single Source Shortest Paths）

**问题扩展**：找到从源顶点 ss 到**所有其他顶点**的最短路径。这个问题的解可以用一棵树来表示，称为**最短路径树（Shortest Paths Tree, SPT）**。

**为什么是一棵树？**

- 从 ss 到每个顶点 vv 的最短路径是唯一的（假设没有等长路径竞争），这些路径的并集不会形成环，因为如果有环，则环上的某个顶点可以通过另一条更短的路径到达，矛盾。
    
- 每个非源顶点在最短路径上有唯一的“父节点”（即路径上到达它的前一个顶点），因此这些边构成一棵以 ss 为根的有向树（或无向树）。
    
- 树中包含恰好 ∣V∣−1∣V∣−1 条边（假设所有顶点从 ss 可达）。
    

**注意**：即使有多个等长最短路径，我们也可以选择其中一条，仍然构成树。

---

## 🧪 二、从 BFS 到 Dijkstra：一步步推导正确算法

为了理解 Dijkstra 算法为什么是“正确”的，我们不妨先看看一些**错误**的尝试，从中吸取教训。

### 2.1 坏算法 #1：直接套用 BFS

**思路**：BFS（广度优先搜索）按“边数”逐层访问顶点。如果我们把 BFS 用到带权图上，会怎么样？

**操作**：从 ss 开始，BFS 依次访问距离为 1 条边、2 条边、3 条边……的顶点。当首次访问到一个顶点时，就认为找到了到它的最短路径，并记录下这条边（加入 SPT）。

**反例**：

```text

    A ---5---> B
    |           ^
    1           |
    +---> C --1-+
```
- 边：A→B (5), A→C (1), C→B (1)
    
- BFS 从 A 开始：
    
    - 第一层：访问 B（通过 A→B）和 C（通过 A→C）。记录 A→B 和 A→C。
        
    - 第二层：从 C 出发，发现 B（通过 C→B）。但此时 B 已经被访问过，BFS 不会再处理 B（因为 BFS 中每个顶点只入队一次）。
        
- 最终 SPT 包含 A→B（权 5）和 A→C（权 1），但真正的最短路径到 B 应该是 A→C→B（权 2）。BFS 错误地将 A→B 当作了最短路径。
    

**根本原因**：BFS 只考虑**边的数量**，而不考虑边的权重。在带权图中，**边数少不一定意味着总权小**。

### 2.2 坏算法 #2：虚拟节点 BFS

**思路**：既然问题出在边权不一致，我们能不能把每条长度为 ww 的边拆成 ww 条单位长度的边（即添加 w−1w−1 个虚拟节点），然后在新的**无权图**上运行 BFS？这样 BFS 就会按**实际距离**（单位边数）访问顶点。

**优点**：访问顺序正确（先距离 1，再距离 2，等等），能保证找到最短路径。

**致命缺点**：如果边权很大（例如 316,800），就需要添加大量虚拟节点，导致图规模爆炸，内存和时间都无法承受。而且边权可能是小数，拆成单位边就更不可行。

**结论**：理论上可行，但实践中完全不可用。

### 2.3 坏算法 #3：最佳优先搜索（Best-First Search）但不更新

**思路**：我们不实际创建虚拟节点，但模仿 BFS 按距离递增的顺序访问顶点。如何知道哪些顶点距离更近？我们可以维护一个优先队列，按**当前已知的最短距离**排序顶点。初始时，只有源点距离 0，其他为无穷大。每次从队列中取出距离最小的顶点 vv，标记它为“已访问”，并将所有从 vv 出发的边检查一遍，如果发现通过 vv 可以到达某个未访问顶点 ww，且这条路径比之前记录的更短，就更新 ww 的距离，并记录下这条边（即 v→wv→w 加入 SPT）。但这里有一个关键：**一旦一个顶点被标记为“已访问”，就不再考虑它了**（即不更新它）。

**这个算法其实就是“贪心”的，但缺少了“替换”机制**。

**反例**（和前面一样）：

```text

    A ---5---> B
    |           ^
    1           |
    +---> C --1-+
```
- 初始队列：[(A,0), (B,∞), (C,∞)]
    
- 取出 A（距离 0）：
    
    - 检查 A→B：更新 B 距离为 5，记录 edgeTo[B]=A，队列中 B 优先级变为 5。
        
    - 检查 A→C：更新 C 距离为 1，记录 edgeTo[C]=A，队列中 C 优先级变为 1。
        
- 此时队列：[(C,1), (B,5)]
    
- 取出 C（距离 1）：
    
    - 检查 C→B：发现 C→B 权 1，距离 = 1+1=2 < 当前 B 的 5，于是更新 B 的距离为 2，记录 edgeTo[B]=C，队列中 B 优先级变为 2。
        
    - 但注意：B 此时还没有被“访问”（即还没有从队列中取出），所以更新是有效的。
        
- 此时队列：[(B,2)]（因为 C 被取出后就不在了）
    
- 取出 B（距离 2）：
    
    - 处理完毕。
        

**咦？这个例子好像成功了？** 是的，因为 B 在取出之前被更新了。但如果我们换一个图，让更新发生在 B 被取出之后呢？考虑这个图：

```text

    A ---5---> B ---1---> D
    |           ^
    1           |
    +---> C --2-+
```
- A→B (5), A→C (1), C→B (2), B→D (1)
    
- 算法过程：
    
    - 取出 A：更新 B=5，C=1。
        
    - 队列：[(C,1), (B,5)]
        
    - 取出 C：更新 B 为 1+2=3 < 5，所以 B 变为 3。更新队列中 B 优先级为 3。
        
    - 队列：[(B,3)]
        
    - 取出 B：更新 D 为 3+1=4。
        
    - 队列：[(D,4)]
        
    - 取出 D：结束。  
        这仍然正确。
        

**那么问题出在哪里？** 问题在于：如果某个顶点在**被取出之后**，又有一条更短的路径到达它，我们无法更新它，因为已经标记为“已访问”了。例如这个图：

```text

    A ---3---> B
    |           ^
    1           |
    +---> C --2-+
    |           ^
    2           |
    +---> D --1-+
```
边：A→B(3), A→C(1), C→B(2), A→D(2), D→B(1)

- 算法：
    
    - 取出 A：更新 B=3, C=1, D=2。
        
    - 队列：[(C,1), (D,2), (B,3)]
        
    - 取出 C：更新 B 为 1+2=3，与当前 B=3 相等或相等？相等，可以不更新（但也可以更新，不影响）。
        
    - 队列：[(D,2), (B,3)]
        
    - 取出 D：更新 B 为 2+1=3，仍然相等。
        
    - 队列：[(B,3)]
        
    - 取出 B：结束。  
        仍然正确。
        

**那么需要更极端的例子**：让一个顶点在取出后，通过某个**尚未处理的顶点**的路径变得更短。但根据算法，当我们取出一个顶点时，它是当前距离最小的未处理顶点，所有其他未处理顶点的距离都 ≥ 它。因此，任何经过其他未处理顶点到达它的路径，长度至少是那个未处理顶点的距离加上正权边，一定 ≥ 当前距离（因为未处理顶点距离 ≥ 当前距离）。所以**不会出现取出后又被更短路径更新的情况**，只要所有边权非负。这正是 Dijkstra 算法的核心思想！所以算法 #3 实际上就是 Dijkstra 算法吗？不，还差一点：算法 #3 中我们只更新未访问顶点，而 Dijkstra 算法允许更新任何顶点（包括已经入队的顶点），并且当顶点被取出后，我们确信它是最优的，不再需要更新。所以算法 #3 其实已经接近了，但还需要一个关键细节：**当我们更新一个已经在队列中的顶点的距离时，如何调整它在队列中的位置？** 这需要优先队列支持 **decreaseKey** 操作。

**结论**：算法 #3 的正确性依赖于两个关键点：

1. 按当前已知距离最小的顺序处理顶点（最佳优先）。
    
2. 当发现更短路径时，更新该顶点的距离，并调整它在优先队列中的优先级。
    

如果优先队列不支持动态调整优先级（decreaseKey），我们可能会遇到问题：比如我们更新了某个顶点的距离，但它在队列中的位置仍然是旧的距离，导致后来取出时得到的是旧的距离，从而错误。所以我们需要一种机制来保证队列中的顶点总是按最新距离排序。

### 2.4 Dijkstra 算法的完整思想

Dijkstra 算法综合了以上所有教训，提出了两个核心操作：

- **最佳优先顺序**：使用优先队列，每次取出当前已知距离最小的未处理顶点。
    
- **松弛（Relaxation）**：当从顶点 vv 出发检查边 v→wv→w 时，如果 `distTo[v] + weight(v,w) < distTo[w]`，则更新 `distTo[w]` 和 `edgeTo[w]`，并**调整优先队列中 ww 的优先级**（decreaseKey）。
    

这两个操作保证了算法能正确找到最短路径。

---

## 🚀 三、Dijkstra 算法：每一步的详细解析

### 3.1 数据结构

我们维护以下数据结构：

- **`distTo[v]`**：从源点 ss 到顶点 vv 的当前已知最短距离。初始时，`distTo[s] = 0`，其余为 `∞`（通常用一个大数如 `Integer.MAX_VALUE`）。
    
- **`edgeTo[v]`**：到达顶点 vv 的最短路径上的前一个顶点。初始时全部为 `null`。通过它我们可以重建路径。
    
- **优先队列 `pq`**：存储所有**未处理**的顶点，并按 `distTo` 值排序。初始时，所有顶点都在队列中（但距离 ∞ 的顶点优先级最低，通常我们一开始只放入源点，或者全部放入但允许更新）。
    

### 3.2 算法步骤（伪代码）

```c

Dijkstra(G, s):
    // 初始化
    for each vertex v in G:
        distTo[v] = ∞
        edgeTo[v] = null
    distTo[s] = 0
    pq = new PriorityQueue(comparator based on distTo)
    pq.insert(s, 0)   // 或者插入所有顶点，但只有 s 有有限距离
    while pq is not empty:
        v = pq.removeMin()          // 取出当前距离最小的未处理顶点
        for each edge (v, w) with weight wgt:
            relax(v, w, wgt)
relax(v, w, wgt):
    if distTo[v] + wgt < distTo[w]:
        distTo[w] = distTo[v] + wgt
        edgeTo[w] = v
        if pq contains w:
            pq.decreaseKey(w, distTo[w])   // 更新 w 的优先级
        else:
            pq.insert(w, distTo[w])
```
**注意**：如果一开始没有将所有顶点放入队列，那么第一次遇到某个顶点时才将其插入队列。上面代码假设我们只插入有有限距离的顶点，这样在 `relax` 中如果 `w` 不在队列中（即尚未被发现），则插入。

### 3.3 详细演示：一个复杂例子

为了让你彻底理解每一步，我们用一个更复杂的图逐步演示。图如下（带权有向图，顶点数 8，源点为 A）：

```text

      2       3       4
A ───→ B ───→ C ───→ D
│              ↑       │
│1             │1      │2
↓              │       ↓
E ───→ F ───→ G ───→ H
   5       1       3
```
为了清晰，列出所有边（有向）：

- A→B (2)
    
- A→E (1)
    
- B→C (3)
    
- C→D (4)
    
- C→G (1)
    
- E→F (5)
    
- F→G (1)
    
- G→H (3)
    
- G→D (2)
    

假设所有边权为正。

**目标**：找到从 A 到所有顶点的最短路径。

#### 步骤 0：初始化

- `distTo`：A=0, B=∞, C=∞, D=∞, E=∞, F=∞, G=∞, H=∞
    
- `edgeTo`：全 null
    
- 优先队列 `pq`：只放入 A，键值 0。`pq = [(A,0)]`
    

#### 步骤 1：取出 A（当前最小，距离 0）

处理 A 的出边：

- A→B (2)：`distTo[B]` 从 ∞ 更新为 0+2=2，`edgeTo[B]=A`。B 不在队列中，插入 B，键值 2。
    
- A→E (1)：`distTo[E]` 从 ∞ 更新为 0+1=1，`edgeTo[E]=A`。插入 E，键值 1。  
    此时队列：[(E,1), (B,2)]（按距离排序，E 在前）
    

#### 步骤 2：取出 E（距离 1）

处理 E 的出边：

- E→F (5)：`distTo[F]` 从 ∞ 更新为 1+5=6，`edgeTo[F]=E`。插入 F，键值 6。  
    队列：[(B,2), (F,6)]
    

#### 步骤 3：取出 B（距离 2）

处理 B 的出边：

- B→C (3)：`distTo[C]` 从 ∞ 更新为 2+3=5，`edgeTo[C]=B`。插入 C，键值 5。  
    队列：[(C,5), (F,6)]
    

#### 步骤 4：取出 C（距离 5）

处理 C 的出边：

- C→D (4)：`distTo[D]` 从 ∞ 更新为 5+4=9，`edgeTo[D]=C`。插入 D，键值 9。
    
- C→G (1)：`distTo[G]` 从 ∞ 更新为 5+1=6，`edgeTo[G]=C`。插入 G，键值 6。  
    队列：[(F,6), (G,6), (D,9)] （F 和 G 距离相同，顺序可能任意）
    

#### 步骤 5：取出 F（距离 6）

处理 F 的出边：

- F→G (1)：检查 `distTo[G]` 当前为 6，新距离 = 6+1=7 > 6，所以不更新。  
    队列：[(G,6), (D,9)]
    

#### 步骤 6：取出 G（距离 6）

处理 G 的出边：

- G→H (3)：`distTo[H]` 从 ∞ 更新为 6+3=9，`edgeTo[H]=G`。插入 H，键值 9。
    
- G→D (2)：`distTo[D]` 当前为 9，新距离 = 6+2=8 < 9，所以更新 `distTo[D]=8`，`edgeTo[D]=G`。同时需要调整队列中 D 的优先级：D 原键值 9 需要改为 8。这需要优先队列支持 **decreaseKey**。更新后，队列中 D 现在键值 8，H 键值 9。  
    队列：[(D,8), (H,9)]（因为 D 现在 8 < H 的 9）
    

#### 步骤 7：取出 D（距离 8）

处理 D 的出边：假设 D 没有出边（或已处理完）。  
队列：[(H,9)]

#### 步骤 8：取出 H（距离 9）

处理 H 的出边：无。  
队列为空，算法结束。

#### 最终结果

- distTo: A=0, B=2, E=1, C=5, F=6, G=6, D=8, H=9
    
- edgeTo: B←A, E←A, C←B, F←E, G←C, D←G, H←G
    

从这些信息我们可以重建到每个顶点的最短路径：

- 到 B：A→B
    
- 到 E：A→E
    
- 到 C：A→B→C
    
- 到 F：A→E→F
    
- 到 G：A→B→C→G
    
- 到 D：A→B→C→G→D
    
- 到 H：A→B→C→G→H
    

**验证**：

- 到 D 的两条路径：A→B→C→D 长度 2+3+4=9，A→B→C→G→D 长度 2+3+1+2=8，后者更短，正确。
    
- 到 H：A→B→C→G→H 长度 2+3+1+3=9。
    

**观察**：当我们在步骤 6 更新 D 的距离时，D 已经在队列中（之前从 C 发现过），我们成功降低了它的优先级，并最终得到了正确的最短路径。这正是 Dijkstra 算法的关键：允许**后期发现更短路径**并更新。

---

## ⚙️ 四、优先队列的实现细节

在 Dijkstra 算法中，优先队列需要支持两种操作：

1. `removeMin()`：取出当前最小键值的顶点。
    
2. `decreaseKey(v, newKey)`：将顶点 v 的键值降低为 newKey（前提是 newKey < 当前键值）。
    

Java 标准库的 `PriorityQueue` **不直接支持 decreaseKey**。但我们可以用以下技巧模拟：

- **懒删除（Lazy Deletion）**：当我们更新一个顶点的距离时，不修改队列中的旧条目，而是**插入一个新的条目**（顶点和新距离）。这样队列中可能有同一个顶点的多个副本。当取出顶点时，我们检查该顶点的当前距离是否与 `distTo` 中记录的一致。如果不一致（说明是旧的、过期的条目），则丢弃，继续取下一条。
    
- 这样，每个顶点可能被插入多次，但总插入次数不超过边数（每次松弛可能产生一次插入）。复杂度变为 O((V+E) log (V+E)) = O(E log V)（因为 E 通常主导）。
    

**实现示例**：

```java

PriorityQueue<Node> pq = new PriorityQueue<>(Comparator.comparingInt(n -> n.dist));
pq.add(new Node(s, 0));
while (!pq.isEmpty()) {
    Node node = pq.poll();
    int v = node.id;
    if (node.dist != distTo[v]) continue; // 过期条目，跳过
    // 处理 v 的出边
    for (Edge e : adj[v]) {
        int w = e.to;
        int newDist = distTo[v] + e.weight;
        if (newDist < distTo[w]) {
            distTo[w] = newDist;
            edgeTo[w] = v;
            pq.add(new Node(w, newDist));
        }
    }
}
```
其中 `Node` 是包含顶点 id 和当前距离的简单类。

**注意**：这个实现中，我们并没有显式地 `decreaseKey`，而是通过插入新节点并跳过旧节点来实现相同的效果。这是实际编程中常用的方法。

---

## ✅ 五、正确性证明（数学归纳）

**定理**：Dijkstra 算法结束后，对于每个顶点 vv，`distTo[v]` 是从源点 ss 到 vv 的最短路径长度，且如果 `distTo[v] < ∞`，则存在一条路径（可由 `edgeTo` 回溯得到）达到该长度。

**证明思路**：采用归纳法。设 SS 为已经从优先队列中取出的顶点集合。归纳假设：对于所有 v∈Sv∈S，`distTo[v]` 已经是最短距离，并且不会再改变。

**基础**：初始时 S=∅S=∅，平凡成立。

**归纳步骤**：假设当前所有已取出的顶点都满足假设。现在从优先队列中取出顶点 uu（即 `u` 是当前队列中 `distTo` 最小的顶点）。我们需要证明 `distTo[u]` 就是到 `u` 的最短距离。

假设存在一条从 ss 到 uu 的更短路径 PP。考虑路径 PP 上第一个不在 SS 中的顶点（记为 xx）。由于 s∈Ss∈S（因为 ss 是第一个取出的），这样的 xx 一定存在。设路径上 xx 的前一个顶点为 y∈Sy∈S，那么路径 PP 可以分成两部分：s→⋯→y→x→⋯→us→⋯→y→x→⋯→u。根据归纳假设，`distTo[y]` 已经是 ss 到 yy 的最短距离，所以 `distTo[y] ≤ length(s→y)`。那么路径 PP 的长度 ≥ `distTo[y] + weight(y,x)`。由于 yy 在取出时，已经松弛了边 y→xy→x，所以此时 `distTo[x] ≤ distTo[y] + weight(y,x)`。因此路径 PP 的长度 ≥ `distTo[x]`。又因为 uu 是当前队列中距离最小的顶点，而 xx 还在队列中（因为 x∉Sx∈/S），所以 `distTo[x] ≥ distTo[u]`。综上，路径 PP 的长度 ≥ `distTo[x] ≥ distTo[u]`，与假设矛盾。因此 `distTo[u]` 已经是最短距离。

**关键**：证明中利用了“所有边权非负”这一条件，否则无法保证 `distTo[x] ≥ distTo[u]`。

---

## ⏱️ 六、时间复杂度详细分析

### 6.1 基础操作

- 每个顶点被取出一次（从优先队列中 `removeMin`）。
    
- 每条边被松弛一次（即检查一次）。在松弛时，可能更新 `distTo` 并触发一次优先队列的插入（或 decreaseKey）。
    

### 6.2 优先队列操作的代价

- 如果用二叉堆实现优先队列，`removeMin` 和 `insert` 都是 O(log N)。`decreaseKey` 如果用标准堆不支持，但我们可以用插入新节点的方式，这样每个顶点可能被插入多次，但每个松弛最多导致一次插入（即每个边最多一次）。所以总插入次数 ≤ E。
    
- 取出操作次数 = V（每个顶点一次，忽略过期条目的话，过期条目也会被取出并丢弃，但每个插入对应一次取出，所以总取出次数 ≤ 插入次数 ≤ E）。
    
- 因此总操作次数约为 O(V + E) 次堆操作，每次 O(log (V+E))，由于 E 通常主导，所以总复杂度 **O(E log V)**。
    

### 6.3 如果使用斐波那契堆

斐波那契堆支持 `decreaseKey` 在 **O(1)** 均摊时间，`removeMin` 仍为 O(log V)。这样总复杂度可降为 **O(E + V log V)**，但实际编程中较少使用，因为常数大且实现复杂。

---

## 🧠 七、深入思考与常见问题

### 7.1 为什么 Dijkstra 不能处理负权边？

**答案**：证明中我们依赖了“所有边权非负”来保证已经取出的顶点距离不再被更短的路径更新。如果有负权边，可能出现这样的情况：某个顶点 uu 被取出后，通过一个尚未取出的顶点 xx 的负权边，可以形成一条更短的路径到达 uu，从而破坏归纳假设。例如：

```text

A → B (1)
A → C (4)
C → B (-3)
```
Dijkstra 过程：

- 取出 A：更新 B=1, C=4。
    
- 取出 B（距离 1），标记 B 已处理。
    
- 从 B 出发无出边。
    
- 取出 C（距离 4），松弛 C→B：4+(-3)=1，等于当前 B 的距离，不更新。  
    最终 B 距离为 1，正确。但如果改成：  
    A → B (2)  
    A → C (1)  
    C → B (-2)
    
- 取出 A：更新 B=2, C=1。
    
- 取出 C：更新 B=1+(-2)=-1，B 距离变为 -1，此时 B 仍在队列中（还没取出），所以会更新成功。
    
- 取出 B：正确。  
    但如果有负权环，则可能无限下降。所以 Dijkstra 在负权边上不一定错误，但无法保证正确。因此规定只用于非负权图。
    

### 7.2 如果有多条最短路径，Dijkstra 会找到哪一条？

**答案**：取决于边松弛的顺序。如果有多条等长路径，算法会选择最先发现的那条（即最早通过某个松弛更新 `edgeTo` 的路径）。如果需要特定的路径（如字典序最小），可以在松弛时加入额外的比较规则。

### 7.3 如何判断一个顶点是否已经“处理过”？

在标准实现中，顶点一旦从优先队列中取出，就被认为是“已处理”。但在懒删除实现中，我们需要检查取出的条目是否过期。过期是指该条目的距离不等于当前的 `distTo`。如果相等，则这个顶点是第一次被取出，即正式处理。

### 7.4 为什么有时在松弛时，需要检查 `pq.contains(w)`？

在初始化时如果只放入了源点，那么当第一次发现一个顶点时，它不在队列中，需要插入。如果已经插入过，则需要更新其优先级。懒删除实现中，我们统一插入新节点，不检查是否存在，这样更简单。

### 7.5 能否用 Dijkstra 求最长路径？

**答案**：不能直接用于正权图的最长路径，因为最长路径可能包含环（正权环会导致无限长）。在非负权图中，最长简单路径是 NP 难问题。但如果将所有权重取负，则变成负权图，Dijkstra 又不能用。所以需要其他算法（如 Bellman-Ford 可以检测负环，但也不能直接求最长路径）。

### 7.6 如何证明最短路径树包含 V-1 条边？

**证明**：每个非源顶点在树中恰好有一个父节点（来自其最短路径的前一个顶点），因此有 V-1 条边。如果某些顶点不可达，则它们不在树中，树只包含可达顶点。

---

## 📊 八、与其他算法的对比

|算法|适用场景|时间复杂度|能否处理负权|能否检测负环|特点|
|---|---|---|---|---|---|
|BFS|无权图|O(V+E)|不适用|否|按边数最短|
|Dijkstra|非负权图|O(E log V)|否|否|贪心，快|
|Bellman-Ford|一般图（可负权）|O(VE)|是|是|慢，但通用|
|Floyd-Warshall|所有点对最短路径|O(V³)|是（无负环）|可检测|稠密图适用，动态规划|

---

## 📚 九、知识点总结（超详细）

|知识点|详细内容|重点/易错点|
|---|---|---|
|**最短路径树**|从源点到所有可达顶点的最短路径构成的树，每个非源点有唯一父节点，边数 V-1。|树中不包含环，与原始图边数无关。|
|**BFS 的局限**|BFS 按边数访问，无法处理不同权重的边。|反例：A→B(5), A→C(1), C→B(1)，BFS 会选 A→B 但实际最短是 A→C→B。|
|**虚拟节点法**|将长边拆成多个单位边，使 BFS 按实际距离工作。|空间爆炸，不可行。|
|**最佳优先搜索**|按当前已知距离顺序访问顶点，但不更新已标记顶点。|可能错过更短路径（如果更新发生在取出之后）。|
|**Dijkstra 核心**|最佳优先顺序 + 松弛操作（允许更新并调整优先级）。|必须用优先队列，且支持 decreaseKey 或懒删除。|
|**松弛操作**|如果 `distTo[v] + w < distTo[w]`，则更新 `distTo[w]` 和 `edgeTo[w]`，并调整优先队列。|更新后 w 的距离可能变小，需要重新排序。|
|**正确性证明**|归纳法：已取出顶点的距离已是最优，后续路径不会更短。|依赖非负权。|
|**优先队列实现**|懒删除：插入新节点，取出时检查是否过期。|每个边最多导致一次插入，总操作 O(E log V)。|
|**时间复杂度**|二叉堆实现：O(E log V)；斐波那契堆：O(E + V log V)。|通常 E 主导，所以简写为 O(E log V)。|
|**负权问题**|Dijkstra 不能处理负权边，因为可能破坏归纳假设。|负权图需用 Bellman-Ford。|
|**路径重建**|从目标顶点回溯 `edgeTo` 直到源点，然后反转。|注意顺序：从目标到源点回溯得到的是逆序，需反转。|

---

## 🧪 十、思考题与详细答案

### 1. 为什么 Dijkstra 算法中，一旦一个顶点从优先队列中取出，它的距离就不会再被更新？

**答案**：因为所有边权非负，任何其他未取出顶点的距离都 ≥ 当前取出的距离，通过它们到达该顶点的路径长度至少是那个顶点的距离加上正权边，一定 ≥ 当前距离。所以不可能有更短的路径。

### 2. 如果图中存在权重为 0 的边，Dijkstra 算法还能正常工作吗？

**答案**：能。0 权边不破坏证明，因为 “≥” 仍然成立。但要注意，如果有 0 权环，则可能形成多个等长路径，算法仍然正确（只是可能产生多个等长路径）。

### 3. 请举例说明，如果图中有负权边，Dijkstra 算法可能出错。

**答案**：

```text

    A ---2---> B
    |           ^
    1           |
    +---> C -- -3-+
```
- 初始：dist[A]=0, dist[B]=∞, dist[C]=∞
    
- 取出 A：更新 B=2, C=1
    
- 队列：[(C,1), (B,2)]
    
- 取出 C：更新 B=1+(-3) = -2，此时 B 还在队列中，所以可以更新 B 为 -2（队列中 B 的优先级变为 -2）
    
- 取出 B：结束。正确。  
    但如果我们把负权边放在后面，比如：
    

```text

    A ---1---> B ---2---> C
    ↑                     |
    +---------------------+
            -3
```
即 A→B(1), B→C(2), C→A(-3)。这是一个负权环。Dijkstra 从 A 出发：

- 取出 A：更新 B=1
    
- 取出 B：更新 C=3
    
- 取出 C：更新 A=3+(-3)=0，但 A 已被取出过，不会更新。最终 dist[A]=0（正确），dist[B]=1（正确？实际可以通过环 A→B→C→A→B 得到更短的 B？从 A 到 B 最短路径是 1，因为有环虽然负，但需要绕回 A，而 A 到 A 距离 0，所以 A→B 仍然是 1。所以这个环不影响 A 到 B 的最短距离，但会影响 A 到 C？A→B→C 是 3，而通过环 A→B→C→A→B→C 是 3+(-3)+1+2=3？相等。所以可能不影响。要构造一个真正出错的例子，需要让某个顶点在取出后被更短的路径更新，且这个路径经过另一个未取出的顶点，且该顶点距离小于当前取出的顶点？但因为有负权，可能未取出的顶点距离小于当前取出的顶点？比如：
    

```text

    A ---5---> B
    |           ^
    2           |
    +---> C -- -1-+
    |           ^
    3           |
    +---> D -- -2-+
```
初始：A=0  
取出 A：更新 B=5, C=2, D=3  
队列：[(C,2), (D,3), (B,5)]  
取出 C：更新 B=2+(-1)=1，更新 B 为 1（B 还在队列中）  
队列：[(D,3), (B,1)]  
取出 B：结束。仍然正确。看来要构造一个在取出后才被更新的例子，需要满足：某个顶点 u 被取出时，还有另一个顶点 v 的距离小于 u 的距离？但 u 是当前最小，所以 v 的距离 ≥ u，所以 v 不会在 u 之前被取出。因此，只要在 u 取出后，通过某个尚未取出的顶点 v 到达 u 的路径能更短，就需要 v 的距离 + 负权边 < u 的距离。但 v 的距离 ≥ u，所以 v 的距离 + 负权边 ≥ u + 负权边。如果负权边足够大（绝对值大），可能使和小于 u。但 v 的距离可能等于 u，那么 v 的距离 + 负权边 = u + 负权边，如果负权边 < 0，则和 < u。所以有可能。例如：  
u 当前距离 5，v 当前距离 5（相等），但 v 有一条负权边 -1 到 u，则通过 v 到 u 的距离 = 5-1=4 < 5。但 v 和 u 距离相等，它们谁先被取出？取决于队列实现。如果 u 先被取出，那么之后从 v 出发松弛时，会更新 u，但 u 已经被取出，所以无法更新。这就会出错。具体图：

```text

    A ---5---> B
    |           ^
    5           |
    +---> C -- -1-+
```
A→B(5), A→C(5), C→B(-1)  
Dijkstra：

- 取出 A：更新 B=5, C=5
    
- 队列：[(B,5), (C,5)]（假设按某种顺序，B 先被取出）
    
- 取出 B：B 被标记
    
- 取出 C：松弛 C→B：5-1=4，但 B 已被取出，所以不会更新 B。最终 B 的距离是 5，但实际最短是 4。错误！  
    因此，这个例子展示了 Dijkstra 在负权边上的失败。
    

### 4. 在 Dijkstra 算法中，如果使用二叉堆但不支持 decreaseKey，而是采用插入新节点的方式，为什么总复杂度仍是 O(E log V)？

**答案**：每个边最多导致一次新的插入（因为每次松弛可能产生一个更短距离，从而插入一个新节点）。每个顶点可能被插入多次，但总插入次数 ≤ E。每次插入和取出都是 O(log N)，其中 N 是队列中的节点数，最多 E，所以 log E = O(log V)。因此总操作次数 O((V+E) log V) ≈ O(E log V)。

### 5. 如何用 Dijkstra 算法求解从源点到所有顶点的最短路径，并同时得到路径？

**答案**：算法结束后，`edgeTo` 数组记录了每个顶点的前驱。要得到从 s 到 v 的路径，可以从 v 开始，不断 `v = edgeTo[v]` 直到 s，然后将这些顶点逆序输出。代码见前。

### 6. 如果图是稀疏的（E ≈ V），Dijkstra 的时间复杂度大约是多少？

**答案**：O(V log V)。因为 E ≈ V，所以 O(E log V) ≈ O(V log V)。

### 7. 如果图是稠密的（E ≈ V²），Dijkstra 的时间复杂度是多少？

**答案**：O(V² log V)。这比 Floyd-Warshall 的 O(V³) 好，但比用斐波那契堆的 O(V²) 差。实际上，对于稠密图，可以用朴素实现（不用优先队列，每次扫描所有未处理顶点找最小），时间复杂度 O(V²)，可能更快。

### 8. 为什么 Dijkstra 算法被称为“贪心算法”？

**答案**：因为它在每一步都选择当前看起来最优的顶点（距离最小的未处理顶点），并相信这个选择不会影响后续的全局最优解。这种局部最优导致全局最优的性质在非负权图中成立。

### 9. 如果图中存在多条最短路径，Dijkstra 算法会记录哪一条？

**答案**：取决于边松弛的顺序。当多条路径长度相等时，第一个到达该顶点的松弛操作会设置 `edgeTo`，后续等长路径不会更新（因为 `distTo[v] + w == distTo[w]` 时，通常不更新，除非特别要求）。所以算法记录的是**第一次发现**的路径。

### 10. 能否用 Dijkstra 算法求最长路径（所有边权非负）？

**答案**：不能。因为最长路径可能包含环（正权环会使路径无限长），而 Dijkstra 要求无环。即使限制为简单路径，最长路径问题是 NP 难的，不能用这种贪心解决。
# 📊 排序 II：归并排序与插入排序（Mergesort & Insertion Sort）—— 从合并操作到递归分治，全面掌握两种重要排序

> 本文是 CS61B Spring 2024 Lecture 30 的超详细笔记，内容涵盖：选择排序回顾、合并操作详解、归并排序的完整推导与实现、时间复杂度分析、插入排序的原地实现与性能分析、各种排序算法的对比总结，以及快速排序的历史趣闻。通过详尽的解释、完整的代码示例、步骤拆解和思考题，帮助你彻底掌握这些排序算法。

---

## 🔁 一、选择排序（Selection Sort）回顾

### 1.1 算法思想

选择排序是最直观的排序算法之一：

1. 在未排序部分中找到最小元素。
    
2. 将其与未排序部分的第一个元素交换。
    
3. 将该元素标记为“已固定”（即不再移动）。
    
4. 对剩余未排序元素重复上述过程。
    

### 1.2 代码实现

```java

public static void selectionSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        int minIdx = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        swap(arr, i, minIdx);
    }
}
private static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```
### 1.3 复杂度分析

- **比较次数**：第一次扫描 N 个元素，第二次 N-1，……，总和为 N + (N-1) + ... + 2 = Θ(N²)。
    
- **交换次数**：最多 N 次（每次找对位置才交换），但比较主导了复杂度。
    
- **空间复杂度**：O(1)（原地排序）。
    

**特点**：无论输入是否有序，选择排序总是进行 Θ(N²) 次比较，因此效率低下。

---

## 🔗 二、合并操作（Merge）

### 2.1 定义

**合并**是指将两个**已经有序**的数组（或列表）合并成一个更大的有序数组的过程。这是归并排序的核心子程序。

### 2.2 算法过程

假设有两个已排序数组 A 和 B，我们要将它们合并到数组 C 中：

1. 初始化三个指针 i, j, k 分别指向 A、B、C 的起始位置。
    
2. 比较 A[i] 和 B[j]，将较小的元素复制到 C[k]，并移动相应的指针。
    
3. 重复直到某一个数组的元素全部被复制完。
    
4. 将另一个数组中剩余的元素直接复制到 C 的末尾。
    

### 2.3 演示示例

```text

A: [2, 3, 6, 10, 11]
B: [4, 5, 7, 8]
合并过程：
比较 2 和 4 → 取 2 → C: [2]
比较 3 和 4 → 取 3 → C: [2, 3]
比较 6 和 4 → 取 4 → C: [2, 3, 4]
比较 6 和 5 → 取 5 → C: [2, 3, 4, 5]
比较 6 和 7 → 取 6 → C: [2, 3, 4, 5, 6]
比较 10 和 7 → 取 7 → C: [2, 3, 4, 5, 6, 7]
比较 10 和 8 → 取 8 → C: [2, 3, 4, 5, 6, 7, 8]
A 剩余 [10, 11] → 全部复制 → C: [2, 3, 4, 5, 6, 7, 8, 10, 11]
```
### 2.4 时间复杂度

- 每比较一次就复制一个元素，总共需要复制 N 个元素（N 为两个数组的总长度）。
    
- 每次比较和复制都是 O(1) 操作。
    
- 因此合并操作的时间复杂度为 **Θ(N)**。
    

**关键**：合并操作利用了输入数组已排序的特性，只需线性扫描一次。

### 2.5 代码实现

```java

public static int[] merge(int[] left, int[] right) {
    int[] result = new int[left.length + right.length];
    int i = 0, j = 0, k = 0;
    while (i < left.length && j < right.length) {
        if (left[i] <= right[j]) {
            result[k++] = left[i++];
        } else {
            result[k++] = right[j++];
        }
    }
    while (i < left.length) result[k++] = left[i++];
    while (j < right.length) result[k++] = right[j++];
    return result;
}
```
---

## 🌲 三、从合并到归并排序

### 3.1 双层合并的启发

如果我们对一个数组先分成两半，分别用选择排序（或其他慢速排序）排序，然后再合并，能提高效率吗？

**计算**（以 N=64 为例）：

- 直接选择排序：约 64² = 4096 单位时间（AU）。
    
- 分成两个 32 的数组：
    
    - 选择排序两半：2 × 32² = 2 × 1024 = 2048 AU
        
    - 合并：64 AU
        
    - 总时间 = 2112 AU，比 4096 快了一半。
        

**再分**：将 32 再分成 16：

- 四个 16 的选择排序：4 × 256 = 1024 AU
    
- 合并两次 16→32：2 × 32 = 64 AU
    
- 合并一次 32→64：64 AU
    
- 总时间 = 1152 AU
    

**观察**：随着分割层数增加，时间逐渐减少。如果我们一直分到大小为 1（天然有序），然后逐层合并，会怎么样？

### 3.2 归并排序的递归思想

**归并排序（Mergesort）** 正是基于这一思想：

1. 将数组分成两半。
    
2. 递归地对左半部分和右半部分进行归并排序。
    
3. 将两个有序的子数组合并成一个有序数组。
    

**基本情况**：当数组大小为 1 时，自然有序，直接返回。

### 3.3 递归实现

```java

public static void mergesort(int[] arr) {
    int[] aux = new int[arr.length]; // 辅助数组
    sort(arr, aux, 0, arr.length - 1);
}
private static void sort(int[] arr, int[] aux, int lo, int hi) {
    if (lo >= hi) return;
    int mid = lo + (hi - lo) / 2;
    sort(arr, aux, lo, mid);
    sort(arr, aux, mid + 1, hi);
    merge(arr, aux, lo, mid, hi);
}
private static void merge(int[] arr, int[] aux, int lo, int mid, int hi) {
    // 将 arr[lo..hi] 复制到 aux[lo..hi]
    for (int k = lo; k <= hi; k++) aux[k] = arr[k];
    int i = lo, j = mid + 1;
    for (int k = lo; k <= hi; k++) {
        if (i > mid) arr[k] = aux[j++];
        else if (j > hi) arr[k] = aux[i++];
        else if (aux[i] <= aux[j]) arr[k] = aux[i++];
        else arr[k] = aux[j++];
    }
}
```
### 3.4 时间复杂度分析

- **层级数**：每次将数组对半分割，直到大小为 1，需要的层数为 log₂N。
    
- **每层工作量**：每一层总共需要合并 N 个元素（因为每个元素恰好参与一次该层的合并）。例如：
    
    - 顶层：合并两个大小为 N/2 的数组 → 处理 N 个元素。
        
    - 第二层：合并四个大小为 N/4 的数组 → 每个合并处理 N/2，总处理量也是 N。
        
    - 以此类推，每一层总处理量都是 N。
        
- **总时间**：层数 × 每层工作量 = N log₂N。
    

因此归并排序的时间复杂度为 **Θ(N log N)**，无论最好、最坏、平均情况都是如此。

### 3.5 空间复杂度

- 需要辅助数组 `aux` 大小与原始数组相同，因此空间复杂度为 **Θ(N)**。
    
- 也可以实现原地归并排序，但算法复杂且常数因子大，实际很少使用。
    

### 3.6 性能特点

- **稳定**：归并排序是稳定的（相同元素的相对顺序不变）。
    
- **可并行**：左右两半可以分别交给不同处理器排序。
    
- **实际速度**：在实践中，归并排序通常比堆排序快（但比快速排序稍慢，取决于实现）。
    

---

## 📥 四、插入排序（Insertion Sort）

### 4.1 基本思想

插入排序的工作方式类似于整理扑克牌：每次将一张牌插入到已经有序的牌中的正确位置。

**原地实现**：

1. 从第二个元素开始，将其视为“旅行者”。
    
2. 将这个元素向左移动（通过交换），直到它前面的元素都小于等于它。
    
3. 重复直到所有元素处理完毕。
    

### 4.2 代码实现

```java

public static void insertionSort(int[] arr) {
    int n = arr.length;
    for (int i = 1; i < n; i++) {
        // 将 arr[i] 插入到已排序的 arr[0..i-1] 中
        for (int j = i; j > 0 && arr[j] < arr[j-1]; j--) {
            swap(arr, j, j-1);
        }
    }
}
```
**关键点**：内层循环在发现 `arr[j] >= arr[j-1]` 时立即停止，因为左边已经有序。

### 4.3 不变性（Invariant）

当处理到第 i 个元素时，`arr[0..i-1]` 已经是有序的。在元素移动过程中可能暂时破坏，但移动结束后重新恢复。

### 4.4 时间复杂度分析

- **最好情况**：数组已经有序。每个元素只需比较一次（与左边元素比较），发现无需交换，内层循环立即退出。总共进行 N-1 次比较，0 次交换 → **Θ(N)**。
    
- **最坏情况**：数组完全逆序。第 i 个元素需要向左移动 i 次，总移动次数为 1+2+...+(N-1) = N(N-1)/2，即 Θ(N²)。
    
- **平均情况**：也是 Θ(N²)。
    

### 4.5 逆序对与时间复杂度

插入排序的交换次数恰好等于数组的**逆序对数**。因此时间复杂度可表示为 **Θ(N + K)**，其中 K 是逆序对数。

**定义**：逆序对是满足 i < j 且 arr[i] > arr[j] 的数对。完全有序时 K=0，完全逆序时 K=N(N-1)/2。

### 4.6 插入排序的适用场景

#### 4.6.1 几乎有序的数组

如果数组几乎有序（K 很小，例如 K ≤ cN），插入排序接近线性时间。例如，仅有一个元素错位的百万长度数组，插入排序只需大约 2N 次操作。

#### 4.6.2 小规模数组

实验表明，当 N < 15 左右时，插入排序的实际运行速度甚至快于归并排序和快速排序。因为递归算法的函数调用开销在小规模上占主导。

**实际应用**：Java 的 `Arrays.sort()` 对小型数组（长度小于 47）使用插入排序；归并排序的实现中，当子数组长度小于某个阈值（如 15）时，也会切换到插入排序。

### 4.7 插入排序 vs 选择排序

|算法|最好情况|最坏情况|空间|稳定性|适用场景|
|---|---|---|---|---|---|
|选择排序|Θ(N²)|Θ(N²)|O(1)|不稳定|教学演示，实际很少用|
|插入排序|Θ(N)|Θ(N²)|O(1)|稳定|小规模或几乎有序的数据|

---

## 📊 五、排序算法总结对比

|算法|最好情况时间复杂度|最坏情况时间复杂度|空间复杂度|稳定性|特点|
|---|---|---|---|---|---|
|选择排序|Θ(N²)|Θ(N²)|O(1)|不稳定|简单但慢|
|堆排序|Θ(N)*|Θ(N log N)|O(1)|不稳定|原地，但缓存性能差|
|归并排序|Θ(N log N)|Θ(N log N)|Θ(N)|稳定|快速，稳定，需额外空间|
|插入排序|Θ(N)|Θ(N²)|O(1)|稳定|适合小规模或几乎有序的数据|

*注：堆排序最好情况（所有元素相等）可达到 Θ(N)，但通常视为 Θ(N log N)。

**堆排序的缓存性能**：由于堆排序的访问模式不连续（跳来跳去），CPU 缓存命中率低，实际速度往往慢于归并排序和快速排序。

---

## 🚀 六、快速排序预告

### 6.1 历史背景

1960 年，Tony Hoare 在从事俄英机器翻译项目时，遇到了一个性能问题：词典存储在磁带上，无法随机访问，每次查询都需要顺序扫描。为了高效翻译句子，他需要先对句子中的单词排序，然后与词典进行一次合并扫描。当时他还是个新手程序员，却发明了**快速排序（Quicksort）**，成为计算机科学史上最著名的算法之一。

### 6.2 快速排序的核心思想

快速排序采用分治策略，但与归并排序不同：

1. 选择一个“基准”（pivot）元素。
    
2. 将数组划分为两部分：左边所有元素 ≤ 基准，右边所有元素 ≥ 基准。
    
3. 递归地对左右两部分进行快速排序。
    

**特点**：

- 原地排序（不需要额外数组，但递归需要栈空间）。
    
- 平均时间复杂度 Θ(N log N)，最坏情况 Θ(N²)（但通过随机化可避免）。
    
- 实际应用中通常比归并排序更快。
    

下一讲将详细讨论快速排序。

---

## 🧠 七、思考题与答案

### 1. 为什么归并排序总是 Θ(N log N)，而插入排序有时能更快？

**答案**：归并排序总是将数组对半分割并合并，无论输入如何，都要进行 log N 层、每层 N 次操作，因此总是 Θ(N log N)。插入排序则利用输入的部分有序性，当逆序对很少时，只需线性时间。

### 2. 对于长度为 100 万的数组，如果只有一个元素被随机修改，用哪种排序最快？

**答案**：插入排序。因为此时逆序对数最多为 999,999（约 N），插入排序运行时间为 Θ(N + K) ≈ Θ(2N)，即线性时间。而归并排序和堆排序都需要 Θ(N log N) 时间。

### 3. 为什么归并排序需要额外空间？能否实现原地归并？

**答案**：归并操作需要将两个有序子数组合并，如果直接在原数组上合并，会覆盖未处理的元素。虽然存在原地归并算法，但实现复杂且常数因子很大，实际很少使用。

### 4. 插入排序的代码中，内层循环的条件 `j > 0 && arr[j] < arr[j-1]` 能否改成 `j > 0 && arr[j] <= arr[j-1]`？

**答案**：可以，但这样会使得排序不稳定（因为相等时也会交换）。如果稳定性不重要，两种写法均可；否则应保持 `<` 以维持稳定。

### 5. 什么是逆序对？如何计算一个数组的逆序对数？

**答案**：逆序对是满足 i < j 且 arr[i] > arr[j] 的数对。可以用双重循环 O(N²) 计算，也可以用归并排序在排序过程中统计，达到 O(N log N)。

### 6. 为什么堆排序的缓存性能较差？

**答案**：堆排序在访问数组时经常在远处跳跃（例如从堆顶跳到堆底），无法利用 CPU 缓存的空间局部性。而归并排序和快速排序更多是顺序访问，缓存友好。

### 7. 归并排序的递归深度是多少？会导致栈溢出吗？

**答案**：递归深度为 log₂N，对于 N=10⁹，深度约 30，远小于 Java 默认栈深度，不会溢出。

### 8. 插入排序在什么情况下退化为 Θ(N²)？

**答案**：当数组完全逆序时，每个元素都需要移动到最左边，总移动次数为 N(N-1)/2。

### 9. 如何将插入排序与归并排序结合？

**答案**：在归并排序的递归中，当子数组长度小于某个阈值（如 15）时，改用插入排序。这样可以减少递归调用开销，提高小规模时的效率。Java 的 `Arrays.sort()` 对对象数组使用的就是这种优化后的归并排序。

### 10. 选择排序和插入排序都是 O(N²)，为什么实际中插入排序更受欢迎？

**答案**：插入排序在最好情况下能到 O(N)，且对几乎有序的数据非常快；而选择排序总是 O(N²)。此外插入排序是稳定的，选择排序不稳定。

---

## 📌 八、知识点总结（彩色标记）

|知识点|核心内容|<span style="color:red">重点/易错点</span>|
|---|---|---|
|合并操作|将两个有序数组合并成一个，每次取较小元素|<span style="color:red">必须输入有序；时间复杂度 Θ(N)</span>|
|归并排序|分治：分割 → 递归排序 → 合并|<span style="color:red">总是 Θ(N log N)；空间 Θ(N)；稳定</span>|
|归并排序实现|需要辅助数组，递归边界为 lo >= hi|<span style="color:red">合并时要正确复制到辅助数组；指针移动要小心</span>|
|插入排序|将当前元素插入已排序部分（通过向左交换）|<span style="color:red">最好 Θ(N)，最坏 Θ(N²)；稳定；适合小规模或几乎有序</span>|
|插入排序不变性|处理完 i 后，arr[0..i] 有序|<span style="color:red">移动过程中可能暂时破坏，但最终恢复</span>|
|逆序对|衡量数组无序程度的指标|<span style="color:red">插入排序交换次数 = 逆序对数</span>|
|排序算法对比|选择、堆、归并、插入的时间、空间、稳定性对比|<span style="color:red">堆排序缓存差；归并最快但需额外空间；插入适合特殊情况</span>|
|快速排序预告|Tony Hoare 1960 年发明，用于解决机器翻译问题|<span style="color:red">核心：划分 + 递归；平均 Θ(N log N)，最坏 Θ(N²)</span>|

## 一、测试哲学

### 1. 测试方式：程序员如何知道代码有效？

在传统编程课程（如 CS61A、CS88）中，学生通常依赖教师提供的**自动评分器（autograder）** 来验证代码正确性。这些系统会提供明确的通过/失败反馈，指出代码中的问题。

**现实挑战：**  
在实际工作和研究中，程序员必须**自行编写测试**来验证代码，因为不存在现成的自动评分系统。测试能力是区分初级和高级程序员的重要标志。

---

### 2. 测试哲学的核心观点

**<span style="color: #e74c3c;">关键理念</span>**：

- 虽然无法 100% 确保代码完全正确（除极少数可通过数学证明的情况外）
    
- 但通过**精心设计的测试**可以提供强有力的正确性证据
    
- 测试的目标是**建立对代码质量的信心**，而非追求绝对完美
    

**能力培养重点：**

- 摆脱对自动评分器的依赖
    
- 掌握自主编写测试的方法论
    
- 建立系统化的代码验证思维
    

---

### 3. 排序任务：测试方法的教学示例

**教学案例**：使用字符串数组排序作为测试方法的教学示例


```java

// 输入示例
String[] input = {"he", "is", "the", "agoyatis", "of", "mr.", "conchis"};

// 预期输出
String[] expected = {"agoyatis", "conchis", "he", "is", "mr.", "of", "the"};
```
**教学策略：**

- 教师预先编写包含 bug 的排序代码
    
- 学生通过测试发现并修复这些缺陷
    
- 强调实践中的调试过程，而非单纯语法学习
    

---

### 4. 调试示例

#### 4.1 计算方差

**方差定义**：给定一个非空整数列表，方差的计算步骤如下：

1. 计算列表的平均值（记为 μ）
    
2. 对每个元素 x，计算 (x - μ)²
    
3. 求这些平方差的平均值
    

**示例**：数组 [1, 2, 3, 4] 的方差计算

1. 平均值 μ = (1+2+3+4)/4 = 2.5
    
2. 平方差：
    
    - (1-2.5)² = 2.25
        
    - (2-2.5)² = 0.25
        
    - (3-2.5)² = 0.25
        
    - (4-2.5)² = 2.25
        
3. 方差 = (2.25+0.25+0.25+2.25)/4 = 1.25
    

**函数签名**：

```java

public static double variance(double[] nums)
```
如果数组长度为 0，返回 0。

#### 4.2 旧方式：自动评分器

**工作流程**：

```text

提交代码 → 自动评分 → 详细错误反馈
```
**局限性**：

- 仅适用于教学环境，真实开发中不可用
    
- 反馈质量高：提供精确的错误定位和修复建议
    

#### 4.3 新方式：单元测试框架

**核心理念**：先编写测试用例，再实现功能代码

**优势**：

- 避免手动编写重复的验证代码
    
- 特别适合方差计算等数学函数的验证
    

**疯狂想法**：从编写 `testSort()` 开始，再实现 `sort()`！

---

#### 4.4 即兴测试的缺点

**传统测试编写方式的问题**：

```java

// 繁琐的测试代码
String[] input = {...};
String[] expected = {...};
sort(input);
for (int i = 0; i < input.length; i++) {
    if (!input[i].equals(expected[i])) {
        System.out.println("Mismatch at index " + i + ": " + input[i] + " vs " + expected[i]);
    }
}
```
**主要问题**：

1. 每个测试都需要编写相似的结构
    
2. 错误处理代码重复率高
    
3. 开发效率低下
    
4. 容易引入人为错误
    

**实际影响**：降低开发者编写测试的积极性

---

#### 4.5 单元测试框架的优势

**核心价值**：

1. 提供标准化的断言方法
    
2. 自动生成详细错误报告
    
3. 支持多种数据类型的比较
    
4. 简化测试代码结构
    

**常用库**：JUnit、TestNG、AssertJ、Truth 等

---

## 二、单元测试

### 1. 单元测试定义

**维基百科定义**：在计算机编程中，单元测试是一种软件测试方法，通过对源代码的各个独立单元进行测试，以确定它们是否适合使用。

**单元测试框架的作用**：替我们完成繁琐的测试工作。

**常用框架演变**：

- JUnit（sp23 之前使用）
    
- AssertJ 和 Truth（sp23 至今使用）
    

---

### 2. 测试函数的编写

#### 2.1 Truth 测试库示例

```java

import static com.google.common.truth.Truth.assertThat;

public class TestSort {
    /** 测试 Sort 类的 sort 方法 */
    public static void testSort() {
        String[] input = {"cows", "dwell", "above", "clouds"};
        String[] expected = {"above", "clouds", "cows", "dwell"};
        Sort.sort(input);
        assertThat(input).isEqualTo(expected);
    }
    
    public static void main(String[] args) {
        testSort();
    }
}
```
**特点**：

- 由 Google 开发的测试库，使测试编写更简单
    
- 历史变化：不同学期可能使用不同的测试库，需要注意代码兼容性
    

---

#### 2.2 测试驱动开发（TDD）

**传统流程**：

```text

先编写功能代码 → 再编写测试验证
```
**TDD 流程**：

```text

先编写测试用例 → 再实现功能代码 → 通过测试验证代码正确性
```
**优势**：虽然看起来"倒行逆施"，但能确保代码质量

**<span style="color: #e74c3c;">TDD 核心循环：红-绿-重构</span>**

1. **红（Red）**：编写测试并观察失败
    
2. **绿（Green）**：编写最少代码使测试通过
    
3. **重构**：优化代码结构但不改变功能
    

---

#### 2.3 测试用例示例

**测试方法结构**：

```java

@Test
public void testVariance() {
    // 输入数据
    double[] input = {1, 2, 3, 4};
    
    // 预期输出
    double expected = 1.25;
    
    // 调用被测方法
    double actual = Variance.variance(input);
    
    // 断言
    assertThat(actual).isEqualTo(expected);
}
```
**断言方式**：

1. **精确匹配**：`assertThat(output).isEqualTo(1.25)`
    
2. **容差匹配**：`assertThat(output).isWithin(1e-10).of(8.06072)`（用于浮点数比较）
    

---

#### 2.4 测试运行界面

**运行方式**：

- 单箭头：运行单个测试方法
    
- 双箭头：运行类中所有测试
    

**结果反馈**：

- 绿色对勾：测试通过
    
- 红色叉号：测试失败
    

**游戏化体验**：IntelliJ 将测试过程设计成游戏形式，通过显示 X 标记和绿色对勾来激励开发者。

**目标驱动**：与无目标编码不同，人类更喜欢有明确目标可以努力实现。

---

#### 2.5 大型测试用例

**测试数据生成**：可以使用循环生成大量测试数据

**浮点数比较注意事项**：对于浮点结果，应使用容差比较而非精确相等

**示例**：测试前 1000 个整数的立方数组的方差

```java

@Test
public void testVarianceOfFirst1000Cubes() {
    double[] cubes = new double[1000];
    for (int i = 1; i <= 1000; i++) {
        cubes[i-1] = Math.pow(i, 3);
    }
    
    double result = Variance.variance(cubes);
    
    // 使用容差比较
    assertThat(result).isWithin(1e-10).of(8.06727e-16);
}
```
---

#### 2.6 考虑边界情况

**常见边界条件**：

1. 空数组输入
    
2. 所有元素相同
    
3. 包含负数的计算
    
4. 非整数输入
    
5. 极大/极小值
    

**测试设计技巧**：

- 先查阅规范确定预期行为
    
- 使用计算器验证复杂数学结果
    
- 考虑极端情况和异常输入
    

**示例边界测试**：

```java

@Test
public void testEmptyArray() {
    double[] empty = {};
    assertThat(Variance.variance(empty)).isEqualTo(0);
}

@Test
public void testSingleElement() {
    double[] single = {5};
    assertThat(Variance.variance(single)).isEqualTo(0);
}

@Test
public void testAllSame() {
    double[] same = {7, 7, 7, 7, 7};
    assertThat(Variance.variance(same)).isEqualTo(0);
}
```
---

#### 2.7 测试驱动开发的优势

**设计引导**：

- 迫使开发者先思考接口设计
    
- 提前发现潜在需求问题
    

**质量保证**：

- 建立自动化的回归测试套件
    
- 确保新增代码不会破坏现有功能
    

**开发节奏**：

- 小步快走的开发模式
    
- 每个功能都有对应的测试验证
    

**<span style="color: #e74c3c;">TDD 具体步骤</span>**：

1. 确定新功能需求
    
2. 为该功能编写单元测试
    
3. 运行测试并确认失败（RED 阶段）
    
4. 编写刚好能通过测试的代码（GREEN 阶段）
    
5. 可选地重构代码提高质量
    

---

## 三、测试输出（游戏化测试界面）

**IntelliJ 的游戏化设计**：

- 将测试和调试过程设计成游戏形式
    
- 通过显示 X 标记和绿色对勾来激励开发者
    

**目标驱动**：

- 与无目标编码不同，人类更喜欢有明确目标可以努力实现
    
- 测试失败显示为 X，通过则变为绿色对勾
    

**进度可视化**：

- 底部左侧汇总测试进度
    
- 当所有测试都通过（全部变为绿色对勾）时即"获胜"
    

**心理激励**：

- 提供具体的小目标
    
- 进度总结在左下角显示
    
- 完成所有测试就像赢得游戏
    

---

## 四、调试实践：从测试错误到全部通过

### 1. 发现测试错误

**调试策略**：

1. 从简单测试用例开始解决
    
2. 逐步消除 X 标记
    
3. 通过堆栈跟踪定位错误
    

**错误定位示例**：

- 除以零错误发生在 Variance.java 第 9 行
    
- 方差计算依赖于平均值方法，应先确保平均值方法正确
    

### 2. 调试功能的使用

**断点设置**：在出现异常的代码行设置断点

**变量检查**：

- 检查传入数组是否为空
    
- 检查 sum 和 nums.length 的值
    

**问题诊断**：

- 当数组为空时，nums.length 为 0 导致除以零异常
    

**修复方法**：

```java

public static double variance(double[] nums) {
    if (nums.length == 0) {
        return 0;  // 处理空数组情况
    }
    // 正常计算逻辑
}
```
### 3. 逐步解决所有测试问题

**类型问题**：发现整数除法导致精度丢失

**修复前**：

java

double sum = 0;
for (double num : nums) {
    sum += num;
}
double mean = sum / nums.length;  // 如果 sum 是 int，会有精度问题

**修复后**：

```java

double sum = 0.0;  // 使用 double 类型
for (double num : nums) {
    sum += num;
}
double mean = sum / nums.length;
```
**调试技巧**：

- 使用 IDE 的表达式求值功能检查中间计算结果
    
- 逐个解决测试问题，最终使所有测试变为绿色对勾
    

---

## 五、调试会话实录

### 1. 运行测试时的问题

**类型不匹配错误**：

- 函数要求返回 int 类型但实际返回了 double 类型
    
- 导致语法错误无法运行代码
    

**修复**：需要将返回类型从 int 改为 double 以匹配实际返回值的类型

### 2. 设置断点进行调试

#### 2.1 方差计算调试

**调试方法**：

- 在测试函数中设置断点
    
- 逐步执行以观察程序行为
    

**关键观察**：

- 通过调试器可以查看变量的变化过程
    
- 验证计算是否正确
    

#### 2.2 平均值函数调试

**验证方法**：

- 使用计算器手动验证平均值计算结果
    
- 对已确认正确的函数部分可以使用"Step Over"跳过详细执行
    

#### 2.3 调试心态

**重要原则**：

- 即使部分测试通过，仍需保持怀疑态度继续验证其他部分
    
- 注意剩余调试时间，合理分配调试重点
    

**调试完成**：修正所有错误后，所有测试用例通过

**经验总结**：单元测试和调试工具结合使用可以有效提高调试效率

---

## 六、调试方法论

### 1. 自动评分器驱动开发（ADD）的弊端

**最差的编程方式**（在 61B 中应避免）：

1. 编写整个程序
    
2. 提交到自动评分器
    
3. 收到许多错误
    
4. 重复直到正确：
    
    - 运行自动评分器
        
    - 添加 print 语句查找 bug
        
    - 修改代码尝试修复 bug
        

**这种工作流程的问题**：

- 速度慢
    
- 不安全
    
- 缺乏系统性
    

**注意**：print 语句本身并不邪恶，虽然它们是弱小的工具，但非常容易使用。

### 2. 最佳实践

**推荐工作流程**：测试驱动开发（TDD）

1. 先编写测试用例
    
2. 再开发代码
    
3. 通过测试验证代码正确性
    

**避免反模式**：

- 不要依赖频繁提交自动评分系统来调试代码（ADD）
    
- 虽然 print 语句简单易用，但调试器是更强大的工具
    

**调试工具选择**：

- **print 语句**：简单、快速，适合简单问题
    
- **调试器**：强大、系统，适合复杂问题
    
- **单元测试**：预防性、自动化，适合长期维护
    

---

## 七、知识小结

### 核心知识点速查表

|知识点|核心内容|考试重点/易混淆点|难度系数|
|---|---|---|---|
|**测试驱动开发(TDD)**|先写测试再写代码，通过测试验证代码正确性|测试失败→修复→验证的循环流程|★★★|
|**方差计算算法**|均值计算→差值平方→求平均|整数除法陷阱、空数组处理|★★★☆|
|**调试技巧**|断点调试、变量监视、步进执行|Traceback 分析、预期与实际值对比|★★★☆|
|**单元测试框架(Truth)**|断言语法 `assertThat(actual).isEqualTo(expected)`|浮点数精度比较需特殊处理|★★|
|**边界条件测试**|空数组、重复值、非整数输入|测试用例设计、均值计算中的整数溢出风险|★★★☆|
|**数学函数使用**|`Math.pow()` 幂运算的正确参数顺序|基础值在前，指数在后|★★|
|**测试覆盖率**|通过多维度测试用例验证代码健壮性|极端值测试常被忽略|★★★☆|

---

## 八、测试最佳实践总结

### 1. 测试编写原则

**AAA 模式**（Arrange-Act-Assert）：

1. **Arrange**：设置测试数据和环境
    
2. **Act**：执行被测试的操作
    
3. **Assert**：验证结果是否符合预期
    

**示例**：

```java

@Test
public void testVariance() {
    // Arrange
    double[] input = {1, 2, 3, 4};
    double expected = 1.25;
    
    // Act
    double actual = Variance.variance(input);
    
    // Assert
    assertThat(actual).isEqualTo(expected);
}
```
### 2. 测试命名规范

**清晰描述测试场景**：

- `testEmptyArrayReturnsZero`
    
- `testVarianceOfSingleElementIsZero`
    
- `testVarianceWithNegativeNumbers`
    

### 3. 浮点数比较策略

**永远不要使用 `==` 比较浮点数**：

```java

// 错误做法
assertThat(actual).isEqualTo(expected);

// 正确做法（使用容差）
assertThat(actual).isWithin(tolerance).of(expected);
```
### 4. 测试独立性

**每个测试应该是独立的**：

- 测试之间不应该有依赖关系
    
- 测试可以以任何顺序运行
    
- 一个测试的失败不应该影响其他测试
    

### 5. 测试维护

**保持测试代码的整洁**：

- 测试代码和生产代码同样重要
    
- 定期重构测试代码
    
- 删除过时或无用的测试
    

---

## 九、思考与练习

### 思考题

1. 为什么 TDD 要求先编写测试？这与直觉相反，有什么好处？
    
2. 如果测试全部通过，是否意味着代码 100% 正确？为什么？
    
3. 如何处理浮点数计算中的舍入误差？
    
4. 什么时候应该使用单元测试？什么时候应该使用集成测试？
    

### 扩展练习

1. 为方差函数添加更多边界测试：
    
    - 包含极大值和极小值的数组
        
    - 包含 NaN 或 Infinity 的数组
        
    - 随机生成的测试数据
        
2. 实现一个完整的测试套件：
    
    - 为排序函数编写测试
        
    - 为复数类（上一讲内容）编写测试
        
    - 为自定义数据结构编写测试
        
3. 尝试不同的测试框架：
    
    - 使用 JUnit 编写相同的测试
        
    - 比较不同框架的语法和特性
        
4. 实践 TDD 流程：
    
    - 选择一个小功能（如计算标准差）
        
    - 先编写测试
        
    - 再实现功能
        
    - 观察红-绿-重构循环
        

---

通过本讲的学习，你应该能够：

1. 理解测试的重要性和哲学基础
    
2. 掌握单元测试的基本概念和编写方法
    
3. 理解测试驱动开发（TDD）的原理和流程
    
4. 使用 Truth 等测试框架编写有效的测试
    
5. 识别和处理常见的边界情况
    
6. 结合调试工具高效定位和修复问题
    

**<span style="color: #3498db;">py大师：好的测试不是代码的负担，而是质量的保障。编写测试不仅是为了发现错误，更是为了建立对代码的信心，确保长期维护的可行性。</span>**
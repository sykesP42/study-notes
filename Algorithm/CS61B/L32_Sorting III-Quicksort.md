# 🚀 排序 III：快速排序（Quicksort）—— 最酷的排序算法，从发明故事到工程优化

> 本文是 CS61B Spring 2024 Lecture 32 的超详细笔记，全面讲解快速排序的发明背景、核心思想、分区操作、递归实现、时间复杂度分析（最好、最坏、平均）、与归并排序的对比，以及避免最坏情况的四种策略。通过详尽的解释、完整的代码示例、步骤拆解和思考题，帮助你彻底掌握这一经典而高效的排序算法。

---

## 📜 一、快速排序的发明故事

### 1.1 背景：1960 年的机器翻译项目

1960 年，年轻的程序员 **Tony Hoare** 正在开发一个俄英自动翻译程序。当时面临的硬件限制：

- 词典存储在长长的磁带上，无法随机访问，只能顺序扫描。
    
- 句子存储在内存数组中，需要查找每个单词在词典中的翻译。
    

**朴素方法**：对句子中的每个单词，在词典上进行二分查找。但二分查找在磁带上并非对数时间，因为磁带需要物理移动！实际效率极低。

**Hoare 的洞察**：如果先将句子中的单词排序，然后与词典进行一次合并扫描，就能大大减少磁带移动次数。

- 排序句子：需要 O(N log N) 时间（假设有高效排序算法）。
    
- 扫描词典一次：O(D) 时间（D 为词典大小）。
    
- 总时间：N log N + D，远优于 N * log D（在磁带上 log D 不成立）。
    

于是 Hoare 开始寻找一种高效的排序算法，最终发明了**快速排序（Quicksort）**，成为计算机科学史上最著名的算法之一。

### 1.2 为什么叫“最酷的排序”？

快速排序以其简洁、高效和独特的“分治”思想著称：

- 不同于选择排序、插入排序的逐个放置，也不同于归并排序的先递归后合并，快速排序通过**分区（partition）** 操作，将数组分成两部分，然后递归处理。
    
- 在实际应用中，它通常比归并排序和堆排序更快，尽管理论上最坏情况可达 O(N²)，但通过随机化等技巧，这种情况几乎不会发生。
    

---

## 🔄 二、排序算法回顾

在深入快速排序之前，我们先回顾一下已学过的排序算法（来自上一讲）：

|算法|最好情况时间复杂度|最坏情况时间复杂度|空间复杂度|特点|
|---|---|---|---|---|
|选择排序|Θ(N²)|Θ(N²)|O(1)|每次找最小元素交换到前面|
|堆排序|Θ(N)*|Θ(N log N)|O(1)|利用最大堆，缓存性能差|
|归并排序|Θ(N log N)|Θ(N log N)|Θ(N)|稳定，但需额外空间|
|插入排序|Θ(N)|Θ(N²)|O(1)|适合小规模或几乎有序的数据|

*堆排序在元素全相等时可达到 Θ(N)，但通常视为 Θ(N log N)。

快速排序将为我们带来新的分治方式。

---

## 🧩 三、快速排序的核心思想

### 3.1 分区（Partition）

**分区**是快速排序的核心操作：选择一个元素作为**基准（pivot）**，将数组重新排列，使得**所有小于基准的元素都在基准左边，所有大于基准的元素都在基准右边**。等于基准的元素可以在任意一侧（具体实现决定）。

**示例**：对数组 `[5, 3, 2, 1, 7, 8, 4, 6]` 以第一个元素 5 为基准进行分区，一种可能结果是：

```text

[3, 2, 1, 4, 5, 8, 7, 6]
```
- 左边 `[3, 2, 1, 4]` 都 ≤ 5
    
- 右边 `[8, 7, 6]` 都 ≥ 5
    
- 基准 5 已经处于最终正确位置（排序后它应该在第 5 位）。
    

**注意**：分区后数组并未完全有序，但基准已经归位。

### 3.2 递归分治

分区之后，我们对左右两个子数组**递归地执行快速排序**：

- 对左边子数组 `[3, 2, 1, 4]` 进行快速排序。
    
- 对右边子数组 `[8, 7, 6]` 进行快速排序。
    

由于每次分区至少将一个元素（基准）放到最终位置，递归最终会终止。

### 3.3 与归并排序的对比

- **归并排序**：先递归分割，再合并（合并操作在递归返回时进行）。
    
- **快速排序**：先分区（在递归调用前进行），然后递归处理左右子数组。
    

两者都是分治法，但操作顺序不同。

---

## 🔧 四、分区算法的实现

### 4.1 简单分区（三次扫描法）

最容易理解的分区方法是使用三个临时数组：

1. 扫描原数组，将所有小于基准的元素放入 `left` 列表。
    
2. 将所有等于基准的元素放入 `mid` 列表。
    
3. 将所有大于基准的元素放入 `right` 列表。
    
4. 将 `left`, `mid`, `right` 按顺序写回原数组。
    

**Java 实现**：

```java

public static void simplePartition(int[] arr, int pivotIndex) {
    int pivot = arr[pivotIndex];
    List<Integer> left = new ArrayList<>();
    List<Integer> mid = new ArrayList<>();
    List<Integer> right = new ArrayList<>();
    for (int x : arr) {
        if (x < pivot) left.add(x);
        else if (x == pivot) mid.add(x);
        else right.add(x);
    }
    int i = 0;
    for (int x : left) arr[i++] = x;
    for (int x : mid) arr[i++] = x;
    for (int x : right) arr[i++] = x;
}
```
- 时间复杂度：O(N)
    
- 空间复杂度：O(N)（需要额外空间）
    

### 4.2 原地分区（双指针法）

更高效的是**原地分区**，只需 O(1) 额外空间。经典算法如下（以第一个元素为基准）：

```java

public static int partition(int[] arr, int lo, int hi) {
    int pivot = arr[lo];
    int i = lo + 1; // 左指针
    int j = hi;     // 右指针
    while (i <= j) {
        while (i <= j && arr[i] <= pivot) i++;
        while (i <= j && arr[j] > pivot) j--;
        if (i < j) swap(arr, i, j);
    }
    swap(arr, lo, j); // 将基准放到正确位置
    return j;         // 返回基准的最终索引
}
```
**过程**：

- 从左边找第一个大于基准的元素，从右边找第一个小于等于基准的元素，交换它们。
    
- 重复直到指针交错。
    
- 最后将基准与 `j` 交换，此时基准左边都 ≤ 它，右边都 > 它。
    

**注意**：这种实现将等于基准的元素分散到两边，但通常不影响正确性（只要最终基准位置正确）。如果需要稳定性，则需更复杂的算法。

### 4.3 分区练习题（荷兰国旗问题）

**问题**：给定一个数组，第一个元素是白色（基准），其余元素是红色（小于）或蓝色（大于），要求重排数组使得所有红色在白色左边，所有白色聚在一起，所有蓝色在右边。时间复杂度 O(N)，空间不限。

**示例**：输入 `[W, R, B, R, B, R]` → 输出 `[R, R, R, W, W, B, B]`（相对顺序不要求）。

这个问题是分区的一种变体，可以用三指针（荷兰国旗算法）解决。

---

## 🌲 五、快速排序的完整实现

### 5.1 递归实现（以第一个元素为基准）

```java

public static void quicksort(int[] arr) {
    quicksort(arr, 0, arr.length - 1);
}
private static void quicksort(int[] arr, int lo, int hi) {
    if (lo >= hi) return;
    int pivotIndex = partition(arr, lo, hi); // 分区，返回基准位置
    quicksort(arr, lo, pivotIndex - 1);      // 排序左边
    quicksort(arr, pivotIndex + 1, hi);      // 排序右边
}
```
### 5.2 示例演示

对数组 `[32, 15, 2, 17, 19, 26, 41, 17, 17]` 进行快速排序（以第一个元素 32 为基准）：

- 分区后：`[15, 2, 17, 19, 26, 17, 17, 32, 41]`，基准 32 位于索引 7。
    
- 左子数组 `[15, 2, 17, 19, 26, 17, 17]` 递归。
    
- 右子数组 `[41]` 递归（已有序）。
    

不断递归，最终得到有序数组。

---

## ⏱️ 六、时间复杂度分析

### 6.1 最好情况

**最好情况**：每次分区都将数组均匀分成两半，即基准总是中位数。此时递归树高度为 log₂N，每层总工作量为 O(N)（每个元素参与一次分区）。总时间 **Θ(N log N)**。

**计算**：

- 第一层：处理 N 个元素。
    
- 第二层：两个子数组各 N/2，总 N。
    
- 第三层：四个子数组各 N/4，总 N。
    
- 以此类推，共 log N 层 → Θ(N log N)。
    

### 6.2 最坏情况

**最坏情况**：每次分区都极度不平衡，例如数组已经有序，且每次都选第一个元素作为基准。此时：

- 第一次分区：处理 N 个元素，基准在最左边，右边子数组大小 N-1。
    
- 第二次分区：处理 N-1 个元素，基准在最左边，右边子数组大小 N-2。
    
- ......
    
- 总工作量 = N + (N-1) + ... + 1 = N(N+1)/2 = **Θ(N²)**。
    

**示例**：对已排序数组 `[1,2,3,4,5,6]`，每次分区只减少一个元素，导致平方时间。

### 6.3 平均情况

**平均情况**：对于随机排列的数组，快速排序的时间复杂度期望为 **Θ(N log N)**。直观上，即使分区不是完美平衡，只要每次分割出一个常数比例（例如 10% 和 90%），递归深度仍为 O(log N)，每层总工作量 O(N)，因此总时间仍为 O(N log N)，只是常数因子稍大。

**数学证明**（简述）：随机选择基准，分区后两个子数组大小的期望比为 1:1 左右，可通过概率分析得到平均比较次数约为 2N ln N ≈ 1.39 N log₂ N，比归并排序的 N log₂ N 稍大，但常数因子差异不大。

**实验直方图**：对 1000 个随机元素进行 10,000 次快速排序，比较次数集中在 11,000-13,000 之间（N log₂ N ≈ 1000 * 10 = 10,000），远小于 N² = 1,000,000，说明最坏情况几乎从不发生。

---

## ⚖️ 七、快速排序 vs 归并排序

|维度|快速排序|归并排序|
|---|---|---|
|时间复杂度|平均 O(N log N)，最坏 O(N²)|最好、最坏、平均均为 O(N log N)|
|空间复杂度|O(log N)（递归栈）或 O(1)（原地）|O(N)（需要额外数组）|
|稳定性|不稳定（通常实现）|稳定|
|缓存性能|好（顺序访问）|好（但合并需额外空间）|
|实际速度|通常最快（常数因子小）|稍慢（复制开销）|

**为什么快速排序在实践中更快？**

- 归并排序需要额外的数组复制，而快速排序是原地排序（除递归栈外）。
    
- 快速排序的访问模式更符合 CPU 缓存（顺序访问），而堆排序的跳跃访问缓存性能差。
    
- 尽管最坏情况存在，但通过随机化可以有效避免。
    

---

## 🛡️ 八、如何避免最坏情况？

快速排序的最坏情况（如已排序数组或所有元素相等）在实际中确实可能出现。以下是四种主流策略：

### 8.1 随机化（Randomization）

- **随机选择基准**：每次分区时，随机选择一个元素与第一个元素交换，然后以第一个元素为基准。这样任何固定输入都不会导致确定性最坏情况。
    
- **预先洗牌（shuffle）**：在排序前将数组随机打乱。这同样可以避免已排序数组的陷阱。
    

**优点**：实现简单，概率上保证几乎不会遇到最坏情况。  
**缺点**：洗牌本身需要 O(N) 时间，但可接受。

### 8.2 更聪明的基准选择（常数时间）

- **三数取中（median-of-three）**：从数组的第一个、中间、最后一个元素中选取中位数作为基准。这可以避免完全逆序或顺序的极端情况。
    
- **随机采样**：随机选几个元素，取其中位数。
    

**优点**：提高分区质量，减少最坏情况概率。  
**缺点**：仍可能被精心构造的输入攻击（见“杀手对手”论文）。

### 8.3 线性时间选择中位数（Median of Medians）

通过线性时间选择算法（如 BFPRT）找到真正的**中位数**作为基准，保证每次分区都平衡，从而使最坏情况达到 O(N log N)。

**缺点**：常数因子很大，实际比归并排序还慢，很少使用。

### 8.4 内省（Introspection）

**内省排序（Introsort）**：监控递归深度，如果超过某个阈值（例如 2 log N），则切换到堆排序（或归并排序）。这样既保持了快速排序的平均性能，又避免了最坏情况。

C++ STL 的 `std::sort` 和 Java 的 `Arrays.sort`（对基本类型）都采用这种策略。

---

## 🧠 九、思考题与答案

### 1. 快速排序是稳定的吗？为什么？

**答案**：通常的原地分区实现是不稳定的，因为交换可能改变相等元素的相对顺序。如果需要稳定性，可以使用额外数组的分区方法，但会增加空间开销。

### 2. 对于已经有序的数组，如何改进快速排序？

**答案**：可以随机选择基准，或使用三数取中法。如果数组基本有序，插入排序反而更快，可以结合使用（如小数组用插入排序）。

### 3. 为什么快速排序的平均时间复杂度是 O(N log N)？

**答案**：直观上，每次分区将数组分成两部分，期望大小比例为常数，递归深度 O(log N)，每层总工作量 O(N)。严格证明需用概率分析，可参考算法导论。

### 4. 快速排序和二叉搜索树（BST）有什么关系？

**答案**：快速排序的比较序列与将相同元素插入 BST 的过程完全一致。第一个基准对应根，左边元素对应左子树，右边对应右子树。因此平均情况和 BST 的平均高度相同，均为 O(log N)。

### 5. 对于包含大量重复元素的数组，快速排序性能如何？

**答案**：如果所有元素相等，普通分区会导致极端不平衡（例如所有元素都在一边），退化为 O(N²)。解决方法：使用**三向分区（3-way partition）**，将数组分为小于、等于、大于三部分，这样等于基准的元素不用再参与递归。这种变体称为“三向快速排序”，对重复元素高效。

### 6. 快速排序的递归深度最多是多少？

**答案**：最坏情况下（如已排序且选第一个为基准）深度为 N，导致栈溢出风险。可通过随机化或内省避免。

### 7. 为什么实际中快速排序比归并排序快？

**答案**：主要因为：

- 快速排序是原地排序，归并需要额外空间和复制。
    
- 快速排序的访问模式更局部，缓存命中率高。
    
- 快速排序的常数因子通常小于归并排序。
    

### 8. 如何用快速排序思想解决“找出数组中第 k 大的元素”？

**答案**：可以使用**快速选择（Quickselect）** 算法：分区后，如果基准位置正好是 k，则返回；否则在左边或右边递归。平均时间复杂度 O(N)。

---

## 📌 十、知识点总结（彩色标记）

|知识点|核心内容|<span style="color:red">重点/易错点</span>|
|---|---|---|
|快速排序核心|分区 + 递归分治|<span style="color:red">分区保证基准归位；先分区后递归</span>|
|分区操作|将数组按基准分成小于和大于两部分|<span style="color:red">原地分区需双指针；等于基准的元素可任意放置</span>|
|时间复杂度|平均 O(N log N)，最坏 O(N²)|<span style="color:red">最坏情况发生在已排序或全相等数组；随机化可避免</span>|
|与 BST 的关联|比较序列与 BST 插入一致|<span style="color:red">平均深度 O(log N) 对应平均时间 O(N log N)</span>|
|避免最坏情况的策略|随机基准、三数取中、内省排序|<span style="color:red">随机化最简单有效；内省排序保证最坏 O(N log N)</span>|
|与归并排序对比|快速排序更快但最坏情况差；归并排序稳定但需额外空间|<span style="color:red">实际选择取决于场景：快速排序通用，归并排序适合链表或需要稳定性的场合</span>|

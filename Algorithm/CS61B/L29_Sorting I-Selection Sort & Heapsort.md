# 🔍 排序 I：选择排序与堆排序（Sorting I: Selection Sort & Heapsort）—— 从 Trie 到排序，深入理解基础排序算法

> 本文是 CS61B Spring 2024 Lecture 29 的超详细笔记，内容涵盖：Trie 的前缀匹配操作及应用、自动补全的优化思路、排序的基本概念（全序、逆序数）、选择排序、堆排序（基础版与原地版）的完整实现与复杂度分析、大 O 符号与最坏情况的区别、以及最大堆在排序中的选择原因。通过详尽的解释、代码示例、步骤拆解和思考题，帮助你彻底掌握这些核心知识。

---

## 🌳 一、Trie 的字符串特定操作

### 1.1 为什么需要 Trie？

在前一讲中，我们介绍了 Trie 的基本结构和实现。Trie 的主要优势不仅在于理论上的常数时间操作（与哈希表相当），更在于它能够**高效支持字符串特有的操作**，例如：

- **前缀匹配**：查找所有以给定前缀开头的键。
    
- **最长前缀**：找出给定字符串的最长前缀存在于集合中。
    

这些操作在哈希表或平衡树中难以高效实现，因为哈希表无法利用键的公共前缀，平衡树虽然有序但需要遍历大量节点。

### 1.2 前缀匹配：`keysWithPrefix`

#### 问题描述

给定一个 Trie 和一个前缀字符串 `prefix`，返回所有以 `prefix` 开头的键。

#### 算法思路

1. 沿着 Trie 从根开始，按照 `prefix` 的字符依次向下移动，找到 `prefix` 对应的节点 `node`。
    
2. 如果中途某个字符不存在，则返回空列表。
    
3. 从 `node` 开始，以深度优先方式遍历其所有子树，收集所有标记为 `isKey` 的路径，并在路径前面加上 `prefix`。
    

#### Java 实现

```java

public class TrieSet {
    private static class Node {
        boolean isKey;
        Map<Character, Node> next = new HashMap<>();
    }
    private Node root = new Node();
    // 插入、查找等方法省略...
    public List<String> keysWithPrefix(String prefix) {
        List<String> results = new ArrayList<>();
        Node node = root;
        // 1. 定位到前缀节点
        for (char c : prefix.toCharArray()) {
            node = node.next.get(c);
            if (node == null) return results; // 前缀不存在
        }
        // 2. 从该节点开始 DFS 收集所有键
        collect(node, new StringBuilder(prefix), results);
        return results;
    }
    private void collect(Node node, StringBuilder path, List<String> results) {
        if (node.isKey) results.add(path.toString());
        for (Map.Entry<Character, Node> entry : node.next.entrySet()) {
            path.append(entry.getKey());
            collect(entry.getValue(), path, results);
            path.deleteCharAt(path.length() - 1);
        }
    }
}
```
**复杂度**：

- 定位前缀节点：O(|prefix|)
    
- 收集结果：O(结果集大小 + 遍历的节点数)，但通常只需遍历结果相关的子树，不会触及整个 Trie。
    

### 1.3 最长前缀匹配：`longestPrefixOf`

#### 问题描述

给定一个字符串 `s`，找出 Trie 中存在的 `s` 的最长前缀（即从 `s` 开头开始，最长的连续子串，该子串是 Trie 中的一个完整键）。

#### 算法思路

从根开始，按字符逐个向下走，同时记录最近一次遇到的 `isKey` 节点及其对应的前缀。如果某个字符找不到对应的子节点，就停止并返回最后记录的前缀。

#### Java 实现

```java

public String longestPrefixOf(String s) {
    Node node = root;
    int length = 0; // 记录最长前缀的长度
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        node = node.next.get(c);
        if (node == null) break;
        if (node.isKey) length = i + 1; // 更新最长前缀长度
    }
    return s.substring(0, length);
}
```
**复杂度**：O(|s|)，与 Trie 中存储的键数量无关。

### 1.4 应用：自动补全（Autocomplete）

#### 问题

当用户在搜索引擎输入框中打字时，如何快速返回最相关的补全建议？

#### 基于 Trie 的朴素方法

- 构建一个从字符串到“重要性”值的映射（Trie 的每个节点可以存储一个值，或者仅在键节点存储值）。
    
- 当用户输入 `prefix` 时，调用 `keysWithPrefix(prefix)` 获取所有候选键。
    
- 根据重要性值排序，返回前 k 个（例如 Google 返回 10 个）。
    

**问题**：如果前缀很短（如只输入一个字母），候选键可能非常多（成千上万），但最终只需要前 10 个，造成大量浪费。

#### 优化：每个节点存储最佳子串信息

一种改进思路：在每个节点中，不仅存储自己的值（如果是键），还存储**以该节点为根的子树中的最佳值**（例如最大值）。这样，在搜索时，可以优先探索最佳值较高的分支，并且可以在找到足够多足够好的结果后提前终止。

**算法**（简略）：

1. 从根开始，按照前缀定位到节点 `node`。
    
2. 使用优先队列（按值从大到小）进行类似 BFS 的搜索：每次取出当前最佳节点，如果该节点是键，则加入结果；然后将其所有子节点加入优先队列。
    
3. 当结果集达到 k 个，且当前队列中最佳节点的值 ≤ 结果集中第 k 大的值时，可以停止。
    

这种方法需要每个节点存储其子树的最佳值，可以在插入时自底向上更新。

#### 更极致的优化：Radix Tree（基数树）

Trie 的每个节点只存储一个字符，可能有很多单分支路径，造成空间浪费。**基数树**（又称压缩 Trie）将连续的单分支节点合并成一个节点，存储一段字符串，从而减少节点数。这在存储长字符串时尤其有效。

---

## 📐 二、排序的基本概念

### 2.1 排序的定义

给定一组元素（通常存储在数组中），以及一个**全序关系**（total order），要求将元素重新排列，使得对于任意下标 `i < j`，有 `x_i ≤ x_j`。

**全序关系**必须满足：

- **三歧性**（trichotomy）：对于任意两个元素 `a, b`，`a < b`、`a = b`、`b < a` 有且仅有一个成立。
    
- **传递性**（transitivity）：若 `a < b` 且 `b < c`，则 `a < c`。
    

**示例**：对字符串数组 `["cows", "get", "going", "the"]` 按长度排序，长度相同的字符串被视为相等，因此排序结果不唯一。

### 2.2 逆序数（Inversions）

**逆序对**：在序列中，一对下标 `(i, j)` 满足 `i < j` 但 `x_i > x_j`。**逆序数**是序列中逆序对的总数。

- 完全有序的序列逆序数为 0。
    
- 完全逆序的序列（如降序）逆序数最大，为 `N(N-1)/2`。
    

排序的过程就是通过一系列操作（如交换、插入、删除）将逆序数减少到 0。不同的算法减少逆序数的策略不同：有的每次减少 1（如冒泡排序），有的可以一次减少多个（如快速排序）。

---

## 🔄 三、选择排序（Selection Sort）

### 3.1 算法思想

选择排序是最直观的排序算法之一：

1. 在未排序部分中找到最小元素。
    
2. 将其与未排序部分的第一个元素交换。
    
3. 重复直到全部排序。
    

### 3.2 代码实现

```java

public static void selectionSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        int minIdx = i;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        swap(arr, i, minIdx);
    }
}
```
### 3.3 复杂度分析

- **时间复杂度**：总是 O(N²)，无论输入是否有序。
    
- **空间复杂度**：O(1)（原地排序）。
    

### 3.4 特点

- 简单，但效率低。
    
- **不稳定**：交换可能改变相同元素的相对顺序。
    

---

## 🌲 四、堆排序（Heapsort）

堆排序利用堆这种数据结构，可以在 O(N log N) 时间内完成排序。我们首先介绍**基础版**（需要额外空间），然后介绍**原地版**。

### 4.1 基础版堆排序（使用额外堆）

#### 算法步骤

1. 将所有元素插入一个最大堆（Max Heap）。
    
2. 重复 N 次：删除堆顶（最大元素），将其放入输出数组的末尾。
    
3. 最终输出数组即为降序排列，可反转得到升序。
    

#### 为什么用最大堆？

因为最大堆删除的最大元素可以直接放在数组尾部，便于后续原地排序的优化。如果用最小堆，删除的最小元素需要放在数组前端，原地处理起来较麻烦。

#### Java 实现（使用优先队列）

```java

public static void heapSortSimple(int[] arr) {
    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());
    for (int x : arr) maxHeap.add(x);
    for (int i = arr.length - 1; i >= 0; i--) {
        arr[i] = maxHeap.poll(); // 从大到小放回原数组
    }
}
```
**复杂度**：

- 插入 N 次：每次 O(log N) → O(N log N)
    
- 删除 N 次：每次 O(log N) → O(N log N)
    
- 总时间：O(N log N)
    
- 空间：O(N)（额外堆空间）
    

### 4.2 原地堆排序（In-place Heapsort）

#### 4.2.1 核心思想

将输入数组本身看作一个堆，通过**堆化**（heapify）操作使其满足堆性质，然后反复删除堆顶并交换到数组末尾，同时维护堆的大小递减。

#### 4.2.2 堆化（Bottom-up Heapification）

**目标**：将任意数组调整为一个最大堆。

**方法**：从最后一个非叶子节点开始，向前对每个节点执行 `sink`（下沉）操作。最后一个非叶子节点的索引为 `(N/2) - 1`（如果数组索引从 0 开始）。

**为什么自底向上有效？**  
因为当对某个节点执行 `sink` 时，它的左右子树已经分别是堆（由于是从后往前处理，后面的节点已经处理过），因此 `sink` 后以该节点为根的树也成为堆。数学归纳法可证明。

**Java 实现**（sink 操作）：

```java

private static void sink(int[] arr, int k, int n) {
    while (2 * k + 1 < n) { // 有左子节点
        int j = 2 * k + 1; // 左子
        if (j + 1 < n && arr[j + 1] > arr[j]) j++; // 取较大的子节点
        if (arr[k] >= arr[j]) break;
        swap(arr, k, j);
        k = j;
    }
}
public static void heapify(int[] arr) {
    int n = arr.length;
    for (int k = n / 2 - 1; k >= 0; k--) {
        sink(arr, k, n);
    }
}
```
**复杂度分析**：

- 直观上，每个 `sink` 操作最多 O(log N)，共 N/2 次，因此总 O(N log N)。
    
- 但精确分析表明，堆化的时间复杂度实际上是 **O(N)**。因为大部分节点位于底层，下沉深度很小。求和可得总操作次数 ≤ 2N。这是堆排序中的一个重要细节。
    

#### 4.2.3 原地排序过程

1. 对原数组进行堆化，使其成为最大堆。
    
2. 将堆顶（最大元素）与数组末尾元素交换，此时最大元素已就位，堆大小减 1。
    
3. 对新的堆顶执行 `sink`，恢复堆性质。
    
4. 重复步骤 2-3，直到堆大小为 1。
    

**Java 实现**：

```java

public static void heapsort(int[] arr) {
    int n = arr.length;
    // 1. 堆化
    for (int k = n / 2 - 1; k >= 0; k--) {
        sink(arr, k, n);
    }
    // 2. 反复删除堆顶
    while (n > 1) {
        swap(arr, 0, n - 1); // 将最大元素交换到末尾
        n--;
        sink(arr, 0, n);     // 恢复堆性质
    }
}
```
**注意**：这里 `sink` 函数需要接收当前堆的大小 `n` 作为参数，以避免访问已排序的部分。

#### 4.2.4 复杂度分析

- **堆化**：O(N)
    
- **删除阶段**：共 N-1 次删除，每次删除后 `sink` 操作 O(log N) → 总 O(N log N)
    
- **总时间复杂度**：O(N log N)
    
- **空间复杂度**：O(1)（原地排序，仅使用常数个变量；若 `sink` 用递归实现则栈空间 O(log N)，但通常用迭代）。
    

### 4.3 为什么用最大堆而不是最小堆？

如果使用最小堆，删除最小元素后，需要将最小元素放在数组前端，但数组前端是已排序部分，这样会导致需要移动大量元素。而最大堆删除的最大元素可以直接放在数组尾部，已排序部分自然从右向左增长，非常自然。因此原地堆排序通常用最大堆。

---

## 📊 五、大 O 符号与最坏情况的区别

### 5.1 概念澄清

- **大 O 表示法**：描述算法运行时间的**上界**，即对于所有输入，运行时间不超过某个常数乘以 `f(N)`（当 N 足够大时）。它是一个**宽松的界**，不一定紧。
    
- **最坏情况**：指在特定输入下，算法实际运行时间的最大值。它是一个精确的界（对于该输入规模）。
    

### 5.2 堆化复杂度示例

堆化的精确最坏情况是 Θ(N)，但我们常用 O(N log N) 作为上界，因为每个 `sink` 最多 O(log N) 是最简单的分析，虽然不紧但正确。在整体堆排序中，由于删除阶段已经是 Θ(N log N)，所以堆化的 O(N) 或 O(N log N) 不影响总复杂度 Θ(N log N)。因此用 O(N log N) 作为堆化的上界是安全的。

**教学意义**：在分析算法时，先给出一个容易理解的上界是可以接受的，只要最终总体复杂度不受影响。但深入理解时，应追求更精确的界。

---

## 🧠 六、思考题与答案

### 1. 对于一个已经有序的数组，选择排序的时间复杂度是多少？堆排序呢？

**答案**：

- 选择排序：无论数组是否有序，每次扫描都要比较剩余的所有元素，因此始终是 Θ(N²)。
    
- 堆排序：建堆阶段需要 O(N)（即使有序，sink 操作也可能需要下沉？实际上如果数组已经是大根堆，sink 操作会很快停止，但整体仍是 O(N)）。删除阶段每次删除后仍需下沉，但下沉次数可能减少，但总体仍是 O(N log N)。不过如果数组已升序（即是最小堆形式），建堆需要调整，但复杂度仍为 O(N)。删除阶段每次取出最大元素后，新堆顶可能是最小元素，需要下沉到底，所以仍是 O(N log N)。因此堆排序最好、最坏、平均都是 Θ(N log N)。
    

### 2. 在 Trie 中，`keysWithPrefix("")` 会返回什么？

**答案**：返回 Trie 中的所有键。因为空前缀对应根节点，从根开始 DFS 收集所有键即可。

### 3. 为什么堆排序是不稳定的？

**答案**：因为堆排序在交换堆顶与末尾元素时，可能改变相同元素的相对顺序。例如，两个相等的元素，一个在堆顶，一个在堆中，交换后它们的相对位置可能颠倒。且下沉操作也可能打乱顺序。

### 4. 堆化操作中，为什么从 `n/2 - 1` 开始而不是从末尾开始？

**答案**：从 `n/2 - 1` 开始是因为下标大于等于 `n/2` 的节点都是叶子节点（如果数组索引从 0 开始）。叶子节点本身可以视为堆，无需调整。从最后一个非叶子节点开始向前处理，可以确保在 `sink` 时，其子树已经是堆。

### 5. 如果输入数组长度为 1，堆排序的堆化阶段会做什么？

**答案**：`n/2 - 1 = 0`，循环执行一次 `sink(arr, 0, 1)`，但 `while (2*0+1 < 1)` 不成立，所以什么都不做。然后删除阶段 `n > 1` 不成立，直接结束。排序正确。

### 6. 在自动补全中，如果每个节点存储了子树的最佳值，如何利用它提前终止搜索？

**答案**：使用优先队列进行最佳优先搜索。每次从队列中取出最佳节点（按值排序）。如果该节点是键，加入结果。然后将它的所有子节点加入队列。当结果集达到 k 个，且当前队列中最佳节点的值 ≤ 结果集中第 k 大的值时，可以停止，因为剩余节点不可能产生更优的结果。

### 7. 证明堆化的时间复杂度为 O(N)（提示：对高度求和）。

**答案**：对于高度为 h 的节点（叶子高度为 0），sink 操作最多需要 h 次交换。高度为 h 的节点最多有 N / 2^(h+1) 个。总操作次数 Σ h * (N / 2^(h+1)) = N/2 * Σ h/2^h，而 Σ h/2^h 收敛于常数 2，因此总操作次数 ≤ N。所以堆化是 O(N)。

### 8. 为什么堆排序不适合对几乎有序的数组进行排序？

**答案**：因为堆排序无论输入如何，都会进行 N log N 次比较和交换，无法利用输入的部分有序性。对于几乎有序的数组，插入排序可以做到接近 O(N)，而堆排序仍然是 O(N log N)。

### 9. 在 Trie 中，`longestPrefixOf` 操作如果传入的字符串正好是一个键，会返回什么？

**答案**：会返回整个字符串，因为当遍历到最后一个字符时，该节点标记为 `isKey`，`length` 会被更新为字符串长度，因此最终返回的就是整个字符串。

### 10. 简述自底向上堆化与自顶向下插入建堆的区别。

**答案**：

- 自顶向下插入：从空堆开始，逐个插入元素，每个插入需要上浮 O(log N)，总时间 O(N log N)。
    
- 自底向上堆化：从已有数组开始，从最后一个非叶子节点向前执行下沉，总时间 O(N)。
    

因此自底向上更快，且不需要额外空间。

---

## 📌 七、知识点总结（彩色标记）

|知识点|核心内容|<span style="color:red">重点/易错点</span>|
|---|---|---|
|Trie 前缀匹配|`keysWithPrefix`：定位节点后 DFS 收集；`longestPrefixOf`：遍历记录最近键|<span style="color:red">注意递归时路径字符串的维护；`longestPrefixOf` 要在每个键节点更新长度</span>|
|自动补全优化|每个节点存储子树最佳值，用优先队列进行最佳优先搜索，可提前终止|<span style="color:red">需要额外空间存储最佳值；插入后要自底向上更新</span>|
|排序定义|全序关系（三歧性 + 传递性）|<span style="color:red">相等元素视为相等，排序结果可能不唯一</span>|
|逆序数|序列中逆序对的数量|<span style="color:red">可用来度量有序程度；不同排序算法减少逆序数的策略不同</span>|
|选择排序|每次找最小元素交换到前面|<span style="color:red">O(N²) 稳定？不稳定；原地</span>|
|堆排序基础版|用额外堆存储元素，删除后放回|<span style="color:red">空间 O(N)，时间 O(N log N)</span>|
|原地堆排序|先堆化，然后反复交换堆顶与末尾并下沉|<span style="color:red">堆化从 `n/2-1` 开始；必须用最大堆；下沉时注意堆大小变化</span>|
|堆化复杂度|精确 Θ(N)，但可用 O(N log N) 作为宽松上界|<span style="color:red">证明需对高度求和；不影响总体复杂度</span>|
|大 O 与最坏情况|大 O 是上界，最坏情况是精确值|<span style="color:red">堆化 O(N log N) 虽宽松但正确；整体仍 Θ(N log N)</span>|
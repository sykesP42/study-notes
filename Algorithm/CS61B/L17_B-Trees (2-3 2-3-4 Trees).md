## 📌 一、二叉搜索树（BST）回顾

### 1.1 有根二叉树与二叉搜索树定义

**有根二叉树**（Rooted Binary Tree）

- 指定一个节点为**根**（root）
    
- 除根外，每个节点有**唯一父节点**（parent）
    
- 没有子节点的节点称为**叶节点**（leaf）
    
- 每个节点最多有 **0、1 或 2 个子节点**（左孩子、右孩子）
    

**二叉搜索树（Binary Search Tree，BST）性质**  
对于树中 **任意节点 X**：

- **左子树**中所有节点的键值 **< X 的键值**
    
- **右子树**中所有节点的键值 **> X 的键值**
    

✅ 这一性质使得 BST 能够像二分查找一样快速定位元素。

---

### 1.2 BST 查找操作


```java

static BST find(BST T, Key sk) {
    if (T == null) return null;          // 未找到
    if (sk.equals(T.key)) return T;      // 找到
    else if (sk < T.key) 
        return find(T.left, sk);         // 递归左子树
    else 
        return find(T.right, sk);        // 递归右子树
}
```
**查找过程示例**（树中单词按字母顺序）：

```text

        dog
       /   \
    bag    flat
    / \    /  \
  alf cat elf  glut
```
- 查找 `"elf"`：`dog` → `flat` → `elf` ✅ 找到
    
- 查找 `"zebra"`：`dog` → `flat` → `glut` → `null` ❌ 未找到
    

**时间复杂度**：

- **茂密（bushy）BST**：树高 ≈ log₂N → **Θ(log N)**
    
- **细长（spindly）BST**：树高 = N → **Θ(N)**
    

🔍 **关键洞察**：当 BST **茂密**时，查找速度极快，**可在1微秒内从包含宇宙原子数量级的树中找到目标**（理论极限）。

---

### 1.3 BST 插入操作

```java

static BST insert(BST T, Key i) {
    if (T == null)
        return new BST(i);               // 空位置，创建新节点
    if (i < T.key)
        T.left = insert(T.left, i);      // 插入左子树
    else if (i > T.key)
        T.right = insert(T.right, i);    // 插入右子树
    // 若相等，不做任何操作（集合不允许重复）
    return T;
}
```
**过程**：

1. 执行一次**查找**，确认键不存在。
    
2. 在查找终止的空指针位置**新建节点**，并将其链接到父节点。
    

⚠️ **插入顺序影响树形**：若按顺序插入 `1,2,3,4,5`，会形成**细长链**，查找退化为 Θ(N)。

---

### 1.4 BST 删除操作（Hibbard 删除）

根据被删节点的子节点数量，分为三种情况：

|情况|子节点数|操作|
|---|---|---|
|**1**|0|直接断开父节点链接（垃圾回收）|
|**2**|1|用子节点替换被删节点|
|**3**|2|用**前驱**（左子树最大）或**后继**（右子树最小）替换，再删除前驱/后继|

**示例**：删除根节点 `dog`

```text

        dog
       /   \
    bag    flat
    / \    /  \
  alf cat elf  glut
```
- 方案 A：用左子树最大 `cat` 替换 `dog`，再删除原 `cat`（简单删除）
    
- 方案 B：用右子树最小 `elf` 替换 `dog`，再删除原 `elf`
    

两种方案均保持 BST 性质。

---

### 1.5 BST 的核心矛盾

✅ **优点**：实现简单，茂密时性能极佳（log N）。  
❌ **缺点**：**插入顺序非随机时极易退化**（如按时间顺序插入），树高变为 N，性能跌至线性。

**现实困境**：数据到达顺序往往是**有序的**（时间戳、ID自增等），无法保证随机性。  
**解决方案**：必须通过**数据结构机制主动维持平衡**，无论插入顺序如何，树都保持茂密。

---

## 🌲 二、B树：完美平衡的多路搜索树

### 2.1 核心思想

**禁止新叶节点添加到底部** → 强制将新键插入**已有的叶节点内部**。

- 叶节点可以容纳**多个键**（过载）。
    
- 当节点“太满”时，**分裂**并**将中间键上提**给父节点。
    
- 通过**链式分裂**，树**整体增高**，但**所有叶节点到根的距离始终保持相等**。
    

这样，我们得到了一类**自动平衡、始终茂密**的树——**B树**。  
本节重点讨论 **2-3树**（每个节点最多2个键）和 **2-3-4树**（每个节点最多3个键），它们是B树的特例。

---

### 2.2 节点分裂机制（以 L=3 为例）

设节点容量上限 **L = 3**（即一个节点最多存3个键）。  
当插入导致节点有 **L+1 = 4** 个键时，必须分裂：

**分裂规则**（以叶节点为例）：

1. 从4个键中选出**中间偏左**的键（若4个键，第2个键）。
    
2. 将该键**提升到父节点**（若父节点无则创建新根）。
    
3. 剩余3个键分成两个节点：左边节点放前1/2个键，右边节点放后1/2个键。
    
4. 父节点增加一个子节点引用，并保持键的顺序。
    

**示例**：向一个已包含 `16, 18, 19` 的叶节点插入 `17`。

```text

插入前： [16, 18, 19]  （容量3，未满）
插入17 → 节点变为 [16, 17, 18, 19]  （溢出！）
分裂：
- 提升键：17
- 左节点： [16]
- 右节点： [18, 19]
- 父节点（若存在）增加一个键17，并拥有三个子节点：<16、介于16~18、>19
```
🔹 **关键**：分裂后所有叶节点仍在同一深度，树高度**仅当根节点分裂时才增加1**。

---

### 2.3 链式分裂与根节点分裂

**非根节点分裂**：树高度不变，仅父节点增加一个键和一个子节点。  
**根节点分裂**：树高度+1，提升的键成为新根，所有节点下移一层。

**演示**（L=3，依次插入20,21,22,23...）：

1. 插入20 → 叶节点 [18,19,20,21] 分裂，提升19，父节点增加19。
    
2. 插入22 → 某叶节点再次分裂，继续提升。
    
3. 若父节点也溢出（如父节点已有17,19,21，再插入23导致4键），则父节点分裂，提升19到新根。
    

✅ **结论**：B树**永远完美平衡**，所有叶节点同深度。

---

### 2.4 B树的两个不变性

由构造过程自然保证：

1. **所有叶节点到根的距离相等** → 完美平衡。
    
2. **非叶节点若有 k 个键，则必有 k+1 个子节点**。
    

**反例**（不可能存在的B树结构）：

```text

       [2,3]
         |
       [5,6,7]   ← 叶节点深度不同；且[2,3]有2个键但只有1个子节点，违反不变性
```
这两个不变性使得B树**无论如何插入**，树高始终为 Θ(log N)。

---

### 2.5 B树的高度分析

设每个节点最多可容纳 **L** 个键（即**阶数**相关），则：

- **最矮情况**：所有节点都**填满**（每节点 L 个键，L+1 个子节点）。  
    N 个键时树高 ≈ **log_{L+1}(N)**。
    
- **最高情况**：所有非叶节点**仅含1个键**（2个子节点）。  
    N 个键时树高 ≈ **log₂(N)**。
    

|L|最低高度|最高高度|实际高度范围|
|---|---|---|---|
|2|log₃N|log₂N|Θ(log N)|
|3|log₄N|log₂N|Θ(log N)|

📌 **无论最佳/最坏，高度均为 Θ(log N)**，区别仅在于对数的底数——**常数因子不影响渐近复杂度**。

---

## 🔍 三、B树操作复杂度分析

### 3.1 查找（contains）

- 从根向下，每层在**一个节点内**进行顺序比较（最多 L 次比较）。
    
- 层数 = 树高 H = Θ(log N)。
    
- 每层比较次数 ≤ L（常数）。
    

**总时间复杂度** = **O(H·L) = O(log N)** （L为常数）。

---

### 3.2 插入（add）

1. **查找插入位置**：同查找，O(log N)。
    
2. **插入叶节点**：若未满，直接插入并排序；若溢出，**分裂**。
    
3. **分裂可能向上传播**，最多传播到根（H次分裂）。
    
4. 每次分裂涉及常数次键移动与指针调整。
    

**总时间复杂度** = **O(H·L) = O(log N)**，与查找同阶。

✅ **结论**：**B树的查找与插入均为 O(log N)，且与输入顺序无关**。

---

## 🧩 四、B树特例：2-3树与2-3-4树

|名称|每个节点最多键数 L|每个节点最多子节点数|分裂时提升位置|
|---|---|---|---|
|**2-3树**|2|3|中间键（第2个）|
|**2-3-4树**|3|4|中间偏左键（第2个）|

**构建练习**（2-3树，L=2，插入顺序 1,2,3,4,5,6,7）：

```text

插入1 → [1]
插入2 → [1,2]
插入3 → [1,2,3] 溢出 → 提升2，左[1]，右[3]，根[2]
插入4 → 找到右节点[3]，插入4 → [3,4]（未满）
插入5 → [3,4,5] 溢出 → 提升4，左[3]，右[5]，父节点[2]增加4 → 父节点[2,4]
插入6 → 插入右节点[5,6]
插入7 → [5,6,7]溢出 → 提升6，父节点[2,4]增加6 → [2,4,6]溢出 → 提升4，成为新根，左[2]，右[6]，叶节点重新分配
```
**最终树**完美平衡，高度仅2，包含7个键。

---

## 📐 五、B树 vs. BST：对比总结

|特性|二叉搜索树（BST）|B树（2-3/2-3-4树）|
|---|---|---|
|节点键数|1|1 ~ L（常数）|
|子节点数|0,1,2|k+1（k为键数）|
|平衡性|依赖插入顺序，可能退化|**始终完美平衡**|
|最坏情况树高|Θ(N)（顺序插入）|Θ(log N)|
|查找时间复杂度|最好 Θ(log N)，最坏 Θ(N)|**Θ(log N)** 保证|
|插入时间复杂度|最好 Θ(log N)，最坏 Θ(N)|**Θ(log N)** 保证|
|实现复杂度|简单|稍复杂（需处理分裂、合并）|
|适用场景|数据随机到达，或可接受退化|任何顺序插入，要求稳定性能|

---

## 🧠 六、核心思想再升华

> **B树的本质：用节点的“胖度”换取树的“矮度”**

- 普通BST每个节点只能存1个键，树高直接由节点数决定，易退化。
    
- B树允许节点存储多个键，并通过强制分裂规则，使树高增长速度**从线性变为对数**。
    
- 这是**数据结构设计中“以空间换时间”的经典范例**——每个节点容纳更多信息，减少了需要遍历的层数。
    

---

## 📘 七、术语澄清与扩展

- **B树**（B-Tree）并非“Binary Tree”，而是“Balanced Tree”或由发明者Rudolf Bayer命名。
    
- **2-3树**：L=2的B树特例。
    
- **2-3-4树**：L=3的B树特例，也称**4阶B树**。
    
- 实际数据库系统使用的B+树是B树的变种，所有键存储在叶节点，内部节点仅作索引，更适合磁盘块存储。
    

⚠️ **本课程未覆盖**：B树的删除操作、L>3时的分裂规则、B+树结构。有兴趣可参考《算法导论》。

---

## ✅ 八、本讲要点速查表

|知识点|核心内容|必须掌握的细节|
|---|---|---|
|BST退化|顺序插入 → 细长树 → Θ(N)|示例：1,2,3,4,...|
|B树核心思想|节点过载 → 分裂 → 上提中间键|保证完美平衡|
|分裂触发|节点键数 = L+1|L是常数（如2或3）|
|分裂操作|中间键上提，左右分裂为两节点|父节点增加一个键和一个子节点|
|高度分析|最低 log_{L+1}(N)，最高 log₂(N)|均为 Θ(log N)|
|复杂度|查找/插入 O(log N)|与插入顺序无关|
|2-3树|L=2，分裂时提升第2个键|每个节点最多2键3子|
|2-3-4树|L=3，分裂时提升中间偏左键|每个节点最多3键4子|
|不变性|①所有叶同深；②非叶有k+1子|验证树是否合法|

---

## 💬 九、初学者常见疑问

**Q1：B树为什么叫“B”树？**  
A：尚无定论，可能代表“平衡（Balanced）”、“波音（Boeing）”或发明者名字。不是Binary的B。

**Q2：B树每个节点可以存很多键吗？**  
A：可以，L 可以根据需要设定（如磁盘页大小）。L越大，树越矮，但节点内比较时间增加（可用二分查找优化）。

**Q3：B树适合内存还是磁盘？**  
A：**尤其适合磁盘**。因为磁盘读写以“块”为单位，B树节点大小正好对齐块大小，一次读入一个节点，减少I/O次数。内存中常用红黑树（一种平衡BST），实现更简单。

**Q4：2-3-4树和2-3树哪个更好？**  
A：2-3-4树更矮，但节点内比较次数略多。算法分析中，**L是常数，不影响渐近复杂度**，实际选择需权衡。

---

## 🎯 十、总结

- **二叉搜索树简单高效，但怕顺序输入**。
    
- **B树通过节点分裂机制，彻底解决了平衡问题**，无论插入顺序如何，始终保证 O(log N) 性能。
    
- **2-3树、2-3-4树是理解B树的绝佳入门模型**，它们的分裂规则直观，不变性清晰。
    
- B树的思想影响深远：**当数据规模巨大且插入顺序不可控时，平衡多路树是可靠的基石**。
    

> “在计算机科学中，**平衡**是一种美德。” —— B树正是这种美德的完美体现。
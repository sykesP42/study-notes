# 📊 排序 VI：基数排序 vs 比较排序（Sorting VI: Radix vs Comparison）—— 非比较排序的全面解析与实战对比

> 本文是 CS61B Spring 2024 Lecture 36 的超详细笔记，全面探讨非比较排序家族：**睡眠排序（概念趣味）**、**计数排序（Counting Sort）**、**基数排序（Radix Sort）** 的 LSD 和 MSD 变体。我们将深入分析每种算法的原理、实现、时间复杂度（考虑 N、R、W 三个维度）、稳定性、内存使用，并与比较排序（快速排序、归并排序）进行多角度对比。通过大量的代码示例、数学推导和实验数据分析，帮助你彻底理解何时该选择哪种排序算法。最后还将讨论 JIT 编译器对性能评测的影响，以及实际工程中的算法选择策略。

---

## 😴 一、睡眠排序（Sleep Sort）—— 趣味概念引入

### 1.1 算法思想

睡眠排序是一种极具创意但完全不实用的排序算法，它利用**时间维度**而非比较来排序整数。对于数组中的每个整数 x，我们启动一个独立的线程（或进程），该线程休眠 x 秒后输出 x。所有线程同时启动，由于休眠时间不同，最终输出的顺序就是排序后的顺序。

**示例**：对数组 `[1, 2, 3, 10]` 进行睡眠排序

- 启动 4 个线程：线程1 休眠 1 秒后输出 1，线程2 休眠 2 秒后输出 2，线程3 休眠 3 秒后输出 3，线程4 休眠 10 秒后输出 10。
    
- 输出顺序：1, 2, 3, 10 ✓
    

### 1.2 时间复杂度分析

- 启动所有线程需要 O(N) 时间。
    
- 等待最后一个元素输出需要 `max(A)` 秒。
    
- 因此总“时间复杂度”为 **O(N + max(A))**。
    

**理论意义**：当 `max(A)` 很小时，理论上可以突破比较排序 O(N log N) 的下界。例如排序 `[1,2,3]` 只需 3 秒，比快速排序的常数时间还“快”？但实际上这是用空间（并行线程）和时间（等待）换来的，且受硬件限制。

### 1.3 为什么实际中不可行？

- **大数值问题**：如果最大元素是 10⁶，需要等待约 11.5 天。
    
- **并行开销**：启动 N 个线程的管理开销巨大。
    
- **精度问题**：浮点数排序时，休眠时间可能不精确。
    
- **系统调度**：操作系统线程调度可能导致输出顺序错乱（例如 1 秒的线程可能被延迟，反而在 2 秒的线程之后输出）。
    
- **资源消耗**：对于 N=10⁶，同时启动百万线程会耗尽系统资源。
    

### 1.4 历史趣闻

睡眠排序据说最早由 4chan 论坛用户在 2011 年提出，并附带了一个 bash 脚本实现。它虽然不实用，但启发了人们对非比较排序可能性的思考。

---

## 📊 二、计数排序（Counting Sort）—— 空间换时间

### 2.1 基本思想

计数排序适用于**键值范围已知且较小**的场景。它通过统计每个键值出现的次数，直接确定每个元素在输出数组中的位置，无需比较。

**核心假设**：键值属于有限集合（如 0~R-1），且 R 不能太大。

### 2.2 简单版本：键值唯一且连续

假设待排序数组中的元素本身就是 0 到 N-1 的整数，且每个值恰好出现一次。那么我们可以直接创建一个大小为 N 的新数组，将原数组中的元素 `a[i]` 放到新数组的第 `a[i]` 个位置。


```java

public static int[] simpleCountingSort(int[] arr) {
    int N = arr.length;
    int[] sorted = new int[N];
    for (int val : arr) {
        sorted[val] = val;
    }
    return sorted;
}
```
**时间复杂度**：O(N)，空间 O(N)。

**局限性**：要求键值连续且唯一，实际很少见。

### 2.3 通用版本：处理重复键值

通用计数排序通过**计数数组**和**前缀和**来确定每个键值的起始位置，并能保持**稳定性**。

**步骤**：

1. **计数**：遍历原数组，统计每个键值出现的次数，存入 `count` 数组（大小为 R）。
    
2. **前缀和**：将 `count` 数组转换为前缀和，即每个键值在输出数组中的**起始索引**（或结束索引，取决于遍历方向）。
    
3. **放置**：逆序遍历原数组（为保持稳定性），根据当前元素的值找到其在输出数组中的位置，放入后将该键值的起始索引加1。
    

**代码实现**：

```java

public static void countingSort(int[] arr, int R) {
    int n = arr.length;
    int[] count = new int[R];
    int[] output = new int[n];
    // 1. 计数
    for (int val : arr) {
        count[val]++;
    }
    // 2. 前缀和（计算起始位置）
    for (int i = 1; i < R; i++) {
        count[i] += count[i-1];
    }
    // 此时 count[i] 表示小于等于 i 的元素总数，即 i 的最后一个位置+1
    // 3. 逆序放置以保持稳定
    for (int i = n-1; i >= 0; i--) {
        int val = arr[i];
        output[count[val] - 1] = val;
        count[val]--;
    }
    // 4. 复制回原数组
    System.arraycopy(output, 0, arr, 0, n);
}
```
**稳定性证明**：因为我们是逆序遍历原数组，对于相同键值的元素，后出现的（原数组中靠后的）会被先放到输出数组中靠后的位置，从而保持原顺序。

### 2.4 示例演示

假设我们要对扑克牌按花色排序（花色顺序：♣ < ♢ < ♡ < ♠，编码为 0,1,2,3）。输入数组 `[♡, ♣, ♢, ♡, ♠]` 编码为 `[2,0,1,2,3]`。

1. 计数：`count = [1,1,2,1]`（♣1个，♢1个，♡2个，♠1个）
    
2. 前缀和：`count = [1,2,4,5]`（表示：♣的最后一个位置索引0，♢的最后一个位置索引1，♡的最后一个位置索引3，♠的最后一个位置索引4）
    
3. 逆序放置：
    
    - 原数组最后一个元素是 ♠(3)，位置 `count[3]-1=4`，放入，`count[3]--` 变为4。
        
    - 下一个是 ♡(2)，位置 `count[2]-1=3`，放入，`count[2]--` 变为3。
        
    - 下一个是 ♢(1)，位置 `count[1]-1=1`，放入，`count[1]--` 变为1。
        
    - 下一个是 ♣(0)，位置 `count[0]-1=0`，放入，`count[0]--` 变为0。
        
    - 最后一个 ♡(2)，此时 `count[2]=2`，位置 `2-1=1`？不对，此时 count[2] 在上一步减为 3？让我们重新仔细做：
        
    
    初始 count（前缀和后）: [1,2,4,5]  
    逆序遍历索引 4 (♠=3): output[5-1=4] = 3, count[3]=4  
    索引 3 (♡=2): output[4-1=3] = 2, count[2]=3  
    索引 2 (♢=1): output[2-1=1] = 1, count[1]=1  
    索引 1 (♣=0): output[1-1=0] = 0, count[0]=0  
    索引 0 (♡=2): 此时 count[2]=3，output[3-1=2] = 2, count[2]=2
    
    输出数组：[0,1,2,2,3] 对应 [♣,♢,♡,♡,♠]，正确且稳定（两个 ♡ 的顺序与输入一致：输入中第一个 ♡ 在索引0，第二个在索引3；输出中第一个 ♡ 在索引2，第二个在索引3，顺序保留）。
    

### 2.5 时间复杂度与空间复杂度

- **时间复杂度**：Θ(N + R)。计数阶段 O(N)，前缀和 O(R)，放置阶段 O(N)。注意是相加而非相乘，因此当 R 较小时非常高效。
    
- **空间复杂度**：Θ(N + R)。需要输出数组和计数数组。
    

### 2.6 适用场景与局限性

✅ **适用场景**：

- 键值范围 R 较小（如 26 个字母、4 种花色、考试成绩 0-100）。
    
- 需要稳定排序。
    
- 数据量 N 很大但 R 固定。
    

❌ **局限性**：

- 无法处理非整数键值（除非映射到整数范围）。
    
- 当 R 远大于 N 时，空间浪费严重，且时间复杂度中的 R 项占主导。例如对 100 个城市按人口排序（人口范围 0~37 万），R=37M，N=100，则 Θ(N+R) ≈ 37M，远大于快速排序的 100 log 100 ≈ 460。
    

---

## 🔢 三、基数排序（Radix Sort）—— 按位排序

基数排序通过多轮计数排序（按位）来处理键值范围大的情况。它将整数或字符串分解为多位数字（或字符），每轮只对一位进行计数排序，且要求每轮的排序是**稳定**的。

### 3.1 LSD 基数排序（Least Significant Digit）

LSD 从最低有效位开始，逐位向最高有效位进行稳定排序。

**算法步骤**（以十进制整数为例）：

1. 找到数组中最大数的位数 W。
    
2. 对每一位（从个位到最高位）执行一次稳定的计数排序。
    

**代码实现**：

```java

public static void lsdRadixSort(int[] arr) {
    int max = Arrays.stream(arr).max().getAsInt();
    int exp = 1; // 当前处理的位（1:个位, 10:十位, ...）
    int[] output = new int[arr.length];
    
    while (max / exp > 0) {
        int[] count = new int[10]; // 十进制，基数为10
        
        // 计数
        for (int val : arr) {
            int digit = (val / exp) % 10;
            count[digit]++;
        }
        
        // 前缀和（转换为位置）
        for (int i = 1; i < 10; i++) {
            count[i] += count[i-1];
        }
        
        // 逆序放置（稳定）
        for (int i = arr.length-1; i >= 0; i--) {
            int digit = (arr[i] / exp) % 10;
            output[count[digit]-1] = arr[i];
            count[digit]--;
        }
        
        // 复制回原数组
        System.arraycopy(output, 0, arr, 0, arr.length);
        exp *= 10;
    }
}
```
**示例**：排序 `[329, 457, 657, 839, 436, 720, 355]`

- 个位：`[720, 355, 436, 457, 657, 329, 839]`
    
- 十位：`[720, 329, 436, 839, 355, 457, 657]`
    
- 百位：`[329, 355, 436, 457, 657, 720, 839]`
    

### 3.2 时间复杂度分析

- 每轮计数排序：O(N + R)，其中 R 是基数（如 10）。
    
- 轮数 W 等于最长数的位数。
    
- 总时间：**Θ(W·(N + R))**
    

**关键变量**：

- **N**：元素个数
    
- **R**：基数（字母表大小）
    
- **W**：最长键的宽度（位数）
    

### 3.3 处理不等长键

对于长度不同的字符串或数字，需要统一处理为等长：

- **数字**：用前导零补齐，如 `9` 视为 `009`。
    
- **字符串**：可将缺失的字符视为小于所有实际字符（如 `'a'` 之前）。在计数排序中，需要对字母表大小 R 进行调整（例如 ASCII 字符集 R=256）。
    

### 3.4 MSD 基数排序（Most Significant Digit）

MSD 从最高有效位开始，逐位递归进行。

**算法步骤**：

1. 按最高位进行一次计数排序，将数组分成多个桶（每个桶对应一个最高位值）。
    
2. 对每个桶递归地进行 MSD 排序（处理下一位），直到所有位处理完或桶内只有一个元素。
    

**特点**：

- **最佳情况**：如果最高位各不相同，只需一次计数排序，时间复杂度 Θ(N + R)。
    
- **最坏情况**：所有元素完全相同，需要检查所有位，退化为 LSD，时间复杂度 Θ(W·(N + R))。
    
- **实现复杂**：需要递归处理子问题，且需要额外空间存储每个桶的边界。
    

### 3.5 LSD vs MSD

|特性|LSD 基数排序|MSD 基数排序|
|---|---|---|
|处理顺序|从低位到高位|从高位到低位|
|子问题|无，直接一次扫描所有位|需要递归处理每个桶|
|空间|O(N + R)|O(N + W·R)（递归栈）|
|最佳情况时间|Θ(W·(N+R))|Θ(N+R)（高位不同）|
|最坏情况时间|Θ(W·(N+R))|Θ(W·(N+R))（所有键相同）|
|稳定性|稳定|稳定|
|实现难度|简单|复杂（需处理桶边界和递归）|

---

## ⚖️ 四、排序算法综合对比

下表总结了本课程学过的所有排序算法（添加 LSD 和 MSD）。

|算法|内存空间|时间复杂度|稳定性|适用场景/备注|
|---|---|---|---|---|
|堆排序|Θ(1)|Θ(N log N)|❌|原地，缓存性能差|
|插入排序|Θ(1)|Θ(N²)|✅|N < 15 或几乎有序|
|归并排序|Θ(N)|Θ(N log N)|✅|最快稳定排序，需额外空间|
|随机快速排序|Θ(log N)|Θ(N log N) 期望|❌|最快比较排序，随机化避免最坏情况|
|计数排序|Θ(N+R)|Θ(N+R)|✅|仅适用于小字母表（R 小）|
|LSD 基数排序|Θ(N+R)|Θ(W·(N+R))|✅|适用于整数/定长字符串，R 固定|
|MSD 基数排序|Θ(N+WR)|最佳 Θ(N+R)，最坏 Θ(W·(N+R))|✅|适用于字符串，高位不同时更快|

**注**：W 为最长键的宽度，R 为基数（字母表大小）。

---

## 🧪 五、实战分析：何时选择哪种排序？

### 5.1 场景一：排序 100 个城市按人口

- 人口值范围 R ≈ 37,000,000，N=100。
    
- 计数排序：Θ(N+R) ≈ 37M，太慢。
    
- 快速排序：Θ(N log N) ≈ 100×6.64 = 664 次比较，实际更快。
    
- **选择**：快速排序。
    

### 5.2 场景二：排序 100 万张扑克牌按花色

- 花色范围 R=4，N=1,000,000。
    
- 计数排序：Θ(N+R) ≈ 1,000,004，极快。
    
- 快速排序：Θ(N log N) ≈ 1e6 × 20 = 2e7 次比较。
    
- **选择**：计数排序。
    

### 5.3 场景三：排序 1000 万个 32 位整数

- 整数范围 0~2³²-1，R=2³²，太大无法计数排序。
    
- LSD 基数排序：选择合适基数（如 R=256，则 W=4），时间 Θ(4·(N+256)) ≈ 4N，优于快速排序的 N log N（log 1e7≈23）。
    
- 实验数据：对 1e7 个整数，快速排序约 10.9 秒，LSD（R=256）约 2.28 秒。
    
- **选择**：LSD 基数排序（基数为 256）。
    

### 5.4 场景四：排序大量变长字符串

- 如果字符串前缀差异大，MSD 可能很快（只需检查前几位）。
    
- 如果字符串几乎相同（如所有字符串仅最后一位不同），MSD 会退化为 LSD，需要检查所有字符。
    
- 实际中需结合数据特征选择。Java 的 `Arrays.sort` 对对象使用 TimSort（归并+插入），对字符串也适用。
    

---

## 🔥 六、JIT 编译器对性能评测的影响

### 6.1 什么是 JIT？

Java 的即时编译器（Just-In-Time Compiler）会在程序运行时**监控热点代码**，并根据实际执行情况动态优化代码。这意味着你写的代码不一定就是最终执行的代码！

**优化示例**：

- 如果发现某段代码的结果从未被使用，JIT 可能会完全消除这段代码。
    
- 如果发现频繁创建对象但未使用，JIT 可能会跳过这些创建。
    

### 6.2 JIT 如何影响排序实验？

考虑一个实验：反复创建链表而不使用它们。JIT 观察到这些链表从未被使用，可能会直接跳过创建操作，导致后续的实验时间越来越短，甚至趋近于 0。这会使性能数据失真。

**对排序实验的影响**：

- 在比较归并排序和 MSD 时，如果 JIT 优化了某些操作（如字符串比较中的冗余检查），可能导致某一种算法看起来更快。
    
- 实验数据显示，在 JIT 启用时，归并排序处理相同字符串反而比 MSD 更快，因为 JIT 可能优化了重复比较；而禁用 JIT 后，MSD 更快。
    

### 6.3 应对策略

- **预热**：让 JIT 先运行一段测试数据，使其完成优化后再开始计时。
    
- **禁用 JIT**：使用 `-Djava.compiler=NONE` 参数（不推荐，因为实际环境 JIT 开启）。
    
- **理解而非盲信数据**：意识到 JIT 的存在，分析算法本身的渐进复杂度，并结合具体场景选择。
    

---

## 📈 七、实验数据与结论

### 7.1 LSD 基数排序 vs 快速排序（整数，N=1e7）

|排序方法|基数|位数 W|运行时间（秒）|
|---|---|---|---|
|Java QuickSort|N/A|N/A|10.9|
|LSD Radix Sort|16|8|3.6|
|LSD Radix Sort|256|4|2.28|
|LSD Radix Sort|65536|2|3.66|
|LSD Radix Sort|2³⁰|2|20|

**结论**：

- 选择合适基数（如 256）时，LSD 明显优于快速排序。
    
- 基数过小（16）导致 W 增大，过小或过大都会增加时间。
    
- 基数过大（2³⁰）时，每轮计数排序的 R 太大，退化为类似计数排序的缺点。
    

### 7.2 归并排序 vs MSD（字符串，W=100）

|N|归并排序运行时间|MSD 运行时间|归并排序字符检查|MSD 字符检查|
|---|---|---|---|---|
|10,000|0.05|0.04|13.8M|1M|
|100,000|0.26|0.25|170.8M|10M|
|1,000,000|1.1|8.68|2,013M|100M|
|10,000,000|15.32|53.39|23,757M|1,000M|

**分析**：

- 归并排序检查的字符数约为 MSD 的 log N 倍（因为每次比较需要比较整个字符串，而 MSD 只检查必要位数）。
    
- 但当字符串相同时，归并排序的比较次数虽多，但 JIT 可能优化，导致实际运行时间反而更短（如 N=10M 时归并排序 15.32 秒 vs MSD 53.39 秒）。
    
- **结论**：没有绝对最优，需要针对数据和 JIT 状态进行测试。
    

---

## 🧠 八、思考题与答案

### 1. 为什么计数排序的时间复杂度是 Θ(N+R) 而不是 Θ(N log R)？

**答案**：因为计数排序不进行比较，它直接通过数组下标定位元素。计数阶段需要遍历 N 个元素，前缀和阶段需要遍历 R 个桶，放置阶段再遍历 N 个元素。这三个阶段是顺序执行的，所以总时间相加。没有涉及 log 项。

### 2. 在 LSD 基数排序中，如果基数为 256，为什么需要 4 趟排序？

**答案**：因为 32 位整数可以看作 4 个字节（每个字节 8 位），基数为 256（0-255）正好对应一个字节。所以需要从最低字节到最高字节进行 4 趟排序。

### 3. 为什么基数排序要求每轮排序是稳定的？

**答案**：因为上一轮的结果是下一轮的基础。例如 LSD 中，个位排序后，相同个位的元素顺序已定；十位排序时，如果十位相同，必须保持个位的顺序，否则最终顺序会乱。稳定排序保证了这一点。

### 4. 什么情况下 MSD 比 LSD 更快？

**答案**：当所有元素的高位各不相同（如随机字符串）时，MSD 只需一次计数排序即可完成，时间复杂度 Θ(N+R)。而 LSD 仍需对所有位进行排序。

### 5. 为什么 JIT 会导致归并排序在相同字符串时反而比 MSD 快？

**答案**：因为归并排序在比较两个相同字符串时，每次比较都需要扫描整个字符串，理论上很慢。但 JIT 可能观察到比较函数被反复调用且结果不变，从而优化掉实际比较（例如缓存结果），导致实际比较次数远小于理论值。而 MSD 的实现可能未受到同等级别的优化。

### 6. 如何为特定数据集选择最优排序算法？

**答案**：

- **小数据集**（N < 15）：插入排序。
    
- **几乎有序**：插入排序。
    
- **需要稳定**：归并排序（通用）或计数/基数排序（若键符合条件）。
    
- **整数且范围小**：计数排序。
    
- **整数或定长字符串且量大**：LSD 基数排序（选合适基数）。
    
- **变长字符串且前缀多样**：MSD 或归并排序（取决于数据）。
    
- **通用情况**：随机化快速排序（期望最快）或内省排序（避免最坏情况）。
    

实际工程中，最好用真实数据做性能测试（profile）后再决定。

---

## 📌 九、知识点总结（彩色标记）

|知识点|核心内容|<span style="color:red">重点/易错点</span>|
|---|---|---|
|睡眠排序|用线程休眠时间排序，O(N+max(A))|<span style="color:red">理论有趣但实际不可行</span>|
|计数排序|统计键值出现次数，直接放置，Θ(N+R)|<span style="color:red">必须知道键值范围 R；稳定排序；R 大时不可用</span>|
|基数排序（LSD）|从低位到高位稳定计数排序，Θ(W·(N+R))|<span style="color:red">W 为最长键位数；R 为基数；稳定</span>|
|基数排序（MSD）|从高位到低位递归计数排序，最佳 Θ(N+R)，最坏 Θ(W·(N+R))|<span style="color:red">递归开销大，但高位不同时极快</span>|
|时间复杂度三变量|N（元素数）、R（基数/字母表大小）、W（键宽度）|<span style="color:red">计数排序 Θ(N+R)，LSD Θ(W·(N+R))，归并 Θ(N log N) 但比较成本可能隐含 W</span>|
|JIT 编译器|动态优化热点代码，可能扭曲性能测试结果|<span style="color:red">测试时需预热或理解其影响</span>|
|算法选择原则|根据数据规模、范围、分布、稳定性需求、内存限制综合决定|<span style="color:red">没有万能算法，需实际评测</span>|
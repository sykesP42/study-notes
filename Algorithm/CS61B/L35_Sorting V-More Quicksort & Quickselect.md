# 🚀 排序 V：深入快速排序与快速选择（Sorting V: More Quicksort & Quickselect）—— 极致细节版

> 本文是 CS61B Spring 2024 Lecture 35 的 **超·超详细笔记**，旨在将快速排序及其相关话题的每一个细节都展开剖析。从避免最坏情况的策略到分区算法的微观操作，从快速选择的数学原理到排序稳定性的工程意义，我们将用大量文字、图示（文字描述）、代码示例和数学推导，让你彻底掌握这一经典算法的方方面面。即使是最挑剔的读者，也能在这里找到想要的深度。

---

## 📌 一、快速排序核心回顾与动机

### 1.1 快速排序的基本思想

快速排序（Quicksort）由 Tony Hoare 于 1960 年发明，是一种基于**分治**的排序算法。其核心操作是**分区（partition）**：

1. 从数组中选择一个元素作为**基准（pivot）**。
    
2. 重新排列数组，使得所有小于基准的元素出现在基准的左边，所有大于基准的元素出现在基准的右边（等于基准的元素可以放在任意一侧，具体取决于实现）。
    
3. 递归地对基准左右两侧的子数组进行相同的操作。
    

**为什么叫“快速”？** 因为在平均情况下，它的常数因子非常小，实际运行速度通常优于其他 O(N log N) 算法。

### 1.2 分区操作的直观示例

以数组 `[32, 15, 21, 7, 19, 26, 41, 17]` 为例，选择第一个元素 32 作为基准。一次分区后可能得到：


```text

[15, 21, 7, 19, 26, 17, 32, 41]
```
此时：

- 基准 32 已经位于最终排序的正确位置（排序后它应该在第 6 位，从 0 开始）。
    
- 左侧子数组 `[15, 21, 7, 19, 26, 17]` 中的所有元素都 ≤ 32。
    
- 右侧子数组 `[41]` 中的所有元素都 ≥ 32。
    

接下来递归地对左右子数组进行相同的操作。

### 1.3 时间复杂度回顾

- **最佳情况**：每次分区都将数组均匀分成两半，递归树高度为 log₂N，每层总工作量 O(N) → **Θ(N log N)**。
    
- **平均情况**：随机输入下，期望比较次数约为 2N ln N ≈ 1.39 N log₂N，也是 **Θ(N log N)**。
    
- **最坏情况**：每次分区都极度不平衡，例如数组已有序且每次选第一个元素作为基准，则递归深度为 N，总工作量 N + (N-1) + ... + 1 = **Θ(N²)**。
    

### 1.4 为什么最坏情况会发生？

考虑输入 `[1,2,3,4,5,6]`，每次选第一个元素为基准：

- 第一次分区：基准 1，左边为空，右边 `[2,3,4,5,6]`。
    
- 第二次分区：基准 2，左边为空，右边 `[3,4,5,6]`。
    
- 以此类推，每次只能排除一个元素，导致平方时间。
    

**关键**：最坏情况出现在**每次分区后子问题规模减少很少**，通常是输入有序或接近有序，且基准选择不当。

---

## 🛡️ 二、避免最坏情况的四种哲学
为了在实际中消除 O(N²) 的风险，人们提出了多种策略。我们将逐一深入探讨。

### 2.1 哲学一：随机化（Randomness）

**核心思想**：通过引入随机性，使得最坏情况出现的概率变得极低（指数级小）。

#### 2.1.1 随机选择基准

在每次分区前，随机选择一个索引与第一个元素交换，然后以新的第一个元素为基准。

**代码实现**：

```java

public static void quicksortRandom(int[] arr, int lo, int hi) {
    if (lo >= hi) return;
    // 随机选择一个索引与 lo 交换
    int randIdx = lo + (int)(Math.random() * (hi - lo + 1));
    swap(arr, lo, randIdx);
    int pivotIdx = partition(arr, lo, hi); // 使用任意分区算法
    quicksortRandom(arr, lo, pivotIdx - 1);
    quicksortRandom(arr, pivotIdx + 1, hi);
}
```
**为什么有效**？

- 对于任何固定输入，随机选择基准相当于对输入进行随机采样，使得每次分区出现极端不平衡的概率是 1/N 的量级，多次递归后概率指数衰减。
    
- 数学上可证明**期望时间复杂度为 O(N log N)**，且方差很小。
    

#### 2.1.2 预先洗牌（Shuffle）

在排序开始前，将整个数组随机打乱。这样即使输入原本有序，也变成了随机排列。

**代码实现**：

```java

public static void quicksortShuffle(int[] arr) {
    shuffle(arr); // Fisher–Yates 洗牌
    quicksort(arr, 0, arr.length - 1);
}
```
**优点**：实现简单，只需一次 O(N) 的洗牌，后续无需随机选择基准。

**注意**：洗牌本身需要随机数生成，但开销可接受。

#### 2.1.3 关于重复元素的陷阱

当数组包含大量重复元素时，随机化仍然有效，但分区算法本身可能导致不平衡。例如，如果所有元素相等，无论怎么随机，分区结果都可能是一边倒（所有元素等于基准，导致基准可能被放到中间，但左右子数组都为空？实际上，如果分区算法将等于基准的元素都放到一侧，那么仍会退化）。因此，需要配合处理重复元素的分区算法（如三向切分）。

### 2.2 哲学二：更聪明的基准选择

#### 2.2.1 三数取中（Median-of-Three）

取第一个、中间、最后一个元素的中位数作为基准。这样可避免已排序数组的最坏情况（因为三个数中至少有两个在正确的位置附近）。

**实现细节**：

1. 找出三个元素的中位数索引。
    
2. 将该索引与 `lo` 交换，然后进行普通分区。
    

```java

private static int medianOf3(int[] arr, int lo, int hi) {
    int mid = lo + (hi - lo) / 2;
    // 对三个数进行简单排序，使 arr[lo] ≤ arr[mid] ≤ arr[hi]
    if (arr[lo] > arr[mid]) swap(arr, lo, mid);
    if (arr[lo] > arr[hi]) swap(arr, lo, hi);
    if (arr[mid] > arr[hi]) swap(arr, mid, hi);
    return mid; // 中位数在 mid 位置
}
public static void quicksortMedian3(int[] arr, int lo, int hi) {
    if (lo >= hi) return;
    int pivotIdx = medianOf3(arr, lo, hi);
    swap(arr, lo, pivotIdx); // 将中位数移到最左边
    int p = partition(arr, lo, hi);
    quicksortMedian3(arr, lo, p - 1);
    quicksortMedian3(arr, p + 1, hi);
}
```
**优点**：

- 常数时间，实现简单。
    
- 对于已排序数组，中位数总是中间元素，因此每次分区平衡。
    
- 对于逆序数组也有效。
    

**缺点**：

- 仍可能被恶意输入攻击。例如，有一种“杀手”数组可以迫使三数取中每次都选到第二小的元素，导致近似 O(N²)。但这种输入非常罕见，且需要精心构造。
    

#### 2.2.2 随机抽样取中位数（Median of Random Samples）

随机选择 k 个元素（例如 k=3 或 5），取它们的中位数作为基准。这可以看作是三数取中的泛化，更加稳健。

**代码示例**（k=3）：

```java

private static int medianOfRandom3(int[] arr, int lo, int hi) {
    int a = lo + (int)(Math.random() * (hi - lo + 1));
    int b = lo + (int)(Math.random() * (hi - lo + 1));
    int c = lo + (int)(Math.random() * (hi - lo + 1));
    // 对 a,b,c 进行排序，返回中位数的索引
    if (arr[a] > arr[b]) { int t = a; a = b; b = t; }
    if (arr[a] > arr[c]) { int t = a; a = c; c = t; }
    if (arr[b] > arr[c]) { int t = b; b = c; c = t; }
    return b;
}
```
**优点**：进一步降低了最坏情况概率，尤其当输入已部分有序时。

#### 2.2.3 精确中位数（Linear-Time Median）

理论上，可以在 O(N) 时间内找到精确中位数（如 BFPRT 算法），然后用它作为基准，这样能保证最坏情况 O(N log N)。但实际中常数因子太大，往往比随机化版本慢得多，因此很少用于快速排序。我们将在后面详细讨论 BFPRT。

### 2.3 哲学三：内省排序（Introspection）

**思想**：监控递归深度，当深度超过某个阈值（例如 2 log₂N）时，认为可能遇到了不平衡，此时切换到堆排序（或归并排序）处理当前子数组，从而保证最坏情况 O(N log N)。

**为什么选 2 log₂N？** 因为快速排序的期望深度为 log₂N，2 倍是一个安全余量，超过它说明已经严重偏离期望。

**实现细节**：

- 在递归函数中传递当前允许的最大深度 `depthLimit`。
    
- 初始深度限制设为 `2 * floor(log₂(N))`（可用位运算快速计算）。
    
- 当 `hi - lo` 小于某个阈值（如 16）时，直接使用插入排序（小数组优化）。
    
- 当 `depthLimit == 0` 时，调用堆排序处理当前子数组。
    

**伪代码**：

```java

public static void introsort(int[] arr, int lo, int hi, int depthLimit) {
    if (hi - lo < 16) {
        insertionSort(arr, lo, hi);
        return;
    }
    if (depthLimit == 0) {
        heapSort(arr, lo, hi);
        return;
    }
    int pivot = partition(arr, lo, hi);
    introsort(arr, lo, pivot - 1, depthLimit - 1);
    introsort(arr, pivot + 1, hi, depthLimit - 1);
}
public static void sort(int[] arr) {
    int n = arr.length;
    int depthLimit = 2 * (int)(Math.log(n) / Math.log(2));
    introsort(arr, 0, n - 1, depthLimit);
}
```
**实际应用**：

- C++ STL 的 `std::sort` 通常实现为内省排序。
    
- Java 的 `Arrays.sort` 对于基本类型使用双轴快速排序（也是一种优化），对于对象类型使用 TimSort（结合归并和插入），但本质上都有内省机制。
    

### 2.4 哲学四：预处理数组

**思想**：在排序前先检测数组是否已经有序或几乎有序，如果是则直接使用插入排序（O(N)）。但这种方法不能完全避免最坏情况，因为“几乎有序”的定义模糊，且可能遇到其他类型的坏情况。通常不作为主要策略，而是作为小优化（例如在 TimSort 中用于检测有序片段）。

---

## 🔧 三、Hoare 分区算法深度剖析

Hoare 分区是快速排序的原始分区方案，它比后来常见的 Lomuto 分区（单指针）更高效，但实现稍复杂。

### 3.1 Hoare 分区的动机

- 原地分区，无需额外数组。
    
- 平均比较次数比 Lomuto 少（约少一半）。
    
- 缓存友好，因为访问模式是顺序的。
    

### 3.2 算法描述

**输入**：数组 `arr`，下界 `lo`，上界 `hi`。  
**输出**：基准的最终位置（通常返回 `j`）。

1. 选择基准 `pivot = arr[lo]`。
    
2. 初始化两个指针：`i = lo`，`j = hi + 1`。
    
3. 循环：
    
    - 向右移动 `i`，直到 `arr[i] ≥ pivot`。
        
    - 向左移动 `j`，直到 `arr[j] ≤ pivot`。
        
    - 如果 `i ≥ j`，退出循环。
        
    - 交换 `arr[i]` 和 `arr[j]`。
        
4. 交换 `arr[lo]` 和 `arr[j]`（将基准放到正确位置）。
    
5. 返回 `j`。
    

### 3.3 详细步骤示例

考虑数组 `[17, 15, 19, 32, 2, 26, 41, 17, 17]`，`lo=0`，`hi=8`，`pivot=17`。

**初始化**：`i=0`, `j=9`（hi+1）。

**第一次循环**：

- 向右移动 `i`：`arr[0]=17` ≥ pivot，停，`i=0`。
    
- 向左移动 `j`：`arr[8]=17` ≤ pivot，停，`j=8`。
    
- `i < j`（0<8），交换 `arr[0]` 和 `arr[8]`。交换后数组不变（都是17）。然后 `i++` 到 1，`j--` 到 7。
    

**第二次循环**：

- 移动 `i`：`arr[1]=15` < pivot → `i=2`，`arr[2]=19` ≥ pivot，停，`i=2`。
    
- 移动 `j`：`arr[7]=17` ≤ pivot，停，`j=7`。
    
- 交换 `arr[2]` 和 `arr[7]`，数组变为 `[17,15,17,32,2,26,41,19,17]`。`i=3`, `j=6`。
    

**第三次循环**：

- 移动 `i`：`arr[3]=32` ≥ pivot，停，`i=3`。
    
- 移动 `j`：`arr[6]=41` > pivot → `j=5`，`arr[5]=26` > pivot → `j=4`，`arr[4]=2` ≤ pivot，停，`j=4`。
    
- 交换 `arr[3]` 和 `arr[4]`，数组变为 `[17,15,17,2,32,26,41,19,17]`。`i=4`, `j=3`。
    

此时 `i=4`, `j=3`，循环结束。

**最后**：交换 `arr[lo]` 与 `arr[j]`，即交换 `arr[0]` 和 `arr[3]`，数组变为 `[2,15,17,17,32,26,41,19,17]`。返回 `j=3`。

验证：基准 17 现在在位置 3，左边 `[2,15]` 都 ≤ 17，右边 `[17,32,26,41,19,17]` 都 ≥ 17（注意有多个17，它们在右边）。

### 3.4 不变性证明

在循环中，维护以下不变式：

- 对于所有 `k ∈ [lo+1, i-1]`，有 `arr[k] < pivot`。
    
- 对于所有 `k ∈ [j+1, hi]`，有 `arr[k] > pivot`。
    
- 每次交换后，这两个性质依然保持。
    
- 循环结束时，`j` 是最后一个 ≤ pivot 的位置，因此将 pivot 与 `arr[j]` 交换后，左边都 ≤ pivot，右边都 ≥ pivot。
    

### 3.5 为什么返回 `j` 而不是 `i`？

因为循环结束后 `j` 指向最后一个 ≤ pivot 的元素，而 `i` 指向第一个 ≥ pivot 的元素。将 pivot 与 `arr[j]` 交换能保证左边的所有元素 ≤ pivot。如果与 `arr[i]` 交换，可能会把一个大元素换到左边。

### 3.6 处理重复元素的注意事项

Hoare 分区不保证等于 pivot 的元素都集中在一边，它们可能分布在两边。但这不影响排序的正确性，因为后续递归会处理它们。然而，如果数组有大量重复元素，这种分布可能导致子问题规模不减小（例如所有元素等于 pivot，则分区后 `j` 可能接近中间，但左右子数组依然包含 pivot，可能导致递归深度大）。此时更好的做法是使用**三向切分（3-way partition）**，将数组分为小于、等于、大于三部分，从而避免对相等元素的重复处理。

### 3.7 与 Lomuto 分区的对比

|特性|Hoare 分区|Lomuto 分区|
|---|---|---|
|指针数|2|1|
|比较次数|较少（约一半）|较多|
|交换次数|较少|较多|
|稳定性|不稳定|不稳定|
|对重复元素|可能分散|通常将等于基准的放在一起|
|实现难度|稍难|简单|

Hoare 分区通常更快，但实现需谨慎处理边界条件。

---

## ⚡ 四、快速选择（Quickselect）—— 找第 k 小的元素

### 4.1 问题定义

**选择问题**：给定无序数组和整数 k（0 ≤ k < N），找出第 k 小的元素（即排序后位于下标 k 的元素）。中位数是 k = floor(N/2) 的特殊情况。

### 4.2 算法思想

快速选择利用分区操作，类似于快速排序，但只递归处理包含目标的一侧。

**步骤**：

1. 选择一个基准，进行分区，得到基准的最终位置 `p`。
    
2. 如果 `p == k`，返回 `arr[p]`。
    
3. 如果 `p > k`，递归地在左子数组（`[lo, p-1]`）中找第 k 小的元素。
    
4. 如果 `p < k`，递归地在右子数组（`[p+1, hi]`）中找第 k-p-1 小的元素（注意调整 k）。
    

### 4.3 递归实现

```java

public static int quickselect(int[] arr, int lo, int hi, int k) {
    if (lo == hi) return arr[lo];
    int p = partition(arr, lo, hi); // 使用 Hoare 或 Lomuto 分区
    if (k == p) return arr[k];
    else if (k < p) return quickselect(arr, lo, p - 1, k);
    else return quickselect(arr, p + 1, hi, k);
}
```
### 4.4 迭代实现（避免递归栈）

```java

public static int quickselectIter(int[] arr, int k) {
    int lo = 0, hi = arr.length - 1;
    while (lo < hi) {
        int p = partition(arr, lo, hi);
        if (p == k) return arr[p];
        else if (p < k) lo = p + 1;
        else hi = p - 1;
    }
    return arr[lo];
}
```
### 4.5 复杂度分析

- **平均情况**：每次分区后，问题规模期望减少一半，总比较次数约为 N + N/2 + N/4 + ... ≈ 2N，因此平均时间复杂度 **Θ(N)**。
    
- **最坏情况**：与快速排序一样，如果每次分区极不平衡，则递归深度 N，总比较次数为 O(N²)。但通过随机化基准，可使最坏情况概率极低。
    

**证明（平均情况）**：设 T(N) 为期望比较次数。分区需要约 N 次比较，然后递归处理一侧，另一侧丢弃。由于基准是随机的，两侧大小均匀的概率大，可推出 T(N) = N + T(N/2)，解得 T(N) ≈ 2N。

### 4.6 处理重复元素

当数组有重复元素时，分区算法可能将等于基准的元素分布在两边。这可能导致即使 `p` 不等于 k，但目标值可能等于基准且分布在两侧。标准快速选择仍然正确，因为如果目标值等于基准，那么它可能在 `p` 位置，也可能在两侧，但最终递归会找到它（因为基准值在两侧都出现）。但性能可能受影响（子问题大小不减小）。改进方案：使用三向分区，将数组分为小于、等于、大于三部分，然后根据 k 落在哪一部分决定下一步。

### 4.7 应用：找中位数

java

public static int findMedian(int[] arr) {
    int n = arr.length;
    return quickselect(arr, 0, n-1, n/2);
}

对于偶数长度，中位数通常定义为中间两个数的平均，但这里返回下中位数。

---

## 🔬 五、BFPRT 算法（线性时间选择）

BFPRT（Blum-Floyd-Pratt-Rivest-Tarjan）算法，又称中位数的中位数算法，能在最坏情况下 O(N) 时间内找到第 k 小的元素。它通过精心选择基准，保证每次分区至少排除一定比例的元素。

### 5.1 算法步骤

1. 将数组分成 ⌈N/5⌉ 组，每组 5 个元素（最后一组可能不足 5 个）。
    
2. 对每组进行排序（可用插入排序），找出每组的中位数。
    
3. 递归调用 BFPRT 找出这些中位数的中位数（作为基准）。
    
4. 用该基准对数组进行分区。
    
5. 根据 k 的位置，递归处理左侧或右侧。
    

### 5.2 为什么是 5？

选择 5 是为了保证数学推导中的常数最优。理论上，任何大于等于 5 的奇数都可以，但 5 是使证明简单的最小值。每组 3 个时，递归规模减小不够，导致总复杂度超过线性。

### 5.3 复杂度分析

- 每组排序：每组 5 个元素，排序时间 O(1)，总共 O(N)。
    
- 找中位数的中位数：递归调用规模为 N/5。
    
- 分区后，至少有多少元素被排除？可以证明，基准至少大于等于 3N/10 个元素，也小于等于 3N/10 个元素，因此递归子问题规模最多 7N/10。
    
- 递推式：T(N) ≤ T(N/5) + T(7N/10) + O(N)，解得 T(N) = O(N)。
    

### 5.4 代码实现（简化版）

由于实现复杂，通常不用于实际快速排序，但作为理论存在。

```java

public static int bfprt(int[] arr, int lo, int hi, int k) {
    if (hi - lo < 5) {
        insertionSort(arr, lo, hi);
        return arr[lo + k];
    }
    // 将每组的中位数交换到数组前部
    int numMedians = (hi - lo + 1) / 5;
    for (int i = 0; i < numMedians; i++) {
        int left = lo + i * 5;
        int right = Math.min(left + 4, hi);
        insertionSort(arr, left, right);
        swap(arr, lo + i, left + (right - left) / 2); // 中位数移到前面
    }
    int medianOfMedians = bfprt(arr, lo, lo + numMedians - 1, numMedians / 2);
    // 用 medianOfMedians 作为基准分区
    int pivotPos = partition(arr, lo, hi, medianOfMedians);
    if (k == pivotPos) return arr[k];
    else if (k < pivotPos) return bfprt(arr, lo, pivotPos - 1, k);
    else return bfprt(arr, pivotPos + 1, hi, k - pivotPos - 1);
}
```
**注意**：实际代码需要处理边界和重复元素，非常繁琐，这里仅示意。

### 5.5 为什么快速排序不用 BFPRT？

虽然 BFPRT 保证了最坏情况 O(N log N) 的快速排序（每次选精确中位数），但常数因子巨大（约 5N 次比较），比随机化版本的 2N ln N 大得多，且实际中随机化几乎从不遇到最坏情况。因此，BFPRT 主要用于理论证明和需要确定性最坏保证的特殊场景（如实时系统）。

---

## 🔁 六、排序稳定性详解

### 6.1 定义

如果排序后，相等元素的相对顺序保持不变，则称该排序是**稳定的**。

**示例**：先按姓名排序，再按班级排序。若排序稳定，则每个班级内的学生仍保持按姓名排序的顺序。

### 6.2 为什么需要稳定性？

- 多关键字排序：可以逐个关键字稳定排序，得到按多个关键字排序的结果。
    
- 保持数据原有顺序：例如按时间戳排序后，再按优先级排序，稳定性能保留时间戳的顺序。
    

### 6.3 各排序算法的稳定性

|算法|稳定性|原因|
|---|---|---|
|插入排序|✅|当遇到相等元素时停止移动，不会越过它们。|
|归并排序|✅|合并时，若左半当前元素 ≤ 右半当前元素，优先取左半，保证相对顺序。|
|冒泡排序|✅|只有逆序时才交换，相等时不交换。|
|计数排序|✅|稳定实现很容易（从后往前放）。|
|堆排序|❌|建堆和交换过程可能打乱相等元素的顺序。|
|快速排序|❌（通常）|Hoare 和 Lomuto 分区都会交换元素，破坏稳定性。但可改造为稳定版本。|

### 6.4 如何实现稳定的快速排序？

若使用三扫描分区（将元素分为小于、等于、大于三组，并保持组内顺序），则可实现稳定快速排序，但需要 O(N) 额外空间且常数大。

**步骤**：

1. 创建三个临时列表（或数组）：`left`、`mid`、`right`。
    
2. 遍历数组，将小于 pivot 的放入 `left`，等于的放入 `mid`，大于的放入 `right`（保持原顺序）。
    
3. 将 `left` 复制回原数组前部，`mid` 复制到中间，`right` 复制到后部。
    
4. 递归处理 `left` 和 `right`。
    

**缺点**：空间 O(N)，且多次复制，实际比不稳定版本慢很多。因此，需要稳定性的场合通常选择归并排序。

---

## 💡 七、基数排序预热：逐位排序

### 7.1 基本思想

基数排序是一种非比较排序，它按数字的每一位进行排序。通常有两种方式：

- **LSD（Least Significant Digit）**：从最低位开始，对每一位使用稳定排序（如计数排序）。
    
- **MSD（Most Significant Digit）**：从最高位开始，递归处理。
    

### 7.2 LSD 排序示例

对三位数 `[329, 457, 657, 839, 436, 720, 355]` 进行 LSD 排序：

1. 按个位稳定排序：`[720, 355, 436, 457, 657, 329, 839]`
    
2. 按十位稳定排序：`[720, 329, 436, 839, 355, 457, 657]`
    
3. 按百位稳定排序：`[329, 355, 436, 457, 657, 720, 839]`
    

**要求**：每一步必须用稳定排序，否则结果错误。

### 7.3 为什么需要稳定排序？

因为上一步的结果是下一步的基础。例如，个位排序后，相同个位的数已经按原始顺序排列；十位排序时，如果十位相同，必须保留个位排序的顺序，这正是稳定排序的保证。

### 7.4 时间复杂度

若每个数有 d 位，每位使用计数排序（O(N)），则总时间复杂度 **O(d * N)**。当 d 较小时（例如固定长度的整数），可突破 O(N log N) 的下界。

### 7.5 空间复杂度

计数排序需要 O(R) 的辅助空间（R 为基数，例如 10 或 256），以及一个输出数组 O(N)。总空间 O(N + R)。

---

## 📉 八、比较排序下界回顾与证明

### 8.1 定理

任何基于比较的排序算法在最坏情况下至少需要 Ω(N log N) 次比较。

### 8.2 证明（决策树模型）

- 有 N 个元素，它们可能的排列有 N! 种。
    
- 一次比较产生两种结果（< 或 ≥），因此可以构建一棵二叉树（决策树）。
    
- 每个叶子节点对应一种可能的最终顺序。
    
- 树的高度 h 表示最坏情况下的比较次数。
    
- 叶子节点数 ≤ 2^h（因为二叉树最多 2^h 个叶子）。
    
- 为了能区分所有 N! 种排列，必须有 2^h ≥ N!。
    
- 取对数：h ≥ log₂(N!)。
    
- 由斯特林公式，log₂(N!) = N log₂ N - N log₂ e + O(log N) = Θ(N log N)。
    
- 因此 h = Ω(N log N)。
    

### 8.3 结论

归并排序、堆排序和快速排序（平均）都达到了这个下界，因此是渐进最优的比较排序算法。基数排序等非比较排序之所以能更快，是因为它们利用了数字本身的特性，不依赖比较操作。

---

## 📚 九、知识点总结（彩色标记）

|知识点|核心内容|<span style="color:red">重点/易错点</span>|
|---|---|---|
|快速排序基本思想|分区 + 递归分治|<span style="color:red">每次分区确定一个元素的最终位置；先分区后递归</span>|
|避免最坏情况策略|随机化、三数取中、内省排序|<span style="color:red">随机化最简单有效；内省排序保证最坏 O(N log N)</span>|
|Hoare 分区|双指针相向移动，交换不满足条件的元素|<span style="color:red">必须保存基准值；最后与 j 交换；不稳定但快</span>|
|三扫描分区|复制到三个临时数组再写回|<span style="color:red">稳定但需要 O(N) 空间，常数大</span>|
|快速选择|分区后只递归一侧，找第 k 小元素|<span style="color:red">平均 O(N)，最坏 O(N²)；随机化可避免</span>|
|精确中位数（BFPRT）|线性时间找中位数，但常数大|<span style="color:red">用于快速排序得不偿失，主要用于理论</span>|
|排序稳定性|相等元素相对顺序保持不变|<span style="color:red">插入、归并稳定；堆、快速（通常）不稳定</span>|
|基数排序预热|按位稳定排序，可突破比较排序下界|<span style="color:red">需要稳定排序作为子程序</span>|
|比较排序下界|任何比较排序最坏情况至少 Ω(N log N)|<span style="color:red">决策树模型证明</span>|

---

## 🧠 十、思考题与答案（超详细）

### 1. 为什么随机化快速排序在实践中几乎不会遇到最坏情况？

**答案**：设输入大小为 N。若每次随机选择基准，则某次分区出现极端不平衡（比如一侧大小为 0）的概率为 2/N（因为基准是最小或最大）。连续两次都出现极端不平衡的概率约为 (2/N)²，依次类推。整个排序过程中出现 O(N²) 的概率是各步概率的叠加，但可证明期望深度为 O(log N)，且方差很小。对于 N=10⁶，出现最坏情况的概率几乎为 0。因此实践中可以忽略。

### 2. Hoare 分区中，如果所有元素都相等，会发生什么？如何改进？

**答案**：若所有元素相等，Hoare 分区会导致 i 和 j 不断移动并交换，最终 i 和 j 会在中间相遇，但左右子数组依然包含大量相等元素，递归会继续。这可能导致递归深度 log N，但实际比较次数可能增多。改进方法是使用**三向切分**，将等于基准的元素放在中间，不参与递归，这样能高效处理重复元素。

### 3. 快速选择中，如果数组有大量重复元素，如何优化？

**答案**：使用三向分区，将数组分为小于、等于、大于三部分。然后根据 k 落在哪一部分决定下一步。如果 k 落在等于部分，直接返回基准值；否则递归处理小于或大于部分。这样可以避免对相等元素的重复处理，使性能更稳定。

### 4. 证明三数取中法能避免已排序数组的最坏情况。

**答案**：对于已排序数组，第一个、中间、最后一个元素中，中间元素就是中位数。因此分区后基准位于中间，左右子数组大小近似 N/2，递归树平衡，时间复杂度 O(N log N)。对于逆序数组同理。

### 5. 为什么内省排序的深度阈值设为 2 log₂N？

**答案**：快速排序的期望深度为 log₂N，深度超过 2 log₂N 的概率非常小（根据大数定律）。若深度达到此值，说明可能遇到了极端不平衡，此时切换到堆排序保证最坏情况 O(N log N)。2 倍是一个经验值，也可取其他常数如 1.5 倍，但 2 倍更安全。

### 6. 基数排序中，如果使用不稳定的排序作为子程序，会发生什么？

**答案**：假设 LSD 排序，个位排序后，相同个位的数顺序已定；十位排序时，若不稳定，可能会打乱个位的顺序，导致最终结果错误。例如，个位排序后序列为 `[17, 27]`（17 在 27 前），十位排序时若不稳定，可能变成 `[27, 17]`，而实际上十位相同（都是 1），个位顺序应该保留，但结果却颠倒了。

### 7. 如何用快速选择找到数组的第 k 大元素？

**答案**：第 k 大等价于第 N-k-1 小（0-based）。只需将 k 转换为 `N - k - 1` 然后调用快速选择。或者修改分区逻辑，使大于基准的放在左边，小于的放在右边，然后找第 k 大。
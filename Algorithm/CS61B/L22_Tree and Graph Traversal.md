# 🌳 树与图遍历（Tree and Graph Traversal）—— 从递归到搜索，全面掌握数据结构核心技巧

> 本文是 CS61B Spring 2024 Lecture 22 的详细笔记，系统讲解树的基本概念、三种深度优先遍历（前序、中序、后序）与层序遍历、图的基础知识、以及深度优先搜索（DFS）在图中寻找路径的应用。通过大量示例、可视化技巧和思考题，帮助你建立清晰的递归思维，并能灵活应用于实际问题。

---

## 🌲 一、树的基础知识回顾

### 1.1 树的定义

**树**由一组**节点**和一组连接节点的**边**组成，且满足关键约束：**任意两个节点之间有且仅有一条路径**。

- 绿色结构是树，粉色结构不是树（存在多条路径或环路）：
    
    - 树：没有环，所有节点连通。
        
    - 非树：有环（循环路径）或不连通（多棵树组成的森林）。
        

### 1.2 根树（Rooted Tree）

在一棵树中，如果我们选定一个节点作为**根**，就得到一棵根树。

- 除根节点外，每个节点有**唯一父节点**（从该节点到根路径上的第一个节点）。
    
- 没有子节点的节点称为**叶节点**。
    

**示例**：

```text

    A
   / \
  B   C
 / \
D   E

```
- A 是根，B、C 是 A 的子节点，D、E 是 B 的子节点，B 是 D、E 的父节点，D、E 是叶节点。
    

### 1.3 树的常见用途

- 数据结构实现：**二叉搜索树、堆、字典树、并查集**等。
    
- 现实应用：**文件系统目录结构、公司组织架构、家谱（注意：家谱可能有婚姻关系，不一定是树）、生物进化树**。
    

---

## 🔄 二、树的遍历（Traversal）

遍历：按某种顺序访问树中所有节点一次。主要有**层序遍历**和**深度优先遍历**。

### 2.1 层序遍历（Level Order）

- **顺序**：从上到下，从左到右（类似阅读英文）。
    
- **示例**：对下面的树，层序遍历结果为 `D B F A C E G`。
    

```text

      D
     / \
    B   F
   / \ / \
  A  C E  G
```
- **实现**：使用队列，根节点入队，循环出队并访问，然后将左右孩子入队。
    

### 2.2 深度优先遍历（Depth First）

深度优先遍历分为三种：**前序、中序、后序**。它们都是递归定义的。

#### 2.2.1 前序遍历（Preorder）

1. 访问当前节点
    
2. 递归遍历左子树
    
3. 递归遍历右子树
    

**示例结果**：`D B A C F E G`

#### 2.2.2 中序遍历（Inorder）

1. 递归遍历左子树
    
2. 访问当前节点
    
3. 递归遍历右子树
    

**示例结果**：`A B C D E F G`（对于二叉搜索树，中序得到升序序列）

#### 2.2.3 后序遍历（Postorder）

1. 递归遍历左子树
    
2. 递归遍历右子树
    
3. 访问当前节点
    

**示例结果**：`A C B E G F D`

### 2.3 可视化技巧（人类友好法）

用手指沿着树的外围逆时针画一圈：

- **前序**：经过节点**左侧**时访问。
    
- **中序**：经过节点**底部**时访问。
    
- **后序**：经过节点**右侧**时访问。
    

**示例**（下图数字表示节点值，括号内为三种遍历结果）：

```text

        1
       / \
      2   3
     / \   \
    4   5   6
       / \
      7   8
```
- 前序：1 2 4 5 7 8 3 6
    
- 中序：4 2 7 5 8 1 3 6
    
- 后序：4 7 8 5 2 6 3 1
    

### 2.4 遍历的递归实现（Java伪代码）

```java

class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int x) { val = x; }
}
// 前序
void preorder(TreeNode root) {
    if (root == null) return;
    System.out.print(root.val + " ");
    preorder(root.left);
    preorder(root.right);
}
// 中序
void inorder(TreeNode root) {
    if (root == null) return;
    inorder(root.left);
    System.out.print(root.val + " ");
    inorder(root.right);
}
// 后序
void postorder(TreeNode root) {
    if (root == null) return;
    postorder(root.left);
    postorder(root.right);
    System.out.print(root.val + " ");
}
```
### 2.5 遍历的应用场景

- **前序**：用于**打印目录结构**，因为父目录应先于子目录显示。
    
    ```text
    
    SC2APM
      directIO
      python
        script.py
      README.txt
    ```
- **后序**：用于**计算文件夹总大小**，需要先知道所有子文件的大小才能求和。
    
- **中序**：用于**二叉搜索树的排序输出**。
    

---

## 🧩 三、从树到图：更一般的关系

### 3.1 为什么需要图？

树适合表示严格的层级关系（如公司组织架构），但现实中有很多关系不是层级化的，例如**地铁线路图**：存在环，从 A 到 B 可能有多条路径。

### 3.2 图的定义

**图**由一组**顶点**和一组**边**组成，每条边连接两个顶点。

- 树是图的一种特例（无环且连通）。
    
- 图允许**环**和**不连通**。
    

### 3.3 简单图（Simple Graph）

简单图要求：

1. **无自环**：没有边连接顶点自身。
    
2. **无平行边**：两个顶点之间最多只有一条边。
    

本课程中默认讨论简单图。

### 3.4 图的类型

- **有向图 vs 无向图**：边是否有方向。
    
- **带权图 vs 无权图**：边是否有权重（如距离、成本）。
    
- **有环图 vs 无环图**：是否包含环（无环图如树）。
    

### 3.5 图的基本术语

- **顶点**（Vertex / Node）
    
- **边**（Edge）
    
- **相邻**（Adjacent）：两个顶点由一条边直接连接。
    
- **路径**（Path）：顶点序列，相邻顶点有边相连。
    
- **路径长度**：路径中边的数量。
    
- **连通分量**（Connected Component）：图中相互可达的最大顶点子集。
    

### 3.6 经典图问题

- **s-t 路径**：判断顶点 s 和 t 之间是否存在路径。
    
- **最短路径**：找到 s 到 t 的最短路径。
    
- **环检测**：图中是否有环？
    
- **欧拉回路**：是否存在一条路径，经过每条边恰好一次且回到起点？（可解，O(E)）
    
- **哈密顿回路**：是否存在一条路径，经过每个顶点恰好一次且回到起点？（NP 完全问题）
    

---

## 🔍 四、深度优先搜索（DFS）解决 s-t 连通性

### 4.1 基本思路

从起点 s 出发，沿着边深入探索，标记已访问的顶点，避免重复和无限循环，直到找到 t 或所有可达顶点都访问完。

**递归算法**（伪代码）：

```java

boolean connected(Node s, Node t) {
    if (s == t) return true;
    mark s as visited;
    for (each neighbor v of s that is not visited) {
        if (connected(v, t)) return true;
    }
    return false;
}
```
### 4.2 标记的重要性

- 如果不标记，可能陷入无限循环（在有环图中）。
    
- 标记确保每个顶点最多被访问一次，复杂度 O(V + E)。
    

### 4.3 路径重建

在 DFS 过程中，可以用一个数组 `edgeTo[]` 记录每个顶点是从哪个顶点过来的。当找到 t 后，可以从 t 回溯到 s 得到完整路径。

**DFS 路径记录**：

```java

void dfs(Node v) {
    mark v;
    for (Node w : v.neighbors) {
        if (!marked[w]) {
            edgeTo[w] = v;   // 记录前驱
            dfs(w);
        }
    }
}
```
之后调用 `dfs(s)`，然后通过 `edgeTo` 重建 s 到任意可达顶点的路径。

### 4.4 DFS 遍历顺序

- 上述算法是**前序**操作（在递归前记录/访问）。
    
- 如果需要后序操作（如拓扑排序），可以在递归完成后处理。
    

---

## 📊 五、知识小结（彩色重点）

|知识点|核心内容|<span style="color:red">重点/易错点</span>|
|---|---|---|
|树定义|节点+边，任意两点唯一路径|<span style="color:red">树是连通无环图；根树有父子关系</span>|
|层序遍历|从上到下，从左到右|<span style="color:red">用队列实现，BFS思想</span>|
|前序遍历|根 → 左 → 右|<span style="color:red">先处理当前节点，再递归子节点；适合目录打印</span>|
|中序遍历|左 → 根 → 右|<span style="color:red">二叉搜索树中序得到升序序列</span>|
|后序遍历|左 → 右 → 根|<span style="color:red">先处理子节点，再处理父节点；适合计算文件夹大小</span>|
|遍历可视化技巧|绕树画圈，按左/下/右侧访问|<span style="color:red">仅用于人类理解，计算机仍用递归/栈</span>|
|图定义|节点+边，无唯一路径约束|<span style="color:red">树是图的特例；允许环和平行边（简单图禁止平行边）</span>|
|图的类型|有向/无向，带权/无权，有环/无环|<span style="color:red">地铁线路图是有环图</span>|
|DFS 搜索|递归探索，标记已访问|<span style="color:red">必须标记，否则死循环；可用 edgeTo 记录路径</span>|
|经典图问题|s-t 路径、最短路径、环检测、欧拉/哈密顿回路|<span style="color:red">欧拉回路可解，哈密顿回路是 NP 难</span>|

---

## 🧠 六、思考题与答案

### 1. 对一棵树进行前序遍历和后序遍历，能否唯一确定树的结构？

**答案**：不能。前序+后序不能唯一确定二叉树（除非是满二叉树）。但前序+中序或后序+中序可以唯一确定。因为中序提供了左右子树的分界。

### 2. 为什么在 DFS 中必须标记已访问节点？

**答案**：如果不标记，在有环图中会无限递归（或无限循环），因为可能会反复进入同一个顶点。标记保证了每个顶点只处理一次，算法复杂度 O(V+E)。

### 3. 层序遍历可以用递归实现吗？

**答案**：层序遍历本质是广度优先，递归不适合直接实现（递归天然是深度优先）。但可以借助递归传递层级信息，然后用列表按层收集，但效率不如队列。

### 4. 在计算文件夹总大小时，应该用哪种遍历？

**答案**：后序遍历。因为必须先知道所有子文件/子文件夹的大小，才能累加到当前文件夹。后序遍历保证了子节点先被处理。

### 5. 举一个现实中的图结构例子，并说明它为什么不是树。

**答案**：**城市地铁线路图**。因为有环（例如环线），且两个车站之间可能有多条路径（换乘）。树要求任意两点只有唯一路径，而地铁显然不满足。

### 6. 深度优先搜索在图中找到的路径一定是最短路径吗？

**答案**：不一定。DFS 只保证找到一条路径，但不保证最短。要找到最短路径，通常使用 BFS（无权图）或 Dijkstra（带权图）。

### 7. 如果一个图有 N 个节点，最少需要多少条边才能保证它连通？

**答案**：最少需要 N-1 条边，此时构成一棵树。如果边数少于 N-1，图一定不连通（除非有孤立节点）。

### 8. 写出二叉树中序遍历的非递归实现（使用栈）。

**答案**：

```java

void inorder(TreeNode root) {
    Stack<TreeNode> stack = new Stack<>();
    TreeNode curr = root;
    while (curr != null || !stack.isEmpty()) {
        while (curr != null) {
            stack.push(curr);
            curr = curr.left;
        }
        curr = stack.pop();
        System.out.print(curr.val + " ");
        curr = curr.right;
    }
}
```
## 一、课程简介

### 1. 核心算法与学习重点

| 算法       | 课程重点                | 难点/易错点                 |
| -------- | ------------------- | ---------------------- |
| **快速排序** | 分治思想、双指针调整区间        | 边界处理、分界点选取与递归分治        |
| **归并排序** | 分治思想、双路归并、**稳定性**   | 辅助空间使用、合并过程的指针控制       |
| **二分查找** | 整数二分两大模板、**边界查找本质** | 🔴 **整数二分死循环**、模板选择与+1 |
|          |                     |                        |

> 💡 **排序算法选择**：课程重点讲解**快排**与**归并**，其他简单排序（冒泡、选择等）使用频率低，初学者**不必深究**。

---

### 2. 学习形式与要求

✅ **课堂核心**

- 理解算法**思想**（为什么对）
    
- 掌握代码**正确性原理**（为什么这样写）
    

❌ **常见误区**

- 死记硬背代码而不理解逻辑
    
- 忽视边界细节，凭感觉写模板
    

🎯 **课堂目标**：通过教师讲解，建立对算法思想的**深刻理解**，而非仅仅AC模板题。

---

### 3. 课后高效训练法

🟢 **模板记忆方法**

- **理解基础上记忆**：先弄懂每行代码的作用，再尝试默写
    
- 不要求逐字母背诵，但必须达到**能独立、快速、无误写出并通过调试**的水平
    

🟢 **练习策略**

- **每个模板配套 2~3 道模板题**（如AcWing 785、786、787等）
    
- **3~5 次重复练习法**：AC 后**删除代码**，过一段时间**重新手写**，直到**条件反射**
    

🟢 **效果验证**

- 通过模板题检验掌握程度
    
- 刷题时不再看题解就能**独立写出**，即为熟练
    

---

## 二、快速排序 —— 分治思想的典范

### 1. 基本流程（三步法）

🔵 **① 确定分界点**  
在区间 [l,r][l,r] 中选一个元素作为分界值 `x`，常用四种方法：

- 左边界 `q[l]`
    
- 右边界 `q[r]`
    
- **中间位置** `q[(l+r)/2]` ✅ **推荐，可避免边界陷阱**
    
- 随机选取（防卡数据，但对初学者非必需）
    

🔵 **② 调整区间**  
将数组划分为**左半部分 ≤ x** 和 **右半部分 ≥ x**，**分界点 x 不一定在分界位置上**。

🔵 **③ 递归处理左右两段**  
对左右两部分分别递归进行快速排序，合并后即有序。

---

### 2. 区间调整的两种实现

#### 📌 暴力法（思路简单，不推荐）

- 开临时数组 `a[]`、`b[]`
    
- 扫描原数组，≤ x 放 `a`，> x 放 `b`
    
- 将 `a`、`b` 依次拷贝回原数组  
    ⚠️ **缺点**：需要额外 O(n) 空间，且多一次拷贝，效率低。
    

#### 📌 双指针法（优雅高效，必须掌握）


```cpp

int i = l, j = r;
while (i < j) {
    while (q[i] < x) i++;   // i 停在 >= x 的位置
    while (q[j] > x) j--;   // j 停在 <= x 的位置
    if (i < j) swap(q[i], q[j]);
}
```
🔴 **核心性质**：**任何时候，i 左侧的数 ≤ x，j 右侧的数 ≥ x**。  
✅ 交换后，i 和 j 继续移动，直到 `i >= j` 时划分完成。

---

### 3. 边界问题 —— 死循环的根源

快速排序的**边界极其敏感**，不同分界点与递归划分方式组合可能造成**无限递归**。  
课程总结了两组**危险组合**：

|分界点选择|递归分界依据|后果|
|---|---|---|
|`q[l]`|使用 `i` 划分|对 `[1,2]` 排序时陷入死循环|
|`q[r]`|使用 `j` 划分|类似问题，区间无法缩小|

🔴 **原因**：当分界点恰好是边界值，且递归区间划分不当时，可能出现**区间长度不减小**的情况。  
✅ **安全策略**：

- **若使用 `j` 划分，分界点不能选 `q[r]`**
    
- **若使用 `i` 划分，分界点不能选 `q[l]`**
    
- 🟢 **推荐**：**分界点取中间值 `q[(l+r)/2]`**，并固定使用 **`j` 作为分界**（如下模板），彻底避免边界问题。
    

---

### 4. 标准模板（C++）—— 稳定、无死循环

```cpp

void quick_sort(int q[], int l, int r) {
    if (l >= r) return;                     // 终止条件：区间长度 ≤ 1
    
    int i = l - 1, j = r + 1;               // 因为循环中先移动，故初始化为边界外
    int x = q[(l + r) / 2];                 // 🟢 取中间值，避免边界陷阱
    
    while (i < j) {
        do i++; while (q[i] < x);           // i 右移，直到 q[i] >= x
        do j--; while (q[j] > x);           // j 左移，直到 q[j] <= x
        if (i < j) swap(q[i], q[j]);
    }
    
    quick_sort(q, l, j);                    // 左半部分 [l, j]
    quick_sort(q, j + 1, r);               // 右半部分 [j+1, r]
}
```
🔴 **注意**：递归时**必须使用 `j` 作为分界**，不可用 `i`，否则与分界点选择冲突。

---

### 5. 输入优化 —— 千万级数据的必备技巧

|语言|推荐输入方式|原因|
|---|---|---|
|**C++**|`scanf`|即使 `ios::sync_with_stdio(false)` 优化，`scanf` 仍更快|
|**Java**|`BufferedReader`|比 `Scanner` 快 **10~20 倍**|
|**通用**|一次性读入所有数据到内存|避免多次 IO 操作，性能大幅提升|

---

### 6. 复杂度与稳定性

- **时间复杂度**：
    
    - 期望 **O(n log n)**
        
    - 最坏（已有序且分界点取边界）**O(n²)**
        
- **空间复杂度**：**O(1)**（原地排序，递归栈空间不算）
    
- **稳定性**：**不稳定**（相等元素的相对顺序可能改变）
    

---

## 三、归并排序 —— 稳定的分治排序

### 1. 分治思想 —— 与快排的对比

|算法|分治顺序|核心操作|空间复杂度|稳定性|
|---|---|---|---|---|
|快速排序|**先划分，再递归**|划分（分区）|O(1)|不稳定|
|归并排序|**先递归，再合并**|合并（归并）|O(n)|**稳定**|

归并排序的流程：  
🔵 **① 确定分界点**：`mid = (l + r) / 2`  
🔵 **② 递归排序**：对 `[l, mid]` 和 `[mid+1, r]` 递归排序  
🔵 **③ 合并**：将两个有序子序列**双路归并**到临时数组，再拷贝回原数组

---

### 2. 合并过程详解（双指针法）

假设左右子数组均已有序，合并时：

- 定义指针 `i = l`（左子数组起点），`j = mid + 1`（右子数组起点）
    
- 定义临时数组 `tmp[]` 及指针 `k = 0`
    
- 比较 `q[i]` 和 `q[j]`，将较小者放入 `tmp[k++]`，并移动对应指针
    
- 当某一子数组遍历完，将另一子数组剩余元素全部放入 `tmp`
    
- 最后将 `tmp` 拷贝回 `q[l..r]`
    

🔴 **注意**：**必须使用临时数组**，无法原地归并（会覆盖未处理元素）。

---

### 3. 标准模板（C++）

```cpp

const int N = 100010;
int tmp[N];                     // 全局临时数组，避免递归中反复开辟
void merge_sort(int q[], int l, int r) {
    if (l >= r) return;
    
    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);
    
    int i = l, j = mid + 1, k = 0;
    while (i <= mid && j <= r) {
        if (q[i] <= q[j]) tmp[k++] = q[i++];
        else tmp[k++] = q[j++];
    }
    while (i <= mid) tmp[k++] = q[i++];
    while (j <= r)   tmp[k++] = q[j++];
    
    for (i = l, k = 0; i <= r; i++, k++) q[i] = tmp[k];
}
```
---

### 4. 复杂度分析

- **时间复杂度**：严格 **O(n log n)**，无论数据分布
    
- **空间复杂度**：**O(n)**（辅助数组）
    
- **稳定性**：**稳定**，因为 `q[i] <= q[j]` 时优先取左子数组元素，相等元素相对顺序不变。
    

---

## 四、二分查找 —— 本质是边界划分

### 1. 二分本质（初学者核心认知）

很多人误以为“二分只能用于有序数组”，但**有序只是二分的前提**，**二分的本质是边界查找**：

- 将区间 `[l, r]` 划分为**满足某性质** 和 **不满足该性质** 两部分
    
- 二分可以找到**满足性质的第一个位置**（左边界）或**最后一个满足性质的位置**（右边界）
    

🟢 **因此，二分的核心是**：  
① 定义**性质**（例如 `≥ x`）  
② 确定要找的是**左边界**还是**右边界**  
③ 根据边界更新方式选择对应的模板

---

### 2. 整数二分的两大模板（必须烂熟于心）

#### 🔵 模板1 —— 用于寻找 **左边界**（第一个满足条件的位置）

**区间划分**：`[l, mid]` 和 `[mid+1, r]`  
**更新方式**：`r = mid` 或 `l = mid + 1`  
**mid 计算**：`mid = l + r >> 1`（**不加1**）

```cpp

int bsearch_1(int l, int r) {
    while (l < r) {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check(mid) 为真，答案在左区间（含 mid）
        else l = mid + 1;           // 否则在右区间
    }
    return l;
}
```
#### 🔵 模板2 —— 用于寻找 **右边界**（最后一个满足条件的位置）

**区间划分**：`[l, mid-1]` 和 `[mid, r]`  
**更新方式**：`l = mid` 或 `r = mid - 1`  
**mid 计算**：`mid = l + r + 1 >> 1`（**必须加1**）

```cpp

int bsearch_2(int l, int r) {
    while (l < r) {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;    // check(mid) 为真，答案在右区间（含 mid）
        else r = mid - 1;           // 否则在左区间
    }
    return l;
}
```
---

### 3. 模板选择技巧（记忆口诀）

🔴 **“等于 mid 要加1，r 等于 mid 不用加”**

即：

- 若更新方式为 **`l = mid`**（说明答案在右半区，包含 mid），则 **mid 必须加1**（模板2）
    
- 若更新方式为 **`r = mid`**（说明答案在左半区，包含 mid），则 **mid 不加1**（模板1）
    

**推导逻辑**：  
当 `l = r - 1` 时，若不加1：`mid = (l + r)/2 = l`，若 `check(mid)` 为真，则 `l = mid = l`，区间无法缩小，陷入**死循环**。  
加1后：`mid = (l + r + 1)/2 = r`，区间必然缩小。

---

### 4. 经典例题 —— 数的范围（AcWing 789）

**题目**：给定升序数组，查询元素 `k` 的起始位置和终止位置（下标从0开始），不存在输出 `-1 -1`。

#### 第一步：查找起始位置（左边界）

- 性质定义：**第一个 ≥ k 的位置**
    
- 采用 **模板1**（`r = mid`）
    

```cpp

int l = 0, r = n - 1;
while (l < r) {
    int mid = l + r >> 1;
    if (q[mid] >= k) r = mid;
    else l = mid + 1;
}
if (q[l] != k) cout << "-1 -1" << endl;
else {
    cout << l << ' ';
    // 第二步：查找终止位置
}
```
#### 第二步：查找终止位置（右边界）

- 性质定义：**最后一个 ≤ k 的位置**
    
- 采用 **模板2**（`l = mid`）
    

```cpp

l = 0, r = n - 1;   // 重新初始化
while (l < r) {
    int mid = l + r + 1 >> 1;
    if (q[mid] <= k) l = mid;
    else r = mid - 1;
}
cout << l << endl;  // 此时 q[l] 必然等于 k
```
🔴 **易错点**：

1. **混淆两个模板**，导致死循环或结果错误
    
2. **忘记处理无解**：二分模板本身**总能找到一个边界**，需要额外判断该位置的值是否等于目标值
    
3. **起始位置和终止位置共用同一个 l, r**，第二次二分前务必重新赋值
    

---

### 5. 浮点数二分 —— 无需处理 ±1

浮点数二分**没有整数除法的向下取整问题**，因此**不需要考虑加1**，只需关注**精度**。

#### 实现方式一：精度控制

```cpp

double bsearch_f(double l, double r) {
    const double eps = 1e-6;   // 经验值：保留6位小数时取1e-8，保留n位取 10^{-(n+2)}
    while (r - l > eps) {
        double mid = (l + r) / 2;
        if (mid * mid >= x) r = mid;
        else l = mid;
    }
    return l;
}
```
#### 实现方式二：固定迭代次数

```cpp

for (int i = 0; i < 100; i++) {
    double mid = (l + r) / 2;
    if (mid * mid >= x) r = mid;
    else l = mid;
}
```
固定迭代100次，可达到约 `2^100` 精度，完全足够。

---

## 五、知识小结

|知识点|核心内容|考试重点/易混淆点|难度|
|---|---|---|---|
|**快速排序**|分治三步：选x、划分、递归|🔴 **边界处理**（分界点不能乱选）、指针写法差异|★★★★★|
|**归并排序**|分治三步：中点、递归、合并|🟢 **稳定性**、辅助空间 O(n)、递归与合并顺序|★★★★★|
|**整数二分**|本质是边界查找，两大模板：  <br>① `r=mid` 不加1  <br>② `l=mid` 必须加1|🔴 **死循环**（l=r-1 场景）、**模板选择**、无解后判断|★★★★★|
|**浮点数二分**|边界查找，无±1，精度控制或固定迭代|精度设置（保留位数+2）|★★★|
|**学习方法**|课堂理解思想 → 课后默写模板（非逐字） → 3~5次重复练习|避免机械记忆，注重熟练度|★★★|
|**时间复杂度**|快排期望 O(nlogn)，归并严格 O(nlogn)|递归层数 logn，每层 O(n)|★★★★|

# 第一章 基础算法（一）
---

# 第一部分 · 排序算法 —— 给混乱的数据“排座次”

## 一、快速排序 —— 霸道总裁式排序

### 1.1 先讲个故事：如何给一个班的学生排身高？

假设你是班主任，要对全班学生按身高从矮到高排序。你站在讲台上喊：

**“身高超过170的站右边，没超过的站左边！”**

—— 这就是**一趟划分**。

然后你对着左右两拨人分别再喊：

- 左边（≤170）：“超过160的站右边，没超过的站左边！”
    
- 右边（>170）：“超过180的站右边，没超过的站左边！”
    

—— 这就是**递归**。

直到每个小组只剩1个人，排序自然完成。

**这就是快速排序的全部秘密。** 没有更复杂的东西了。

---

### 1.2 核心三步走（用你能记住的方式）

|步骤|官方说法|人话版|零基础理解锚点|
|---|---|---|---|
|①|确定分界点|**选一个“标杆”**|班主任喊的那个身高标准（比如170）|
|②|调整区间|**站队**|比标杆矮的左转，高的右转|
|③|递归处理|**重复以上操作**|对左右两队分别再喊一遍|

🔴 **初学者最大误区**：以为标杆（分界点）必须卡在中间。  
**真相**：标杆可以随便选，选左边界、右边界、中间、随机都行 —— **但有些选法会让你死循环**（后文详细解剖）。

---

### 1.3 站队（划分）的两种方式 —— 暴力法 vs 优雅法

#### 📦 暴力法（思路像搬砖）

```cpp

// 伪代码——仅用于理解，考试别写！
vector<int> left, right;
for (每个元素) {
    if (元素 <= 标杆) left.push_back(它);
    else right.push_back(它);
}
把left和right依次拷回原数组;
```
✅ **优点**：傻子都能看懂  
❌ **缺点**：需要额外内存，拷贝两遍，慢

#### 🎯 双指针法（像相亲节目里的“快速配对”）

想象一下：

- 左指针 `i` 从左边走，任务是**找到第一个不该站在左边的人**（比标杆大）
    
- 右指针 `j` 从右边走，任务是**找到第一个不该站在右边的人**（比标杆小）
    
- 两人找到后**交换座位**，然后继续
    

**这个过程非常符合直觉**，不需要额外空间。

```cpp

int i = l, j = r;
while (i < j) {
    while (q[i] < x) i++;  // i的执念：只要我比标杆小，我就继续往右走
    while (q[j] > x) j--;  // j的执念：只要我比标杆大，我就继续往左走
    if (i < j) swap(q[i], q[j]);  // 两人都走不动了？换座位！
}
```
🟢 **初学者最容易犯的错**：把 `while (q[i] < x)` 写成 `while (q[i] <= x)`。  
**后果**：当遇到和标杆相等的元素时，指针会**越过标杆**，导致划分失败。  
**记忆锚点**：“遇到相等的，停一下，别急着过”——相等元素可以留在原地等待交换。

---

### 1.4 死循环解剖课 —— 为什么你的快排跑不完？

这是很多初学者最崩溃的地方：明明逻辑没错，但程序就是**卡死、爆栈、闪退**。

#### 📌 典型死亡组合1：分界点 = q[l] + 递归分界 = i

```cpp

int x = q[l];  // 选左边界
// ... 划分后 ...
quick_sort(q, l, i-1);  // 用i做分界
quick_sort(q, i, r);
```
**症状**：输入 `[1,2]` 就死循环。  
**病理解剖**：

- 初始 `l=0, r=1, x=1`
    
- 划分后：`i` 会停在1的位置（因为`q[0]=1`不小于x，所以`i=0`不动？等等这里需要仔细算——我们展开）
    

**我们用具体数值一步步走**（这是你调试时应该自己画在纸上的）：

```text

数组 [1,2], l=0, r=1, x=q[l]=1
初始化 i=0, j=1
第一轮while(i<j):
  do i++: i=1, q[1]=2, 2<1? false → i停在1
  do j--: j=0, q[0]=1, 1>1? false → j停在0
  
此时 i=1, j=0, i<j不成立 → 循环结束
递归: quick_sort(q, l, i-1) → quick_sort(q, 0, 0) ✅ 没问题
      quick_sort(q, i, r)   → quick_sort(q, 1, 1) ✅ 也没问题？等等，这不没死循环吗？
```
——**等等**！这是很多人自己调试时的困惑：**网上说会死循环，为什么我手动模拟没死？**

**真相**：死循环不一定发生在第一次递归，而是发生在**下一层**。我们继续：

第一趟结束，数组还是 `[1,2]`（因为没发生交换）。  
第二趟对 `[1,2]` 再快排 —— **完全相同的输入、完全相同的流程**，无限重复。

**根本原因**：当数组已经有序且分界点取左边界时，**划分结果永远是左子数组空、右子数组全**，递归永远不会把问题规模缩小到1以下。

#### 📌 解决方案：两种姿势，任选一种固化

|姿势|分界点选择|递归分界|记忆口诀|
|---|---|---|---|
|✅ 安全姿势A|**q[(l+r)/2]**|`j`|“中间分界，j为界”|
|✅ 安全姿势B|**q[(l+r)/2]**|`i-1, i`|“中间分界，i-1/i”|

**强烈建议初学者固定使用姿势A**，因为：

1. 中间值永远不会是边界（除非数组长度1，直接返回）
    
2. 用 `j` 分界时，**j 最后指向的位置一定是 ≤ 标杆的**，递归范围 `[l, j]` 和 `[j+1, r]` 必然缩小
    

---

### 1.5 标准模板（带防呆注释）

```cpp

void quick_sort(int q[], int l, int r) {
    // 【守则1】区间没东西了，收工
    if (l >= r) return;
    
    // 【守则2】标杆取中间，绝不取边界
    int x = q[(l + r) / 2];
    
    // 【守则3】双指针外扩一格，配合do-while
    int i = l - 1, j = r + 1;
    while (i < j) {
        do i++; while (q[i] < x);  // 停：q[i] >= x
        do j--; while (q[j] > x);  // 停：q[j] <= x
        if (i < j) swap(q[i], q[j]);
    }
    
    // 【守则4】用j分界，铁律
    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}
```
🟢 **初学者自检清单**：

- 分界点取的是`q[(l+r)/2]`，不是`l`也不是`r`
    
- 递归用的是`j`和`j+1`，不是`i`
    
- do-while确保指针至少移动一次，避免卡死
    
- 循环条件`while(q[i] < x)`用的是`<`和`>`，不是`<=`和`>=`
    

---

## 二、归并排序 —— 细致的档案管理员

### 2.1 另一种故事：两叠已排好的试卷怎么合并？

你有两叠按学号排好的学生档案，要合并成一叠。你怎么做？

**正常人做法**：

1. 从两叠各取最上面一张
    
2. 比较学号，小的放新堆，再取一张
    
3. 重复直到一叠空了，把另一叠直接摞上去
    

**这就是归并排序的合并操作**。简单到令人发指。

---

### 2.2 快排 vs 归并：性格完全不同的两兄弟

|维度|快速排序|归并排序|
|---|---|---|
|**性格**|先折腾再递归|先递归再合并|
|**做事方式**|先把人大致分两拨，再分别细化|先把人拆成单个，再两两合并|
|**空间观念**|原地折腾，不占地方（O(1)）|需要复印机，占地方（O(n)）|
|**稳定性**|不稳定（相等的可能换位）|**稳定**（永远不拆散相等者）|
|**最坏情况**|O(n²)——运气差时|**永远** O(n log n)|

🟢 **给零基础的视角转换**：

- **快排**像**整顿纪律**：先喊“高的站右，矮的站左”，然后左右各自整队
    
- **归并**像**拼积木**：把一块块小积木（单个元素）两两拼成更大的，直到拼完
    

**很多人觉得归并比快排难，是因为混淆了“递归顺序”**。  
记住：**快排是“自上而下”发号施令，归并是“自下而上”逐步构建**。

---

### 2.3 合并过程图解（用扑克牌理解）

假设左牌堆：`[2, 5, 7]`，右牌堆：`[1, 3, 8]`

**第1步**：比较2和1 → 取1，右堆指针后移  
输出堆：`[1]`  
左堆：`[2,5,7]`（指针在2）  
右堆：`[3,8]`（指针在3）

**第2步**：比较2和3 → 取2，左堆指针后移  
输出堆：`[1,2]`  
左堆：`[5,7]`（指针在5）  
右堆：`[3,8]`（指针在3）

**第3步**：比较5和3 → 取3，右堆指针后移  
输出堆：`[1,2,3]`  
左堆：`[5,7]`（指针在5）  
右堆：`[8]`（指针在8）

**第4步**：比较5和8 → 取5，左堆指针后移  
输出堆：`[1,2,3,5]`  
左堆：`[7]`（指针在7）  
右堆：`[8]`（指针在8）

**第5步**：比较7和8 → 取7，左堆指针后移  
输出堆：`[1,2,3,5,7]`  
左堆：`[]`  
右堆：`[8]`（指针在8）

**第6步**：左堆空，右堆剩余`[8]`全放入  
输出堆：`[1,2,3,5,7,8]`

**完成**。

这个过程中，**你不需要思考排序逻辑**，只需要**机械地比大小、取小的、移动指针**。  
这就是归并排序合并操作**零思考、零失误**的本质。

---

### 2.4 归并排序的递归树（可视化你的思维）

很多初学者看不懂递归代码，是因为**大脑里没有形成递归树的画面**。

对于数组 `[5,1,4,2,8,4]`，归并排序的递归过程是这样的：

```text

                        [5,1,4,2,8,4]  ← 原始数组
                      /              \
              [5,1,4]                [2,8,4]
              /      \              /      \
           [5,1]     [4]        [2,8]     [4]
           /   \                /   \
         [5]   [1]           [2]   [8]
```
**向上合并（归的过程）**：

```text

         [5] → [1]           [2] → [8]
           \   /               \   /
           [1,5]              [2,8]
              \                 /
            [1,4,5]        [2,4,8]
                  \         /
                 [1,2,4,4,5,8]
```
**关键洞察**：

- **向下（递）**：不做事，只分割
    
- **向上（归）**：真正做排序
    

这是归并排序和快排**最大的思维差异**。  
快排是在**向下**的过程中做事（划分），归并是在**向上**的过程中做事（合并）。

---

### 2.5 标准模板（带生命周期注释）

```cpp

const int N = 100010;
int tmp[N];  // 临时仓库 —— 整个排序过程中唯一的额外空间
void merge_sort(int q[], int l, int r) {
    // 递归终止：单个元素，自然有序
    if (l >= r) return;
    
    // 1. 拆 —— 找到中点，分成两半
    int mid = l + r >> 1;
    
    // 2. 递 —— 先让左半有序，再让右半有序
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);
    
    // 3. 归 —— 此时左右都已有序，合并它们
    int i = l, j = mid + 1, k = 0;
    
    // 双指针比大小，小的先入队
    while (i <= mid && j <= r) {
        if (q[i] <= q[j]) tmp[k++] = q[i++];
        else tmp[k++] = q[j++];
    }
    
    // 扫尾：谁有剩，全放进去
    while (i <= mid) tmp[k++] = q[i++];
    while (j <= r)   tmp[k++] = q[j++];
    
    // 物归原主：从临时仓库搬回原数组
    for (i = l, k = 0; i <= r; i++, k++) q[i] = tmp[k];
}
```
🔴 **初学者最常问**：为什么非要tmp数组？不能直接在原数组上交换吗？  
**答**：你可以试试。当你把左子数组的元素覆盖掉右子数组未处理的元素时，数据就丢了。  
**记忆锚点**：“合并需要同时看到两个子数组的全貌，所以必须有一块额外画板。”

---

# 第二部分 · 二分查找 —— 数学家的“猜数字”游戏

## 三、重新理解二分：不是“查找”，是“边界”

### 3.1 你可能被误导了很多年

99%的教材会告诉你：**二分查找的前提是有序**。

**这是对的，但会限制你的思维。**

**更本质的真相**（零基础也能懂）：

> **二分不是用来“找某个数”的，而是用来“找分界线”的。**

想象一条马路，左边全是奶茶店，右边全是咖啡店。  
**二分的任务**：找到**最后一家奶茶店**，或者**第一家咖啡店**。  
至于这条路上有没有你最爱的那家“一点点”——**那是找到边界之后的事**。

**这就是二分查找和二分答案的本质区别**，也是你从“会用模板”到“灵活应用”的跨越点。

---

### 3.2 整数二分：为什么+1是灵魂拷问？

#### 📌 先看一个让你崩溃的场景

```cpp

int l = 0, r = 1;
int mid = (l + r) / 2;  // mid = 0
if (check(mid) == true) {
    l = mid;  // l 还是 0，没变！
}
```
**死循环诞生了**。  
此时 `l=0, r=1`，mid永远是0，check(0)永远为真，l永远是0 —— **计算机被困在时间循环里**。

这就是整数二分**唯一**、**致命**、**必须记住**的死循环场景：**l = r - 1 且 check(mid) 为真且更新方式为 l = mid**。

#### 📌 解决方案：加1，破坏平衡

```cpp

int mid = (l + r + 1) / 2;  // 当 l=0, r=1 时，mid=1
if (check(mid) == true) {
    l = mid;  // l 变成 1，和 r 相等，循环结束
}
```
**这就是“l=mid必加1”这一铁律的数学根源**。  
不是玄学，不是经验，是**整数除法向下取整的物理缺陷**。

---

### 3.3 两大模板 —— 像背乘法口诀一样背下来

#### 🔵 模板1：向左找（找左边界/第一个满足条件的）

**适用场景**：区间划分成 `[l, mid]` 和 `[mid+1, r]`  
**记忆锚点**：“答案在左边，mid不用加”

```cpp

int bsearch_1(int l, int r) {
    while (l < r) {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check为真 → 答案在左区间（含mid）
        else l = mid + 1;           // check为假 → 答案在右区间（不含mid）
    }
    return l;
}
```
#### 🔵 模板2：向右找（找右边界/最后一个满足条件的）

**适用场景**：区间划分成 `[l, mid-1]` 和 `[mid, r]`  
**记忆锚点**：“答案在右边，mid必须加1”

```cpp

int bsearch_2(int l, int r) {
    while (l < r) {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;    // check为真 → 答案在右区间（含mid）
        else r = mid - 1;           // check为假 → 答案在左区间（不含mid）
    }
    return l;
}
```
🟢 **背不下来怎么办？—— 三句话救命口诀**：

> **① 写check** —— 想清楚“满足什么性质”  
> **② 看更新** —— 如果写 `l = mid` → **mid必须+1**  
> **③ 对称记** —— `l=mid` 要加1，`r=mid` 不加，**加给赋值左边的**

---

### 3.4 经典案例：数的范围（用生活场景理解）

**题目**：全班同学的生日（已按日期排序），老师问：“生日是3月5号的同学，第一个和最后一个分别在第几位？”

**你不是在找“3月5号”**——  
**你是在找**：

1. **第一个 ≥ 3月5号的人**（可能他就是3月5号，也可能是3月6号——说明3月5号没人）
    
2. **最后一个 ≤ 3月5号的人**（同理）
    

**如果第一个 ≥ 3月5号的人，生日不是3月5号 → 说明没人这天生日**。

这就是“无解判断”的逻辑。

#### 📌 完整代码（带错误示范警示）

```cpp

// 查找起始位置 —— 模板1（不加1）
int l = 0, r = n - 1;
while (l < r) {
    int mid = l + r >> 1;
    if (a[mid] >= x) r = mid;   // 🔴 初学者常写成 a[mid] > x —— 会漏掉相等情况！
    else l = mid + 1;
}
if (a[l] != x) {
    cout << "-1 -1" << endl;
    continue;
}
cout << l << " ";
// 查找终止位置 —— 模板2（加1）
l = 0, r = n - 1;   // 🔴 非常容易忘！一定要重新赋值！
while (l < r) {
    int mid = l + r + 1 >> 1;
    if (a[mid] <= x) l = mid;   // 🔴 这里要用 <=，不能用 <
    else r = mid - 1;
}
cout << l << endl;
```
**这段代码背下来不难，理解每一处符号选择的原因，才是真正的掌握。**

---

## 四、浮点数二分 —— 终于不用纠结+1了

### 4.1 为什么浮点数二分简单？

**因为浮点数没有“整除”**。

整数二分所有痛苦的根源，都来自于 `(l+r)/2` 在 `l` 和 `r` 相邻时等于 `l`。  
浮点数除法是精确的，`(0.0 + 1.0)/2 = 0.5`，区间必然缩小。

**所以你不需要记忆两套模板，不需要纠结+1。**

---

### 4.2 唯一需要关心的事：精度

浮点数在计算机里是**近似存储**的 [](https://www.ni.com/docs/fr-SY/bundle/labview/page/floating-point-numbers.html)。  
0.1 + 0.2 可能等于 0.30000000000000004。  
所以**你不能问“r - l == 0”**，只能问“r - l 足够小了吗”。

#### 📌 精度设置经验公式

|要求保留小数位数|推荐精度 eps|原理|
|---|---|---|
|4位小数|1e-6|多两位，防舍入误差|
|5位小数|1e-7|同上|
|6位小数|1e-8|同上|

这是无数前辈**用WA换来的经验值** [](https://blog.csdn.net/yl_puyu/article/details/109171733)。

---

### 4.3 懒人专属方案：固定迭代100次

如果你不想纠结eps设多少，**直接循环100次**。

```cpp

double l = 0, r = x;
for (int i = 0; i < 100; i++) {
    double mid = (l + r) / 2;
    if (mid * mid >= x) r = mid;
    else l = mid;
}
```
**为什么100次就够了？**  
因为每次区间缩小一半，100次后区间长度是初始的 `1/2^100` ≈ `10^-30`，**地球直径的误差级别都够了** [](https://blog.csdn.net/yl_puyu/article/details/109171733)。

---

# 📊 总结

|算法|核心思想|零基础理解锚点|死循环高危区|必背口诀|
|---|---|---|---|---|
|**快速排序**|分治 · 划分|班主任喊站队|分界点取边界 + 递归用i/j乱配|**中间分界，j为界**|
|**归并排序**|分治 · 合并|两叠扑克牌合并|（无，归并很乖）|**先拆成单，再两两合**|
|**整数二分**|边界查找|奶茶店/咖啡店分界线|l=r-1 且 l=mid|**l=mid必加1**|
|**浮点数二分**|近似查找|猜数字|（无，浮点不整除）|**保留n位，eps设n+2**|

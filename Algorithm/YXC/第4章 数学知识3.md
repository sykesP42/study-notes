# 第四章 数学知识（三）—— 从高斯消元到卡特兰数，解方程与组合计数的艺术


> 🎯 **目标**：学完本章，你将彻底掌握**高斯消元法解线性方程组**、**组合数的四种经典求法**（递推/阶乘逆元/卢卡斯/高精度分解）以及**卡特兰数的推导与应用**。从此线性代数与组合数学不再是拦路虎。

---

# 📌 开篇：从方程到计数，数学在算法中的两大面孔

数学知识在算法竞赛中无处不在，但归纳起来无非两大方向：

1. **解方程**——现实问题抽象成线性方程组，用**高斯消元**求解。
    
2. **数数目**——从集合中选东西的方案数，用**组合数**计算，遇到大范围用**卢卡斯定理**，遇到不取模用**高精度**。
    

本章将这两条主线串联起来，并引入一个经典的组合结构——**卡特兰数**。  
**准备好了吗？我们从解方程组开始。**

---

# 第一部分 · 高斯消元 —— 计算机如何解多元一次方程？

## 一、故事引入：鸡兔同笼升级版

小学的鸡兔同笼只有两个变量，手算即可。  
但如果有 n 个变量、n 个方程，比如：


```text

2x + y -  z =  5
 x - 3y + 2z = -4
3x + 2y - 4z =  0
```
你怎么解？

**高斯消元**就是你的“机械化求解程序”：

- 将方程组的系数和常数写成一张**矩阵表**。
    
- 通过三种合法操作（**初等行变换**），把它变成**阶梯形**（上三角矩阵）。
    
- 然后从最后一行**回代**出所有未知数。
    

**三种初等行变换**（怎么变都不改变方程组的解）：

1. **交换两行**（换个位置，方程不变）。
    
2. **某行乘以非零常数**（方程两边同乘）。
    
3. **某行的倍数加到另一行**（消元操作）。
    

---

## 二、算法步骤 —— 四步成“上三角”

### 第 1 步：找主元（列主元）

对于当前列 c，在未处理的行中（从第 c 行往下），找到该列**绝对值最大**的元素所在行 r。

- **为什么找最大？** 提高数值稳定性，减少浮点误差。
    
- 若最大绝对值仍小于一个极小量（如 `1e-6`），则认为该列全零，跳过此列（自由变量）。
    

### 第 2 步：换行

将找到的行 r 交换到当前处理的行 c。

### 第 3 步：归一化

将当前行第 c 列系数变成 1：整行除以 `a[c][c]`。

### 第 4 步：消元

用当前行将**下方所有行**的第 c 列系数消成 0：  
对每行 i（> c），`a[i][j] -= a[c][j] * a[i][c]`。

**重复**这四步，直到处理完所有列。

---

## 三、解的三种情况

经过消元后，矩阵变为**行阶梯形**。观察最后几行：

- **唯一解**：每一行都有主元，且没有矛盾方程 → 从下往上回代可得唯一解。
    
- **无解**：出现形如 `0 = 非零` 的行（左边系数全零，右边非零）。
    
- **无穷多解**：有效方程个数 < 未知数个数，出现全零行（`0 = 0`）。
    

**判定口诀**：

> “**无解看0=非0，无穷看0=0还多行，唯一解是完美三角。**”

---

## 四、代码模板（浮点版）

```cpp

#include <iostream>
#include <cmath>
#include <vector>
using namespace std;
const int N = 110;
const double eps = 1e-6;   // 浮点误差阈值
double a[N][N];   // 增广矩阵，a[i][n] 是常数项
int n;
int gauss() {
    int c, r;   // c 列, r 行
    for (c = 0, r = 0; c < n; c++) {
        // 1. 找主元行
        int t = r;
        for (int i = r; i < n; i++)
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;
        if (fabs(a[t][c]) < eps) continue;   // 该列全零，跳过
        
        // 2. 换行
        for (int j = c; j <= n; j++) swap(a[t][j], a[r][j]);
        
        // 3. 归一化
        for (int j = n; j >= c; j--) a[r][j] /= a[r][c];
        
        // 4. 消元（下方）
        for (int i = r + 1; i < n; i++)
            if (fabs(a[i][c]) > eps)
                for (int j = n; j >= c; j--)
                    a[i][j] -= a[r][j] * a[i][c];
        r++;
    }
    
    // 此时 r 是有效方程个数
    if (r < n) {
        for (int i = r; i < n; i++)
            if (fabs(a[i][n]) > eps)   // 0 = 非零
                return -1;   // 无解
        return 0;   // 无穷多解
    }
    
    // 回代（上三角已归一化）
    for (int i = n - 1; i >= 0; i--)
        for (int j = i + 1; j < n; j++)
            a[i][n] -= a[i][j] * a[j][n];
    
    return 1;   // 唯一解
}
```
🔴 **易错点**：

- **浮点比较**：永远不要写 `if (a[i][c] == 0)`，必须用 `fabs(a[i][c]) < eps`。
    
- **归一化顺序**：从右往左除，避免覆盖还没用的系数。
    
- **消元顺序**：也是从右往左，一边减一边改，不影响当前行的主元系数（已经归一化为1）。
    
- **回代时**：注意系数矩阵已经归一化，对角线为1，直接减掉后面的已知解即可。
    

🟢 **记忆口诀**：

> “**高斯消元四步走：列主元，换上行，归一化，消下方；回代从下往上算，浮点比较用eps。**”

---

## 五、时间复杂度与适用场景

- 三重循环 O(n³)，n ≤ 500 时完全可行。
    
- 适用于**实数线性方程组**，也可推广到**模意义下的方程组**（除法改为乘逆元）或**异或方程组**（加减改为异或）。
    

---

# 第二部分 · 组合数 —— 选东西的学问

组合数 CabCab​（或 (ab)(ba​)）表示从 a 个物品中选 b 个的方案数。  
竞赛中，根据数据范围的不同，有四种常用求法。

---

## 一、递推法 —— 杨辉三角（a,b ≤ 2000）

**原理**：

$$Cab=Ca−1b+Ca−1b−1Cab​=Ca−1b​+Ca−1b−1​$$

**边界**：Ca0=Caa=1Ca0​=Caa​=1。

**生活类比**：你从 a 个苹果里选 b 个，可以**分类**：

- 不拿第 a 个苹果 → 从剩下 a-1 个里选 b 个
    
- 拿第 a 个苹果 → 从剩下 a-1 个里选 b-1 个
    

**代码**：

```cpp

const int N = 2010, MOD = 1e9+7;
int c[N][N];
void init() {
    for (int i = 0; i < N; i++)
        for (int j = 0; j <= i; j++) {
            if (!j) c[i][j] = 1;
            else c[i][j] = (c[i-1][j] + c[i-1][j-1]) % MOD;
        }
}
```
**查询**：O(1) 查表。  
**适用**：a ≤ 2000，查询次数极多。

---

## 二、阶乘逆元法 —— 预处理阶乘（a,b ≤ 1e5）

**公式**：

$$Cab=a!b!⋅(a−b)!mod  pCab​=b!⋅(a−b)!a!​modp
$$
其中 p 是质数（常用 1e9+7）。

**关键**：除法在模意义下要转为乘**逆元**。  
由**费马小定理**：当 p 为质数，且 b 与 p 互质时，b−1≡bp−2(modp)b−1≡bp−2(modp)。

**预处理**：

- `fact[i] = i! % p`
    
- `infact[i] = (i!)^{-1} % p`，可由 `infact[i] = infact[i-1] * qmi(i, p-2, p) % p` 递推。
    

**代码**：

```cpp

const int N = 100010, MOD = 1e9+7;
int fact[N], infact[N];
int qmi(int a, int k, int p) { ... }  // 快速幂
void init() {
    fact[0] = infact[0] = 1;
    for (int i = 1; i < N; i++) {
        fact[i] = 1LL * fact[i-1] * i % MOD;
        infact[i] = 1LL * infact[i-1] * qmi(i, MOD-2, MOD) % MOD;
    }
}
int C(int a, int b) {
    if (b < 0 || b > a) return 0;
    return 1LL * fact[a] * infact[b] % MOD * infact[a-b] % MOD;
}
```
🔴 **易错点**：

- **乘法转 long long**，否则 int 相乘可能溢出。
    
- **取模时机**：每次乘法后取模。
    
- **边界**：当 b > a 时返回 0。
    

---

## 三、卢卡斯定理 —— 超大组合数（a,b ≤ 1e18, p ≤ 1e5）

**场景**：a 和 b 大得离谱（10¹⁸），但模数 p 不大（≤10⁵），且 p 是质数。

**定理**：

$$Cab≡Ca  pb  p⋅Ca/pb/p(modp)Cab​≡Camodpbmodp​⋅Ca/pb/p​(modp)
$$
递归终点：当 a < p 且 b < p 时，直接用阶乘逆元法。

**代码**：

```cpp

int lucas(LL a, LL b, int p) {
    if (a < p && b < p) return C(a, b, p);   // 这里的 C 用阶乘逆元（模 p）
    return 1LL * C(a % p, b % p, p) * lucas(a / p, b / p, p) % p;
}
```
**原理简证**（不用背）：  
将 a,b 写成 p 进制：  
$$a=akpk+...+a0a=ak​pk+...+a0​，$$$$b=bkpk+...+b0b=bk​pk+...+b0​  $$
利用 $$(1+x)a≡(1+x)a0(1+xp)a1...(modp)(1+x)a≡(1+x)a0​(1+xp)a1​...(modp)$$ 展开，比较系数可得。

**适用**：a,b 极大，p 较小且为质数。

---

## 四、高精度组合数 —— 不取模，要精确值（a,b ≤ 5000）

**场景**：结果不取模，直接输出整个数字，a,b ≤ 5000（如 5000! 已经天文数字，必须高精度）。

**策略**：**质因数分解 + 高精度乘法**（避免高精度除法）。

**步骤**：

1. **筛质数**：线性筛出 1~5000 的所有质数。
    
2. **计算每个质数的指数**：
    
    $Cab=a!b!(a−b)!Cab​=b!(a−b)!a!​$
    
    对于质数 p，它在 n! 中的指数为：
    
    $⌊np⌋+⌊np2⌋+⌊np3⌋+⋯⌊pn​⌋+⌊p2n​⌋+⌊p3n​⌋+⋯$
    
    因此组合数中 p 的指数 = 分子指数 - 分母指数。
    
3. **高精度乘法**：从 2 开始，把所有质数按对应次数乘起来（用 vector 存储大数）。
    

**为什么不用高精度除法？**  
高精度除法复杂且慢，通过质因数分解**只做乘法**，简单高效。

**核心函数**（求 n! 中质因子 p 的次数）：

```cpp

int get(int n, int p) {
    int res = 0;
    while (n) {
        res += n / p;
        n /= p;
    }
    return res;
}
```
**高精度乘法**：

```cpp

vector<int> mul(vector<int> &A, int b) {
    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size() || t; i++) {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```
**完整思路**：

1. 筛质数数组 `primes[]`。
    
2. 对每个质数 p，计算 `sum = get(a, p) - get(b, p) - get(a-b, p)`。
    
3. 结果向量 `res` 初始化为 `{1}`。
    
4. 对每个质数 p，循环 sum 次，`res = mul(res, p)`。
    
5. 逆序输出 `res`。
    

🔴 **易错点**：

- **get 函数循环条件**：`while (n)`，不断除以 p，累加商。
    
- **高精度乘法**：必须从低位开始，注意最后进位。
    
- **质数范围**：筛到 a 即可（因为组合数只用到 ≤a 的质数）。
    

---

# 第三部分 · 卡特兰数 —— 栈与括号的神奇数列

## 一、故事引入：买票找零

电影票 50 元一张，售票处没有零钱。  
有 n 个人手持 50 元，n 个人手持 100 元。  
问：有多少种排队方式，能让售票处**始终有 50 元找零**（即任何时候 50 元人数 ≥ 100 元人数）？

**答案**：第 n 个**卡特兰数** $Catn=1n+1(2nn)Catn​=n+11​(n2n​)$。

---

## 二、定义与公式

卡特兰数 CnCn​ 满足：

$$Cn=(2nn)−(2nn−1)=1n+1(2nn)Cn​=(n2n​)−(n−12n​)=n+11​(n2n​)$$

**前几项**：1, 1, 2, 5, 14, 42, 132, 429, ...

**递推式**：

$$C0=1,$$$$Cn+1=∑i=0nCiCn−iC0​=1,$$$$Cn+1​=i=0∑n​Ci​Cn−i​$$

---

## 三、经典应用（全部等价）

1. **合法括号序列**：n 对括号，合法排列数 = CnCn​。
    
2. **栈的进出序列**：1~n 依次入栈，不同出栈顺序数 = CnCn​。
    
3. **二叉树计数**：n 个节点组成的不同二叉树形态数 = CnCn​。
    
4. **对角线不穿过**：n×n 网格，从左下到右上，不穿过对角线的路径数 = CnCn​。
    

**路径转化法**（组合证明核心）：

- 总路径数：从 (0,0) 到 (n,n)，只能右或上，共 (2nn)(n2n​) 种。
    
- 非法路径：第一次越过对角线（碰到 y=x+1），将其后路径关于对角线反射，终点变为 (n-1, n+1)，非法路径数 = (2nn−1)(n−12n​)。
    
- 合法 = 总 - 非法 = (2nn)−(2nn−1)(n2n​)−(n−12n​)。
    

---

## 四、代码实现（模质数）

```cpp

const int MOD = 1e9+7;
int C(int a, int b) { ... }  // 阶乘逆元法
int catalan(int n) {
    return 1LL * C(2*n, n) * qmi(n+1, MOD-2, MOD) % MOD;   // 除以 n+1 转为乘逆元
}
```
🔴 **注意**：当 n 很大时（如 10⁵），仍可使用阶乘逆元法；若 n 更大（10⁶）且需多次查询，可预处理卡特兰数递推式 Cn=Cn−1∗(4n−2)/(n+1)Cn​=Cn−1​∗(4n−2)/(n+1) 取模。

---

# 📊 本章知识小结 —— 考试前夜必看

|知识点|核心思想|零基础理解锚点|易错点|难度|
|---|---|---|---|---|
|**高斯消元**|行变换成阶梯形，回代|矩阵表盘方程|浮点 eps、归一化顺序|★★★★★|
|**组合数递推**|C[i][j]=C[i-1][j]+C[i-1][j-1]|杨辉三角|边界 j=0|★★|
|**阶乘逆元法**|预处理阶乘和逆元|模逆代替除法|long long 防溢出|★★★|
|**卢卡斯定理**|递归分解 p 进制|分而治之|递归终止条件|★★★★|
|**高精度组合数**|质因数分解 + 大数乘法|只乘不除|get 函数、乘法进位|★★★★|
|**卡特兰数**|C(2n,n)/(n+1)|路径反射|除以 n+1 逆元|★★★|

---

# 🎓 写在最后：数学算法的“三板斧”

本章的三大主题——**线性方程组**、**组合计数**、**卡特兰结构**，对应着竞赛数学的三大基本工具：

- **高斯消元**：处理一切线性关系，包括图上概率、电路方程等。
    
- **组合数求法**：从几千到十亿，各有对应方法，**按数据范围选算法**是核心素养。
    
- **卡特兰数**：看似复杂，实则只是“路径问题”的一个特例，掌握反射原理即可一通百通。
    

**给你的硬核建议**：

1. **高斯消元**：手动模拟一个 3×3 方程组的消元过程，再用代码验证。
    
2. **组合数**：写齐四种方法，输入不同范围的数据，观察运行时间差异。
    
3. **卡特兰数**：把 n=1~5 的括号序列、栈序列、二叉树形态都手动画出来，感受“同一结构不同表象”的魅力。
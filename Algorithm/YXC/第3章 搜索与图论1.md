# 第三章 搜索与图论（一）—— 从树形思维到图论基石


> 🎯 **目标**：学完本章，你将彻底掌握**DFS与BFS的核心思想**、**八皇后问题的剪枝技巧**、**图的邻接表存储**、**树的重心计算**以及**拓扑排序**。从此搜索不再是玄学，图论不再是天书。

---

# 📌 开篇：搜索 —— 计算机的“试错”艺术

想象你要从一堆钥匙里找出能开某一扇门的那一把。  
你可以**一把一把试**，试错了就换下一把 —— 这就是**枚举**。  
但如果你有**很多扇门**，或者每把钥匙试过后还会影响后续的选择，你就需要一种**有组织的试错策略**。

**深度优先搜索（DFS）**：一条道走到黑，撞墙了再回头。  
**宽度优先搜索（BFS）**：层层推进，稳扎稳打。

**图论**则是把问题抽象成**点与边**，让计算机在关系网中寻找答案。

**本章，我们将从最简单的全排列开始，一步步走向树的重心与拓扑排序。**

---

# 第一部分 · 深度优先搜索（DFS）—— 不撞南墙不回头

## 一、全排列问题 —— DFS 的“Hello World”

### 1.1 故事引入：三个空位，三张牌

你有三张牌，数字分别是 1、2、3。  
你要把它们摆到三个空位里，**每个空位一张牌，不能重复**，列出所有可能的顺序。

**你的做法**：

- 第一个空位：可以放 1、2、3
    
- 第二个空位：从剩下的牌里选一张
    
- 第三个空位：放最后一张
    

这个过程天然是一棵树：  
根节点是“未放牌”，第一层是第一个空位的选择，第二层是第二个空位的选择……**深度优先搜索就是按照这棵树，从上到下走到底，然后回溯到上一个分叉口，换一条路继续走**。

---

### 1.2 状态表示与回溯

我们用什么来记录当前“已经放了哪些牌”？

- **`path[]`** 数组：记录当前排列，`path[0]` 是第一个空位的数字，`path[1]` 是第二个……
    
- **`st[]`** 布尔数组：`st[i] = true` 表示数字 `i` 已经被用过。
    

**核心操作**：


```cpp

void dfs(int u) {          // u 表示当前要填第几个空位（从0开始）
    if (u == n) {          // 填满了，输出
        for (int i = 0; i < n; i++) cout << path[i] << ' ';
        cout << endl;
        return;
    }
    for (int i = 1; i <= n; i++) {   // 枚举所有数字
        if (!st[i]) {                // 如果 i 还没用过
            path[u] = i;            // 放入当前空位
            st[i] = true;          // 标记已用
            dfs(u + 1);           // 递归填下一个空位
            st[i] = false;       // ❗❗ 恢复现场（回溯）
        }
    }
}
```
🔴 **易错点（初学者必犯）**：**忘记恢复现场**！  
如果不把 `st[i]` 改回 `false`，那么这条分支用过的数字在其他分支里也变成“已用”，后续分支就没法用了。

🟢 **记忆口诀**：“**递归前占座，递归后还座；占座不还，全家没座。**”

---

### 1.3 DFS 的时间复杂度

全排列共有 `n!` 种方案，每个方案需要 O(n) 时间输出。  
总时间复杂度 **O(n × n!)**。  
当 `n = 10` 时，`10! = 3628800`，已经接近千万级别，因此题目通常 `n ≤ 7`。

---

## 二、八皇后问题 —— 剪枝的艺术

### 2.1 问题重述

在 `n×n` 棋盘上放 `n` 个皇后，要求任意两个皇后**不在同一行、不在同一列、不在同一对角线上**。  
输出所有摆法（`n` 一般为 8，但可推广到任意 n）。

**皇后可以横、竖、斜任意走，攻击范围是整个直线**。

---

### 2.2 两种搜索顺序

#### 📌 方法一：全排列式（按行枚举，推荐！）

**思路**：每一行只能放一个皇后。我们枚举每一行皇后应该放在哪一列。  
这就是一个**全排列**问题：列号 1~n 的一个排列，且需要满足对角线约束。

**剪枝条件**：

1. 列不能重复 → 用 `col[i]` 标记第 `i` 列是否已放皇后。
    
2. 主对角线（`y = x + b`）不能重复 → 用 `dg[b]` 标记。
    
3. 副对角线（`y = -x + b`）不能重复 → 用 `udg[b]` 标记。
    

**难点**：如何用数组下标唯一表示一条对角线？

- 主对角线：行号 - 列号 = 常数，但可能是负数 → 加上偏移量 `n` 使其非负：`u - i + n`
    
- 副对角线：行号 + 列号 = 常数，范围 0 ~ 2n → 直接用 `u + i`
    

```cpp

const int N = 20;
char g[N][N];   // 棋盘
bool col[N], dg[N], udg[N];
void dfs(int u) {   // 当前在第 u 行
    if (u == n) {
        for (int i = 0; i < n; i++) puts(g[i]);
        puts("");
        return;
    }
    for (int i = 0; i < n; i++) {   // 枚举列
        if (!col[i] && !dg[u + i] && !udg[n - u + i]) {
            g[u][i] = 'Q';
            col[i] = dg[u + i] = udg[n - u + i] = true;
            dfs(u + 1);
            col[i] = dg[u + i] = udg[n - u + i] = false;
            g[u][i] = '.';
        }
    }
}
```
🔴 **易错点**：

- 对角线数组大小至少为 `2n`（因为 `u+i` 最大为 `2n-2`）。
    
- 偏移量 `n` 保证下标 ≥ 0，但数组也要开到 `2n`。
    
- 恢复现场必须**三个标记 + 棋盘符号**都恢复。
    

🟢 **记忆口诀**：“**行号列号定对角，主减副加偏移妙；列、主、副，三个数组要记牢。**”

---

#### 📌 方法二：格子枚举（逐个格子决定放不放皇后）

**思路**：从 `(0,0)` 开始，每个格子尝试放或不放皇后，直到所有格子都处理完，并保证放了 n 个皇后。

**复杂度**：每个格子两种选择 → `O(2^(n²))`，**不可接受**（除非 n 很小）。  
**仅作对比理解，实际不采用**。

---

### 2.3 DFS 剪枝总结

**剪枝**：在搜索过程中，提前判断当前路径是否可能合法，若不可能则直接回溯，不再深入。

八皇后问题的剪枝体现在：

- 列、对角线冲突 → 直接跳过该列
    
- 行天然不冲突（因为我们一行只放一个）
    

**DFS + 剪枝** 是解决**组合优化问题**的经典范式。

---

# 第二部分 · 宽度优先搜索（BFS）—— 稳扎稳打，步步为营

## 一、走迷宫 —— BFS 求最短路

### 1.1 为什么 BFS 能求最短路径？

**BFS 是按层（距离）扩展的**：

- 起点距离为 0
    
- 从起点走一步能到的点，距离为 1
    
- 走两步能到的点，距离为 2  
    ……
    

**第一次到达某个点时，走的步数一定是最少的**。  
因为 BFS 是逐层推进，所有更短的路径都已经在之前的层中被访问过了。

**DFS 不能保证最短**：DFS 可能会先沿着一条远路走到终点，虽然也到了，但不是最短的。

---

### 1.2 BFS 框架（队列实现）

```cpp

int bfs() {
    queue<pair<int,int>> q;
    q.push({0,0});
    memset(d, -1, sizeof d);   // d 数组记录距离，-1 表示未访问
    d[0][0] = 0;
    
    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
    
    while (q.size()) {
        auto t = q.front(); q.pop();
        for (int i = 0; i < 4; i++) {
            int x = t.first + dx[i], y = t.second + dy[i];
            if (x >= 0 && x < n && y >= 0 && y < m && g[x][y] == 0 && d[x][y] == -1) {
                d[x][y] = d[t.first][t.second] + 1;
                q.push({x, y});
            }
        }
    }
    return d[n-1][m-1];
}
```
🔴 **易错点**：

- **忘记初始化距离数组为 -1**（未访问）。
    
- **出界判断**：先判断 `x,y` 是否在边界内，再访问 `g[x][y]` 和 `d[x][y]`。
    
- **重复入队**：只有第一次访问才入队，否则会死循环。
    

🟢 **记忆口诀**：“**BFS 求最短，队列层层扩；首次访问即最短，标记入队不重复。**”

---

## 二、八数码问题 —— 状态图的 BFS

### 2.1 问题建模

3×3 棋盘，8 个数字和一个空格（X），每次可将空格与上下左右数字交换。  
给定初始状态，求最少步数到达目标状态。

**关键**：**状态是一个 3×3 的布局**。  
我们需要把**每个布局看作图的一个节点**，交换操作就是边，**所有边权为 1** → 可用 BFS 求最短路。

---

### 2.2 状态表示与判重

如何表示一个状态？

- 字符串：把 3×3 矩阵按行拼接成 9 个字符的字符串。
    
- 哈希表（`unordered_map<string, int>`）存储每个状态的距离。
    

**BFS 流程**：

1. 初始状态入队，距离为 0。
    
2. 队头出队，找到空格位置，尝试四个方向交换。
    
3. 生成新状态，如果没访问过，距离+1，入队。
    
4. 直到目标状态或队列为空。
    

```cpp

int bfs(string start) {
    string end = "12345678x";
    queue<string> q;
    unordered_map<string, int> d;
    q.push(start);
    d[start] = 0;
    
    int dx[4] = {-1,0,1,0}, dy[4] = {0,1,0,-1};
    
    while (q.size()) {
        auto t = q.front(); q.pop();
        int distance = d[t];
        if (t == end) return distance;
        
        int k = t.find('x');          // 空格位置
        int x = k / 3, y = k % 3;    // 转为行列
        for (int i = 0; i < 4; i++) {
            int a = x + dx[i], b = y + dy[i];
            if (a >= 0 && a < 3 && b >= 0 && b < 3) {
                swap(t[k], t[a*3 + b]);   // 交换
                if (!d.count(t)) {
                    d[t] = distance + 1;
                    q.push(t);
                }
                swap(t[k], t[a*3 + b]);   // 恢复
            }
        }
    }
    return -1;   // 无解
}
```
🔴 **易错点**：

- **交换后必须恢复**，因为下一次方向尝试要从原状态开始。
    
- **判重用 `unordered_map`**，`d.count(t)` 检查是否存在。
    
- **坐标转换**：一维下标 `k` 转二维 `(x,y)`：`x = k/3, y = k%3`。
    

---

# 第三部分 · 树与图的存储 —— 数组模拟的艺术

## 一、图的基本分类

- **有向图**：边有方向，`a → b`
    
- **无向图**：边无方向，`a — b` 等价于两条有向边 `a→b` 和 `b→a`
    

**树**：无环连通图，`n` 个点，`n-1` 条边。

---

## 二、邻接矩阵（不推荐，除非稠密图）

```cpp

int g[N][N];
// 加边
g[a][b] = 1;   // 无权图
g[a][b] = w;   // 有权图
```
**缺点**：空间 `O(n²)`，`n=10⁵` 时不可行。  
**适用**：`n ≤ 1000` 且稠密。

---

## 三、邻接表（数组模拟，竞赛标配）

我们复用**单链表静态链表**那一套：

- `h[N]`：头指针数组，`h[i]` 表示顶点 i 的链表头结点下标（初始 -1）
    
- `e[M]`：存储边的终点
    
- `ne[M]`：存储 next 指针
    
- `idx`：当前可用节点下标
    

**加边操作（有向图）**：

```cpp

void add(int a, int b) {
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}
```
**无向图**：调用两次 `add(a,b); add(b,a);`

**遍历顶点 u 的所有出边**：

```cpp

for (int i = h[u]; i != -1; i = ne[i]) {
    int v = e[i];   // v 是 u 的邻接点
    // ...
}
```
🔴 **易错点**：

- **`h` 数组必须初始化为 -1**（全局变量默认 0，但 0 是合法下标，必须手动 memset）。
    
- **边数 M**：无向图记得开 2 倍！
    
- **节点编号**：通常从 1 开始，但数组下标从 1 存即可。
    

🟢 **记忆口诀**：“**邻接表，三数组；h 当头，e 存点，ne 连下家，idx 跟着走。**”

---

# 第四部分 · 树与图的遍历

## 一、深度优先遍历（DFS）

```cpp

void dfs(int u) {
    st[u] = true;   // 标记已访问
    for (int i = h[u]; i != -1; i = ne[i]) {
        int v = e[i];
        if (!st[v]) dfs(v);
    }
}
```
**应用**：求子树大小、树的重心、连通块等。

---

## 二、树的重心 —— 一次 DFS 的经典应用

**定义**：删除树中某个节点后，剩余各个连通块中节点数的**最大值**。  
**重心**：使这个最大值**最小**的节点（可能有多个）。

### 2.1 核心思想

我们对每个节点 `u`，计算**删除 u 后**各连通块的大小：

1. u 的每一个子节点 `v` 对应的子树大小（通过递归得到）
    
2. 父节点方向的连通块大小 = `总节点数 n - 以 u 为根的子树大小`
    

**删除 u 后的最大连通块大小** = `max( 各个子树大小, n - size[u] )`

我们**遍历所有节点**，取这个最大值的最小值。

### 2.2 代码实现

```cpp

const int N = 100010, M = N * 2;
int h[N], e[M], ne[M], idx;
bool st[N];
int ans = N;        // 存储答案（最小化最大连通块）
int n;
int dfs(int u) {
    st[u] = true;
    int size = 1;      // 当前子树大小（包括 u 自己）
    int max_part = 0;  // 删除 u 后的最大连通块大小
    
    for (int i = h[u]; i != -1; i = ne[i]) {
        int v = e[i];
        if (!st[v]) {
            int s = dfs(v);      // 子树 v 的大小
            size += s;
            max_part = max(max_part, s);   // 子节点方向的连通块
        }
    }
    max_part = max(max_part, n - size);    // 父节点方向的连通块
    ans = min(ans, max_part);              // 更新全局答案
    
    return size;
}
```
🔴 **易错点**：

- **`st[]` 必须在递归前标记**，防止走回头路（树是无向图）。
    
- **`max_part` 既要考虑子节点，也要考虑父节点**。
    
- **返回值是子树大小**，不是答案。
    

🟢 **记忆口诀**：“**重心 DFS 三行半：递归子树累 size，子父最大取个 max，全局 ans 更新小。**”

---

# 第五部分 · 拓扑排序 —— 有向无环图的线性化

## 一、定义与性质

**拓扑序列**：对于有向图，将节点排成一排，使得每条边 `u→v`，`u` 都在 `v` 的左边。  
**存在条件**：图必须是有向无环图（DAG）。

**性质**：DAG 至少有一个入度为 0 的点。  
（反证法：如果所有点入度 > 0，沿着入边回溯，n+1 个点必成环）

---

## 二、算法步骤（BFS 版）

1. 统计所有点的入度 `d[i]`。
    
2. 将所有入度为 0 的点入队。
    
3. 当队列不空：
    
    - 取出队头 `t`
        
    - 输出 `t`（或存储到拓扑序数组）
        
    - 遍历 `t` 的所有出边 `t→j`，将 `d[j]--`，如果 `d[j] == 0`，则入队。
        
4. 如果输出的节点数 < 总节点数，说明有环。
    

```cpp

int d[N];   // 入度
vector<int> topsort;
bool topo() {
    queue<int> q;
    for (int i = 1; i <= n; i++)
        if (d[i] == 0) q.push(i);
    
    while (q.size()) {
        int t = q.front(); q.pop();
        topsort.push_back(t);
        for (int i = h[t]; i != -1; i = ne[i]) {
            int j = e[i];
            d[j]--;
            if (d[j] == 0) q.push(j);
        }
    }
    return topsort.size() == n;
}
```
🔴 **易错点**：

- **删边**的本质是 `d[j]--`，不是真的删除邻接表的节点。
    
- **入度数组**需要在加边时维护，`add(a,b)` 时 `d[b]++`。
    
- **多解**：入度为 0 的点可能不止一个，拓扑序不唯一。
    

🟢 **记忆口诀**：“**拓扑排序找 DAG，入度为 0 先入队；删边减入度，零度再入队，计数不足环已现。**”

---

# 📊 本章知识小结 —— 考试前夜必看

|知识点|核心思想|零基础理解锚点|易错点|难度|
|---|---|---|---|---|
|**DFS 全排列**|递归枚举，回溯恢复|占座还座|忘记恢复现场|★★★|
|**八皇后（全排列式）**|按行枚举，列+对角线剪枝|列、主副对角|对角线下标偏移|★★★★★|
|**BFS 最短路**|队列层层扩展，首次即最短|波纹扩散|未标记距离、出界|★★★★|
|**八数码 BFS**|状态图，字符串判重|拼图游戏|恢复交换、一维转二维|★★★★★|
|**邻接表存储**|h[], e[], ne[], idx|静态链表|无向图开双倍、h 初始化|★★★|
|**树的重心**|一次 DFS 计算子树大小|砍树看最大块|父节点连通块计算|★★★★★|
|**拓扑排序**|入度为零入队，删边减度|修课顺序|入度维护、环检测|★★★★|

---

# 🎓 写在最后：搜索与图论 —— 算法世界的“任督二脉”

如果你能独立写出**全排列的 DFS**，你已经掌握了递归与回溯的精髓。  
如果你能调出**八数码的 BFS**，你已经能处理任意状态图的最短路。  
如果你能一次 DFS 搞定**树的重心**，你已经吃透了树的遍历与子问题分解。  
如果你能**手写邻接表 + 拓扑排序**，你已经迈入了图论的大门。

**接下来的路**：

- 最短路（Dijkstra、Bellman-Ford、Floyd）
    
- 最小生成树（Prim、Kruskal）
    
- 二分图（染色法、匈牙利算法）
    

**但请先确保**：本章的每一道例题，你都亲手敲过三遍以上；每一个易错点，你都亲眼见过它导致程序崩溃的样子。
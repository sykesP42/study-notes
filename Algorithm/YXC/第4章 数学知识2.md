# 第四章 数学知识（二）—— 从欧拉函数到中国剩余定理，数论的进阶之路

**献给所有被 φ、逆元、同余方程组绕晕过的初学者**

> 🔴 **阅读提示**：本章延续**零基础友好型**写作风格——每个知识点先用**生活故事**引入，再用**代码逐行拆解**，最后用**易错点 + 记忆口诀**固化。  
> 🎯 **目标**：学完本章，你将彻底掌握**欧拉函数的定义与计算**、**线性筛法求欧拉函数**、**欧拉定理与费马小定理**、**快速幂**、**乘法逆元**、**扩展欧几里得算法**以及**中国剩余定理**。从此数论不再是“天书”。

---

# 📌 开篇：数论的第二层 —— 从“质数”到“互质”

上一章我们学习了质数、约数、最大公约数。  
这一章，我们将围绕一个核心概念展开：**互质**。

- 欧拉函数：**1~n 中有多少个数与 n 互质？**
    
- 欧拉定理：**若 a,n 互质，则 a^φ(n) ≡ 1 (mod n)** —— 这是模运算的“周期表”。
    
- 费马小定理：欧拉定理在 n 为质数时的特例。
    
- 逆元：**模意义下的倒数**，解决除法取模问题。
    
- 扩展欧几里得：求解 ax + by = gcd(a,b) 的通法。
    
- 中国剩余定理：**解同余方程组**，古人的智慧。
    

**准备好了吗？我们开始攀登数论的第二座山。**

---

# 第一部分 · 欧拉函数 —— 互质个数的计数器

## 一、什么是欧拉函数？

> **定义**：对于正整数 n，**欧拉函数 φ(n)** 表示 1 ~ n 中与 n **互质**的整数的个数。  
> 特别地，φ(1) = 1（1 与自身互质）。

**生活类比**：你有一个密码锁，有 n 个刻度。能和你共享密钥（互质）的人有多少个？——欧拉函数告诉你答案。

**示例**：

- φ(6) = 2，因为 1~6 中与 6 互质的数只有 1 和 5。
    
- φ(7) = 6，因为 7 是质数，1~6 都与 7 互质。
    

---

## 二、欧拉函数的计算公式

若 n 的质因数分解为：

n=p1a1⋅p2a2⋯pkakn=p1a1​​⋅p2a2​​⋯pkak​​

则

φ(n)=n×(1−1p1)×(1−1p2)×⋯×(1−1pk)φ(n)=n×(1−p1​1​)×(1−p2​1​)×⋯×(1−pk​1​)

**记忆**：**n 乘以每个不同质因子的 (1 - 1/p)**。

**为什么是指数无关？**  
欧拉函数只关心**质因子的种类**，不关心次数。因为若 p^a 与 p^(a-1) 的互质数个数有固定比例关系，最终化简后与指数无关。

**示例**：n = 12 = 2² × 3，  
φ(12) = 12 × (1 - 1/2) × (1 - 1/3) = 12 × 1/2 × 2/3 = 4。  
验证：1~12 中与 12 互质的数：1,5,7,11 → 4 个。

---

## 三、公式的由来 —— 容斥原理

我们可以用容斥原理理解这个公式：

1. 从 1 ~ n 中**去掉**所有 p₁ 的倍数，这些倍数有 n/p₁ 个。
    
2. 再去掉所有 p₂ 的倍数，有 n/p₂ 个。  
    但 p₁ 和 p₂ 的公倍数被减了两次，需要**加回**一次：加 n/(p₁p₂)。
    
3. 再去掉 p₃ 的倍数……以此类推。
    

最终，经过容斥展开，你会得到：

n−∑npi+∑npipj−∑npipjpk+⋯n−∑pi​n​+∑pi​pj​n​−∑pi​pj​pk​n​+⋯

这正是 n × ∏(1 - 1/pᵢ) 的展开式。

**结论**：欧拉函数公式是容斥原理的**闭式结果**，直接记住即可，证明不要求掌握。

---

## 四、特殊情况

- 若 p 是质数，则 φ(p) = p - 1。
    
- 若 p 是质数，则 φ(p^a) = p^a - p^(a-1) = p^a × (1 - 1/p)。（公式依然成立）
    
- φ(1) = 1（定义）。
    

---

## 五、代码实现 —— 求单个数的欧拉函数

我们只需要对 n 做**质因数分解**，边分解边套公式。

**技巧**：为了避免浮点数，将公式改写成：

φ(n)=n×∏p∣np−1pφ(n)=n×p∣n∏​pp−1​

在代码中，我们先令 res = n，然后对每个质因子 p：  
`res = res / p * (p - 1)`（先除后乘，保证整除且不溢出）。


```cpp

int phi(int x) {
    int res = x;
    for (int i = 2; i <= x / i; i++) {
        if (x % i == 0) {
            res = res / i * (i - 1);   // 公式应用
            while (x % i == 0) x /= i; // 除尽该质因子
        }
    }
    if (x > 1) res = res / x * (x - 1); // 剩余的大质因子
    return res;
}
```
🔴 **易错点**：

- **循环条件**：`i <= x / i`，防止溢出，且能覆盖到 √x。
    
- **除尽因子**：一定要用 `while` 把所有该因子除光，否则会重复处理。
    
- **最后剩余因子**：若 x > 1，说明还剩一个大于 √x 的质因子，需要处理。
    
- **整数运算顺序**：`res / i * (i-1)` 保证中间结果是整数，且先除后乘避免溢出。
    

🟢 **记忆口诀**：“**欧拉函数公式美，n 乘所有 (p-1)/p；质因数分解一边过，除尽再判剩因子。**”

**时间复杂度**：O(√n)，n ≤ 2×10⁹ 时完全可行。

---

# 第二部分 · 线性筛法求欧拉函数 —— 批量生产的艺术

## 一、为什么需要筛法求欧拉函数？

如果题目要求**求 1~n 所有数的欧拉函数**（n = 10⁶ 甚至 10⁷），对每个数单独分解质因数 O(√n) 就太慢了。  
我们需要**在线性筛素数的同时，用递推关系计算出每个数的欧拉函数**，达到 O(n)。

---

## 二、线性筛求欧拉函数的三种情况

我们复用线性筛的框架，设 `primes[]` 存储已筛出的质数，`phi[]` 存储欧拉函数值。

### 📌 情况 1：i 是质数

显然，φ(i) = i - 1。

### 📌 情况 2：i % primes[j] == 0（primes[j] 是 i 的最小质因子）

设 `m = primes[j] * i`。  
因为 primes[j] 整除 i，所以 i 的质因子集合包含 primes[j]，且 i 的最小质因子也是 primes[j]。  
那么 m 的质因子种类与 i **完全相同**，只是 primes[j] 的指数多 1。  
根据欧拉公式，φ(m) = m × ∏(1-1/p) = (primes[j] × i) × ∏(1-1/p) = primes[j] × φ(i)。  
（因为 φ(i) = i × ∏(1-1/p)）

**结论**：**φ(primes[j] × i) = primes[j] × φ(i)**。

### 📌 情况 3：i % primes[j] != 0

此时 primes[j] 是 m 的**新质因子**，且 primes[j] 小于 i 的所有质因子。  
那么 m 的质因子种类比 i **多了一个 primes[j]**。  
于是：  
φ(m) = m × ∏(1-1/p) = (primes[j] × i) × [∏_{p|i}(1-1/p)] × (1-1/primes[j])  
= primes[j] × φ(i) × (1-1/primes[j])  
= φ(i) × (primes[j] - 1)。

**结论**：**φ(primes[j] × i) = φ(i) × (primes[j] - 1)**。

---

## 三、代码模板

```cpp

const int N = 1000010;
int primes[N], cnt;
int phi[N];
bool st[N];
void get_phi(int n) {
    phi[1] = 1;                 // 定义
    for (int i = 2; i <= n; i++) {
        if (!st[i]) {
            primes[cnt++] = i;
            phi[i] = i - 1;     // 质数
        }
        for (int j = 0; primes[j] <= n / i; j++) {
            int m = primes[j] * i;
            st[m] = true;
            if (i % primes[j] == 0) {
                phi[m] = phi[i] * primes[j];   // 情况 2
                break;
            } else {
                phi[m] = phi[i] * (primes[j] - 1); // 情况 3
            }
        }
    }
}
```
🔴 **易错点**：

- **初始化**：φ(1) = 1 必须单独设置。
    
- **循环条件**：`primes[j] <= n / i` 防止溢出，且保证 m ≤ n。
    
- **break**：当 i % primes[j] == 0 时，primes[j] 是 i 的最小质因子，后续 primes[j] 不再是 m 的最小质因子，必须 break，保证线性。
    
- **数据类型**：φ 值可能很大，但 n ≤ 10⁷ 时 int 足够（φ(n) < n）。若求前缀和，需用 long long。
    

---

## 四、应用 —— 求 1~n 欧拉函数之和

```cpp

long long sum = 0;
for (int i = 1; i <= n; i++) sum += phi[i];
```
---

# 第三部分 · 欧拉定理与费马小定理 —— 模运算的周期律

## 一、欧拉定理

> **定理**：若 a 与 n 互质（gcd(a,n)=1），则
> 
> aφ(n)≡1(modn)aφ(n)≡1(modn)

**生活类比**：钟表有 n 个刻度，你每次走 a 格，走 φ(n) 步后，你一定会回到起点。

**示例**：取 a = 5, n = 6，φ(6)=2，5² = 25 ≡ 1 mod 6 ✅。

**证明思路**（了解即可）：

1. 取 1~n 中所有与 n 互质的数：x₁, x₂, …, x_φ(n)。
    
2. 将它们每个乘以 a（模 n），得到另一组数：a·x₁, a·x₂, …, a·x_φ(n)。
    
3. 可以证明这组数仍然与 n 互质，且两两不同模 n。
    
4. 因此这组数是 x₁,…,x_φ(n) 的一个**排列**。
    
5. 将两组数相乘：∏(a·x_i) ≡ ∏x_i (mod n)，即 a^φ(n)·∏x_i ≡ ∏x_i (mod n)。
    
6. 因为每个 x_i 都与 n 互质，∏x_i 也与 n 互质，可以两边消去，得 a^φ(n) ≡ 1 (mod n)。
    

---

## 二、费马小定理

> **定理**：若 p 为质数，且 a 不是 p 的倍数（即 gcd(a,p)=1），则
> 
> ap−1≡1(modp)ap−1≡1(modp)

**这是欧拉定理的特例**：当 n = p 时，φ(p) = p-1。

**示例**：a = 3, p = 7，3⁶ = 729 ≡ 1 mod 7 ✅。

**应用**：快速幂求逆元（见后）。

---

# 第四部分 · 快速幂 —— 指数运算的加速器

## 一、问题

计算 a^k mod p，其中 a,k,p 都可高达 10⁹。  
直接循环 k 次？k=10⁹ 时不可行。

## 二、核心思想 —— 反复平方

将 k 写成二进制：k = 2⁰·b₀ + 2¹·b₁ + … + 2^{t}·b_t，其中 bᵢ ∈ {0,1}。  
则

ak=a20b0×a21b1×⋯×a2tbtak=a20b0​×a21b1​×⋯×a2tbt​

我们只需要**预处理** a^{2⁰}, a^{2¹}, a^{2²}, … (mod p)，每个都是前一个的平方取模。  
然后根据 k 的二进制位，选择对应的乘入结果。

**时间复杂度**：O(log k)。

---

## 三、代码模板

```cpp

typedef long long LL;
LL qmi(LL a, LL k, LL p) {
    LL res = 1 % p;          // 防止 p=1 时结果为 0
    while (k) {
        if (k & 1) res = res * a % p;   // 当前位为1，乘入
        a = a * a % p;                  // 平方
        k >>= 1;                       // 右移
    }
    return res;
}
```
🔴 **易错点**：

- **初始化 res = 1 % p**：当 p=1 时，任何数 mod 1 = 0，需要特殊处理。但竞赛中 p 通常很大，直接 `res = 1` 也可，严谨写法为 `res = 1 % p`。
    
- **乘法溢出**：a * a 可能超过 int 范围，必须用 long long 或快速乘（一般 long long 足够）。
    
- **取模时机**：每次乘法后立即取模，保持数值在范围内。
    

🟢 **记忆口诀**：“**快速幂，二进展；位为1，乘入果；底平方，位右移。**”

---

# 第五部分 · 乘法逆元 —— 模意义下的倒数

## 一、定义

在模 p 意义下，若存在 x 使得

b⋅x≡1(modp)b⋅x≡1(modp)

则称 x 为 b 模 p 的**乘法逆元**，记作 b⁻¹ (mod p)。

**作用**：模运算中不能直接除，但可以乘以逆元：  
a / b ≡ a × b⁻¹ (mod p)。

---

## 二、费马小定理求逆元（模数为质数）

若 p 是质数，且 b 不是 p 的倍数（即 gcd(b,p)=1），则

bp−1≡1(modp)⇒b⋅bp−2≡1(modp)bp−1≡1(modp)⇒b⋅bp−2≡1(modp)

因此 **b⁻¹ ≡ b^{p-2} (mod p)**。

**代码**：直接用快速幂计算 `qmi(b, p-2, p)`。

**注意**：必须保证 p 是质数且 b % p != 0，否则逆元不存在（输出 "impossible"）。

```cpp

if (b % p == 0) cout << "impossible" << endl;
else cout << qmi(b, p-2, p) << endl;
```
---

## 三、扩展欧几里得求逆元（模数任意）

当 p 不是质数，但 b 与 p 互质时，逆元存在。  
解方程 `b*x ≡ 1 (mod p)` 等价于 `b*x + p*y = 1`。  
使用扩展欧几里得算法求出一组 (x,y)，x 就是逆元（可能为负，调整到 0~p-1）。

**此部分在下文扩展欧几里得中详述**。

---

# 第六部分 · 扩展欧几里得算法 —— 求解 ax+by=gcd(a,b)

## 一、裴蜀定理（贝祖定理）

> 对于任意整数 a,b，存在整数 x,y 使得
> 
> ax+by=gcd⁡(a,b)ax+by=gcd(a,b)
> 
> 并且这个等式右边是能表示的最小正整数。

**生活类比**：你有两种面额的硬币 a 元和 b 元，你可以支付任意金额，但最小能支付的**正金额**就是 gcd(a,b) 元（当然，要找零）。定理告诉你，一定能凑出 gcd(a,b) 元。

---

## 二、算法推导（递归）

我们想求 `ax + by = gcd(a,b)` 的一组解。

1. **递归边界**：当 b = 0 时，gcd(a,0) = a，显然取 `x = 1, y = 0` 即可。
    
2. **递归过程**：  
    设我们已求得 `b*x' + (a % b)*y' = gcd(b, a%b)` 的解 (x', y')。  
    注意 `gcd(a,b) = gcd(b, a%b)`。  
    将 `a % b = a - (a/b)*b` 代入：
    
    bx′+(a−⌊a/b⌋b)y′=gcd⁡bx′+(a−⌊a/b⌋b)y′=gcd
    
    整理：
    
    ay′+b(x′−⌊a/b⌋y′)=gcd⁡ay′+b(x′−⌊a/b⌋y′)=gcd
    
    因此当前解为：
    
    x=y′,y=x′−⌊a/b⌋y′x=y′,y=x′−⌊a/b⌋y′

**代码**：

```cpp

int exgcd(int a, int b, int &x, int &y) {
    if (!b) {
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);   // 注意这里交换了 x,y
    y -= a / b * x;
    return d;
}
```
**为什么传入 (y,x)**？因为递归后，x 对应原式子的 y'，y 对应原式子的 x'，这样交换后，回溯时 y -= a/b * x 就对应公式的 `y = x' - (a/b) y'`。

**返回值**：d = gcd(a,b)。

---

## 三、应用1 —— 求线性同余方程

求解 `a x ≡ b (mod m)`。

**转化**：`a x + m y = b`。

**解的存在条件**：令 d = gcd(a,m)，若 d | b，则有解，否则无解。

**求解步骤**：

1. 用 `exgcd(a, m, x0, y0)` 得到 `a x0 + m y0 = d`。
    
2. 两边乘以 `b/d`：`a * (x0 * (b/d)) + m * (y0 * (b/d)) = b`。  
    因此特解 `x = x0 * (b/d) % m`（注意模 m）。
    
3. 通解：`x = x0 + k * (m/d)`，k ∈ Z。
    

**代码**：

```cpp

int d = exgcd(a, m, x, y);
if (b % d != 0) 无解;
else {
    x = x * (b / d) % m;
    // 调整到非负
    x = (x % m + m) % m;
    cout << x << endl;
}
```
---

## 四、应用2 —— 求逆元（模数任意）

解 `a x ≡ 1 (mod m)`，即 `a x + m y = 1`。  
要求 gcd(a,m) = 1，否则无逆元。

直接用 exgcd 求出的 x 即为逆元，再取模调整为正。

```cpp

int inv(int a, int m) {
    int x, y;
    int d = exgcd(a, m, x, y);
    if (d != 1) return -1;   // 逆元不存在
    return (x % m + m) % m;
}
```
---

# 第七部分 · 中国剩余定理（CRT） —— 解同余方程组

## 一、问题描述

给定 k 个线性同余方程：

{x≡a1(modm1)x≡a2(modm2)⋮x≡ak(modmk)⎩⎨⎧​x≡a1​(modm1​)x≡a2​(modm2​)⋮x≡ak​(modmk​)​

其中 **模数 m₁, m₂, …, mₖ 两两互质**。  
求 x 的最小非负整数解。

**生活类比**：你不知道具体数字，但知道它除以 3 余 2，除以 5 余 3，除以 7 余 2 —— 这就是“韩信点兵”问题。

---

## 二、构造解法

1. 令 `M = m₁ × m₂ × … × mₖ`。
    
2. 对每个 i，令 `M_i = M / m_i`。
    
3. 由于 m_i 与 M_i 互质（因为 m_i 与其它模数互质），存在 M_i 模 m_i 的逆元 `t_i`，使得 `M_i * t_i ≡ 1 (mod m_i)`。
    
4. 则方程组的**一个特解**为：
    

$$x=∑i=1kai⋅Mi⋅tix=i=1∑k​ai​⋅Mi​⋅ti​$$

5. **通解**：`x = x0 + k·M`，k ∈ Z。最小非负解为 x0 mod M。
    

**验证**：模 m_i 时，除了第 i 项，其他项的 M_j 都含有因子 m_i，因此模 m_i 为 0；第 i 项 $$a_i·M_i·t_i ≡ a_i·1 ≡ a_i (mod m_i)。$$

---

## 三、代码实现

```cpp

LL crt(int k, LL a[], LL m[]) {
    LL M = 1, res = 0;
    for (int i = 0; i < k; i++) M *= m[i];
    for (int i = 0; i < k; i++) {
        LL Mi = M / m[i];
        LL ti = inv(Mi, m[i]);   // 扩展欧几里得求逆元
        res = (res + a[i] * Mi % M * ti) % M;
    }
    return res;
}
```
🔴 **易错点**：

- **模数必须两两互质**，否则该公式不适用（需用扩展中国剩余定理）。
    
- **乘法可能溢出**：M 可能很大（乘积可能超过 long long 范围），但题目通常会保证 M 在 long long 内，若超出需用 __int128 或特殊处理。
    
- **逆元存在性**：由于互质，逆元一定存在，直接用 exgcd 求。
    

---

# 📊 本章知识小结 —— 考试前夜必看

|知识点|核心思想|零基础理解锚点|易错点|难度|
|---|---|---|---|---|
|**欧拉函数 φ(n)**|1~n 中与 n 互质的个数|n 乘 (1-1/p)|质因数分解除尽因子|★★★|
|**筛法求 φ**|线性筛递推|质数：p-1；整除：×p；不整除：×(p-1)|break 条件|★★★★★|
|**欧拉定理**|a^φ(n) ≡ 1 (mod n)|互质时的周期|条件：互质|★★★|
|**费马小定理**|a^(p-1) ≡ 1 (mod p)|质数特例|p 为质数，a 不是 p 倍数|★★★|
|**快速幂**|二进制拆分|反复平方|乘法溢出、1%p|★★★|
|**乘法逆元**|b*x ≡ 1 (mod p)|模倒数|p 质数时 b^(p-2)；否则 exgcd|★★★★|
|**扩展欧几里得**|ax+by=gcd(a,b)|递归交换系数|递归回溯参数对应|★★★★★|
|**线性同余方程**|ax ≡ b (mod m)|转化为 exgcd|无解判断（d \| b）|★★★★|
|**中国剩余定理**|模互质方程组|分别乘逆元相加|模乘积可能溢出|★★★★|

---

# 🎓 写在最后：数论的“三大支柱”

本章的知识点环环相扣：

- **欧拉函数** → 欧拉定理 → 费马小定理 → 快速幂求逆元（模质数）
    
- **扩展欧几里得** → 任意模数求逆元 → 解线性同余方程 → 中国剩余定理
    

它们构成了竞赛数论的核心工具包。  
**不要死记硬背，要理解推导过程**，因为题目往往不是直接考模板，而是要求你**灵活组合**这些工具。

**给你的硬核建议**：

1. **欧拉函数**：分别写单个求法和筛法求法，对比运行时间。
    
2. **快速幂**：自己推演 4⁵ mod 10 的二进制过程，理解位运算。
    
3. **扩展欧几里得**：手动模拟 exgcd(6,15) 的递归栈，验证回溯结果。
    
4. **中国剩余定理**：解一个三方程的手算题，再用代码验证。
    
5. **综合应用**：尝试做一道“求逆元 + 线性同余方程”的题目。
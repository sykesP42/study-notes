# 第七章 时空复杂度分析 —— 从“超时”到“AC”的最后一公里



> 🔴 **阅读提示**：本章是算法基础课的收官之章，不讲新算法，只讲**如何评估算法的效率**。  
> 你将学会：**看到数据范围 → 秒出该用什么算法**；**写完代码 → 估算能否通过**。  
> 这是从“会写代码”到“会写能AC的代码”的**关键一跃**。

---

# 📌 开篇：为什么我们需要时空复杂度分析？

你兴冲冲写完一道题，样例过了，提交上去——  
**TLE**（超时） 或 **MLE**（内存超限）。  
然后你开始盲目地优化：把 `cin` 改成 `scanf`，把 `vector` 改成数组……运气好过了，运气不好还是超时。

**真正的问题不是输入输出不够快，而是算法选错了！**  
`O(n²)` 的算法在 `n = 10⁵` 时注定超时，再怎么优化常数也没用。

**时空复杂度分析**就是让你**在写代码之前**就知道这个算法能不能跑过，该不该换思路。

**竞赛时间限制通常 1~2 秒**，C++ 操作次数 ≈ **10⁷ ~ 10⁸**。  
这是你脑子里必须刻进去的**基准线**。

---

# 第一部分 · 时间复杂度 —— 大O的世界

## 一、什么是时间复杂度？

时间复杂度不是程序实际的运行秒数，而是**随着数据规模 n 增大，算法执行时间的增长趋势**。  
我们用 **大O表示法** 来描述这种增长关系。

**常见复杂度排序（从快到慢）**：


```text

O(1) < O(log n) < O(√n) < O(n) < O(n log n) < O(n²) < O(n³) < O(2ⁿ) < O(n!)
```
**图例**（想象一下）：

- O(1)：无论 n 多大，瞬间完成。
    
- O(log n)：n 翻倍，时间只增加常数（二分查找）。
    
- O(n)：n 从 1000 到 2000，时间也翻倍（线性扫描）。
    
- O(n²)：n 翻倍，时间**变成4倍**（双重循环）。
    
- O(2ⁿ)：n 增加1，时间**翻倍**（指数爆炸）。
    

---

## 二、数据范围反推算法 —— 竞赛生存法则

**这是本章最最最重要的内容**。  
你不需要背诵所有算法复杂度，但必须建立**数据规模 → 允许复杂度**的条件反射。

**以下表格务必刻进DNA**：

|数据规模 n|允许的时间复杂度|典型算法/数据结构|
|---|---|---|
|**n ≤ 30**|指数级，O(2ⁿ) 或 O(n!)|DFS + 剪枝、状态压缩DP|
|**n ≤ 100**|O(n³)|Floyd、三维DP|
|**n ≤ 1000**|O(n²) 或 O(n² log n)|朴素Dijkstra、二维DP、朴素Prim|
|**n ≤ 10⁴**|O(n√n)|块状链表、莫队算法（常数小）|
|**n ≤ 10⁵**|**O(n log n)**|排序、堆优化Dijkstra、线段树/树状数组、二分答案|
|**n ≤ 10⁶**|O(n) 或小常数 O(n log n)|双指针、KMP、线性筛、并查集|
|**n ≤ 10⁷**|O(n)|线性算法，常数必须极小|
|**n ≤ 10⁹**|O(√n)|试除法判断质数、分解质因数|
|**n ≤ 10¹⁸**|O(log n)|欧几里得算法、快速幂|

🔴 **易错点**：

- 不要只看 n，还要看 m（边数）等维度。
    
- 对数复杂度 `log n` 的底数通常不重要，因为 log₂n 和 log₁₀n 只差常数。
    
- 实际运行速度还和**常数因子**有关：树状数组比线段树快3~5倍，快速排序比归并排序常数小。
    

🟢 **记忆口诀**：“**30指2ⁿ，100立方法，千次平方万根号，十万对数百万线，亿次根号，十亿对数。**”

---

## 三、分档详解 —— 每一档都配上例题

### 1. n ≤ 30 —— 指数级（状压DP / DFS剪枝）

**为什么？**  
2³⁰ ≈ 10⁹，刚好压着 1 秒边界，加上剪枝往往能过。  
30! 是天文数字，但 DFS 剪枝可大幅减少。

**典型例题**：

- 最短Hamilton路径（n=20） → 状态压缩DP，O(2ⁿ × n²)
    
- n 皇后问题（n=13 左右） → DFS + 剪枝
    
- 蒙德里安的梦想（n,m≤11） → 状压DP，O(2²ⁿ × n)
    
- 数独、八数码 → 搜索 + 剪枝 / IDA*
    

---

### 2. n ≤ 100 —— O(n³)

**为什么？**  
100³ = 1e6，加上常数 ≈ 几百万次操作，1 秒内稳稳跑完。  
甚至 O(n³ log n) 也勉强可过（1e6 * log100 ≈ 7e6）。

**典型例题**：

- Floyd 求最短路（n≤200 也可）
    
- 三维 DP（如石子合并 n=300 时 O(n³)=2.7e7 仍可）
    
- 朴素高斯消元
    

---

### 3. n ≤ 1000 —— O(n²) 或 O(n² log n)

**为什么？**  
1000² = 1e6，非常安全。  
即使 n=2000，4e6 也可接受。  
加上 log 因子（如 O(n² log n) ≈ 1e7）仍在边界内。

**典型例题**：

- 朴素 Dijkstra（邻接矩阵）
    
- 最长上升子序列 O(n²)
    
- 朴素 Prim
    
- 二维前缀和预处理 O(n²)
    
- 动态规划（如背包 n×m ≤ 1e6 时）
    

---

### 4. n ≤ 10⁵ —— O(n log n) 主场

**为什么？**  
n log n ≈ 1e5 × 17 = 1.7e6，安全。  
即使 n=2e5，log≈18，3.6e6 也轻松。

**典型算法**：

- 排序（快排、归并、堆排）
    
- 堆优化 Dijkstra（O(m log n)，m≈n 时）
    
- 线段树 / 树状数组（单点/区间）
    
- 二分答案（每次 check O(n)，总 O(n log n)）
    
- KMP、AC 自动机（线性，但常数略大）
    

---

### 5. n ≤ 10⁶ —— O(n) 或 小常数 O(n log n)

**为什么？**  
10⁶ 次循环 = 1e6，安全。  
O(n log n) 时 1e6 × 20 = 2e7，仍可，但常数不能大。

**典型算法**：

- 双指针、滑动窗口
    
- KMP（严格 O(n)）
    
- 线性筛素数
    
- 并查集（路径压缩 + 按秩合并 ≈ O(α(n))）
    
- 单调栈、单调队列
    
- 哈希表（平均 O(1)）
    

---

### 6. n ≤ 10⁹ —— O(√n)

**为什么？**  
√1e9 ≈ 31623，约 3 万次操作，非常快。

**典型例题**：

- 试除法判质数
    
- 试除法分解质因数
    
- 试除法求约数集合
    

---

### 7. n ≤ 10¹⁸ —— O(log n)

**为什么？**  
log₂(1e18) ≈ 60，常数十倍也才几百次。

**典型算法**：

- 欧几里得算法（gcd）
    
- 快速幂
    
- 二分查找（但需有序）
    
- 矩阵快速幂
    

---

# 第二部分 · 递归算法的时间复杂度 —— 主定理与树形分析

## 一、主定理（Master Theorem）简介

对于形如 `T(n) = a·T(n/b) + O(nᵈ)` 的递推式（a ≥ 1, b > 1）：

- 若 log_b a > d → T(n) = O(n^{log_b a})
    
- 若 log_b a = d → T(n) = O(n^d log n)
    
- 若 log_b a < d → T(n) = O(n^d)
    

**竞赛中用得不多，但归并排序、快速排序可套用**。

**归并排序**：T(n) = 2T(n/2) + O(n)  
a=2, b=2, d=1 → log_2 2 = 1 = d → O(n log n) ✅

**快速排序**：平均情况下 T(n) = 2T(n/2) + O(n) → 同归并，但最坏 O(n²)。

---

## 二、递归树分析法（更直观）

**例：全排列 DFS 的时间复杂度**

- 第一层：1 个节点
    
- 第二层：n 个节点
    
- 第三层：n×(n-1) 个节点
    
- ……
    
- 最后一层（叶子层）：n! 个节点，每个节点输出 O(n)  
    总复杂度 ≈ n × n!（主要来自叶子层）→ **O(n × n!)**  
    加上剪枝后实际运行会少一些，但阶乘级仍只能跑 n≤11。
    

---

# 第三部分 · 常见算法的真实时间复杂度 —— 那些看似 O(n²) 实则 O(n) 的套路

## 一、双指针算法（滑动窗口）

**典型代码**（最长不重复子串）：

```cpp

for (int i = 0, j = 0; i < n; i++) {
    while (j < i && check()) j++;
    // ...
}
```
**看似**双重循环 → O(n²)  
**实则**：j 只增不减，总共移动 ≤ n 次 → **O(n)**

✅ **记忆口诀**：“**双指针，巧分析，内层指针单向移，总步不超 n 次。**”

---

## 二、单调栈 / 单调队列

**看似**：外层循环，内层 while 弹出 → O(n²)  
**实则**：每个元素入栈/出栈一次 → **O(n)**

**KMP 算法**同理：j 最多增加 n 次，也最多回退 n 次 → **O(n)**

---

## 三、并查集（路径压缩）

**单次 find**：看似递归深度可能 O(n)  
**实则**：经过路径压缩，**均摊复杂度 O(α(n))**，α(n) 是反阿克曼函数，增长极慢，n=1e18 时 α(n)≈5。  
**可视为近似 O(1)**。

---

## 四、哈希表

**理论最坏** O(n)（大量冲突）  
**实际概率** ≈ 小行星撞地球，**平均 O(1)**。

**竞赛态度**：只要不是恶意卡哈希（C++ 的 unordered_map 可被卡），放心用；若担心，换 map（O(log n)）或手写哈希。

---

# 第四部分 · 空间复杂度 —— 你的数组开对了吗？

## 一、基本数据类型大小

|类型|字节数|范围（约）|
|---|---|---|
|bool|1|true/false|
|char|1|-128 ~ 127|
|int|4|±2.1e9|
|unsigned int|4|0 ~ 4.2e9|
|long long|8|±9.2e18|
|float|4|7位精度|
|double|8|15位精度|
|指针（32位）|4|-|
|指针（64位）|8|-|

**注意**：`bool` 数组每个元素占 1 字节，不是 1 位！  
`vector<bool>` 可能特化成 1 位，但访问慢且易出错，**慎用**。

---

## 二、空间限制与数组大小估算

**常见空间限制**：64MB、128MB、256MB。  
**公式**：`数组元素个数 = 空间(字节) / 单个元素字节`

**例**：64MB = 64 × 1024 × 1024 ≈ 67,108,864 字节

- int 数组：67e6 / 4 ≈ 1677万
    
- long long 数组：67e6 / 8 ≈ 838万
    
- bool 数组：67e6 / 1 ≈ 6710万
    

**安全原则**：**不要开满**，留 10~20MB 给代码、栈、系统调用。  
通常 **int a[N]** 的 N ≤ 1e7 在 64MB 下是安全的，但最好 ≤ 5e6。

---

## 三、递归的空间消耗

每层递归会占用栈空间（保存局部变量、返回地址）。  
递归深度过大 → **栈溢出**（Stack Overflow）。

**典型问题**：

- 快速排序：递归深度 O(log n)，安全
    
- 归并排序：递归深度 O(log n)，安全
    
- DFS 深度 = n（如链状树）：可能爆栈，需改成栈模拟或 BFS
    

**解决方案**：

- 改用非递归
    
- 编译时加栈空间指令（`-Wl,--stack=16777216`）
    
- 竞赛中通常不会刻意卡递归，但 n=1e5 的链状树递归 DFS 必爆。
    

---

# 第五部分 · 综合例题 —— 把复杂度分析刻进DNA

## 1. 试除法判质数

```cpp

bool is_prime(int n) {
    if (n < 2) return false;
    for (int i = 2; i <= n / i; i++)   // 循环 √n 次
        if (n % i == 0) return false;
    return true;
}
```
**时间复杂度**：O(√n)  
**n=1e9** → 3.1e4 次，完美通过。

---

## 2. 朴素筛法

```cpp

for (int i = 2; i <= n; i++)
    for (int j = i + i; j <= n; j += i)
        st[j] = true;
```
**看似** O(n²)，**实则** O(n log n)（调和级数）。  
**n=1e6** → 约 1e6 × (ln 1e6 + γ) ≈ 1.4e7，可过。

**埃氏筛**（只筛质数倍数）：O(n log log n)，n=1e7 约 1e7 × (log log 1e7≈3) ≈ 3e7，勉强可过。  
**线性筛**：O(n)，n=1e7 约 1e7，轻松。

---

## 3. 最长上升子序列 O(n²)

```cpp

for (int i = 1; i <= n; i++) {
    f[i] = 1;
    for (int j = 1; j < i; j++)
        if (a[j] < a[i])
            f[i] = max(f[i], f[j] + 1);
}
```
**n=1000** → 5e5 次，轻松。  
**n=10⁵** → 5e9 次 → 必 TLE，需 O(n log n) 贪心+二分。

---

## 4. Floyd 算法

```cpp

for (int k = 1; k <= n; k++)
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
```
**n=500** → 1.25e8 次，常数较大，勉强过（需优化常数）。  
**n=200** → 8e6 次，安全。

---

## 5. 全排列 DFS

```cpp

void dfs(int u) {
    if (u == n) { 输出排列; return; }
    for (int i = 1; i <= n; i++)
        if (!st[i]) { path[u] = i; st[i]=true; dfs(u+1); st[i]=false; }
}
```
**时间复杂度**：O(n × n!)  
**n=10** → 10×3628800 ≈ 3.6e7，极限。  
**n=11** → 4e8，超时。  
**n=7** → 5e4，秒过。

---

## 6. 树的重心（一次 DFS）

```cpp

int dfs(int u) {
    st[u] = true;
    int sum = 1, max_part = 0;
    for (int i = h[u]; i != -1; i = ne[i]) {
        int v = e[i];
        if (!st[v]) {
            int s = dfs(v);
            sum += s;
            max_part = max(max_part, s);
        }
    }
    max_part = max(max_part, n - sum);
    ans = min(ans, max_part);
    return sum;
}
```
每个节点访问一次，每条边访问两次 → **O(n + m)** = O(n)（树中 m = n-1）。

---

# 📊 本章知识小结 —— 考试前夜必看

|数据规模|允许复杂度|典型算法|易错点|
|---|---|---|---|
|n ≤ 30|O(2ⁿ), O(n!)|状压DP、DFS剪枝|剪枝不够会超时|
|n ≤ 100|O(n³)|Floyd、三维DP|常数优化（用 int 不用 long long）|
|n ≤ 1000|O(n²)|朴素Dijkstra、朴素LIS|注意内层循环优化|
|n ≤ 10⁵|**O(n log n)**|排序、堆优化Dijkstra|必须用 scanf/printf|
|n ≤ 10⁶|O(n)|双指针、KMP、线性筛|常数不能大|
|n ≤ 10⁹|O(√n)|试除法|循环条件 `i <= n/i`|
|n ≤ 10¹⁸|O(log n)|gcd、快速幂|用 long long|

**递归算法**：主定理 or 树形分析。  
**双指针/单调栈**：看似 O(n²) 实为 O(n)，需理解**指针单向移动**。  
**空间计算**：64MB ≈ 1600万 int，递归深度别爆栈。

---

# 🎓 写在最后：复杂度分析是算法竞赛的“第六感”

如果说刷题是练招式，那么时空复杂度分析就是练**内功**。  
内功深厚者，看到数据范围的那一刻，脑中就已经筛选掉了 80% 的错误算法，**不再盲目试错**。

**给你的硬核建议**：

1. **把数据范围-算法对应表打印出来**，贴桌上，每天看三遍。
    
2. **每做一道题，先看数据范围，猜算法**，然后再看题解验证。
    
3. **故意写一个复杂度超标的算法提交一次**，亲眼看看 TLE，加深记忆。
    
4. **用 `clock()` 或 `<chrono>` 计时**，感受 O(n) 和 O(n²) 的真实差距。
    

**当你看到 n=10⁵ 就条件反射“必须 O(n log n)”时，你已出师。**
# 第二章 数据结构（一）—— 从“静态链表”到“KMP”，手把手带你用数组模拟一切

---

# 📌 开篇：为什么竞赛中不用指针，不用 STL？

很多同学学数据结构时，第一个接触的是：


```cpp

struct Node {
    int val;
    Node *next;
};
```
然后用 `new Node()` 动态创建节点。  
**但在算法竞赛中，这几乎是被禁止的**——因为 `new` 操作非常慢，当节点数量达到 10⁵ ~ 10⁶ 时，仅创建节点就可能超时。

✅ **竞赛标准做法**：**用数组模拟**（静态链表）

- 预先开好足够大的数组，用下标代替指针
    
- 没有 `new/delete`，没有内存泄漏
    
- 速度极快，代码简洁
    

**这就是本章的灵魂——所有数据结构都用数组模拟，没有例外。**

---

# 一、单链表（静态链表） —— 邻接表的基石

## 1.1 为什么需要单链表？

- 邻接表：存储图、树（每个顶点一个链表）
    
- 需要频繁在**头部插入**（头插法 O(1)）
    
- 不需要随机访问，也不需要双向遍历
    

## 1.2 数组模拟的核心结构

我们只用**两个数组 + 两个变量**：

|名称|作用|类比指针|
|---|---|---|
|`e[N]`|存储节点的**值**|节点的数据域|
|`ne[N]`|存储节点的**下一个节点下标**|节点的 next 指针|
|`head`|存储**头结点的下标**|头指针|
|`idx`|当前可用的**新节点下标**|内存分配指针|

**初始化**：

cpp

int head = -1;   // 空链表，-1 表示 nullptr
int idx = 0;     // 从 0 号节点开始分配

**空指针表示**：统一用 **`-1`**。

---

## 1.3 头插法 —— 算法题中出现频率 80%

**故事**：你要在队伍最前面插一个新同学，怎么办？

1. 新同学的“下一个”指向原来的队首
    
2. 队首标记改为新同学
    

**代码**：

```cpp

void add_to_head(int x) {
    e[idx] = x;          // 存入值
    ne[idx] = head;      // 新节点的 next 指向原 head
    head = idx;          // 更新 head 为新节点
    idx++;               // 准备下一个新节点
}
```
🔴 **易错点**：**顺序不能乱**！如果先更新 `head`，就找不到原链表了。

🟢 **记忆口诀**：“**新人先指旧队首，队长再换新人当**。”

---

## 1.4 在第 k 个插入的数后面插入

⚠️ **注意**：“第 k 个插入的数”指的是**按插入顺序的第 k 个**，不是当前链表顺序的第 k 个。  
由于我们每次插入都使用 `idx`，**第 1 个插入的节点下标是 0，第 2 个插入的下标是 1，……，第 k 个插入的下标是 `k-1`**。

**步骤**（画图理解）：

1. 新节点的 next 指向 k 节点的 next
    
2. k 节点的 next 指向新节点
    

```cpp

void add(int k, int x) {
    e[idx] = x;
    ne[idx] = ne[k];   // 新节点指向 k 的后继
    ne[k] = idx;       // k 指向新节点
    idx++;
}
```
🔴 **易错点**：

- **忘记 `k` 是插入顺序的第几个，需要 `k-1`**（如果输入给的是第 k 个插入）
    
- **先写 `ne[k] = idx` 再写 `ne[idx] = ne[k]`** → 自己指向自己，链表断裂
    

🟢 **记忆口诀**：“**新人先认老邻居，老人再指新面孔**。”

---

## 1.5 删除第 k 个插入的数后面的数

**原理**：让 k 节点的 next 指向**下下个节点**，跳过中间节点。

```cpp

void remove(int k) {
    ne[k] = ne[ne[k]];   // 跳过下一个节点
}
```
**特殊情况**：删除头结点（`k = 0` 表示删除头结点）

```cpp

if (k == 0) head = ne[head];   // 头结点指向第二个节点
else remove(k-1);              // 注意下标转换
```
🔴 **易错点**：

- **单链表无法直接删除当前节点**，只能删除**后面的节点**（除非是头结点）
    
- **删除后节点空间不会重用**（竞赛不回收，直接忽略）
    

---

## 1.6 遍历链表

```cpp

for (int i = head; i != -1; i = ne[i]) {
    cout << e[i] << ' ';
}
```
---

## 1.7 尾插法优化（拓展）

头插法 O(1)，尾插法如果每次都遍历到尾部是 O(n)。  
**优化**：维护一个 `tail` 指针，始终指向最后一个节点。

```cpp

int tail;  // 全局维护
void add_to_tail(int x) {
    e[idx] = x;
    ne[idx] = -1;
    if (head == -1) head = tail = idx;
    else {
        ne[tail] = idx;
        tail = idx;
    }
    idx++;
}
```
✅ 适用场景：需要**保持输入顺序**时。

---

## 1.8 单链表小结

|操作|时间复杂度|关键点|
|---|---|---|
|头插法|O(1)|先连后改|
|任意插入|O(1)|下标是 k-1|
|删除（后一个）|O(1)|跳过|
|删除头结点|O(1)|特判|
|遍历|O(n)|-|

---

# 二、双链表 —— 两个哨兵的优雅

## 2.1 为什么需要双链表？

- 支持**快速获取前驱**
    
- 某些问题需要双向遍历（如编辑器、缓存）
    
- 用数组模拟同样简单
    

## 2.2 存储结构

我们使用**三个数组**：

- `e[N]`：值
    
- `l[N]`：左指针（前驱下标）
    
- `r[N]`：右指针（后继下标）
    

**特殊约定**：

- `0` 号节点作为**左边界哨兵**（head）
    
- `1` 号节点作为**右边界哨兵**（tail）
    
- `idx` **从 2 开始分配**真实节点
    

**初始化**：

```cpp

r[0] = 1;   // 左边界右指针指向右边界
l[1] = 0;   // 右边界左指针指向左边界
idx = 2;    // 新节点从 2 开始
```
这样，空链表就是 `0 <-> 1`，中间没有实际节点。

---

## 2.3 插入操作 —— 在节点 k 的右侧插入

**步骤**（四步，必须按顺序）：

1. 存值：`e[idx] = x`
    
2. 新节点的右指针指向 k 的右节点：`r[idx] = r[k]`
    
3. 新节点的左指针指向 k：`l[idx] = k`
    
4. 原 k 的右节点的左指针指向新节点：`l[r[k]] = idx`
    
5. k 的右指针指向新节点：`r[k] = idx`
    
6. `idx++`
    

```cpp

void add(int k, int x) {
    e[idx] = x;
    r[idx] = r[k];
    l[idx] = k;
    l[r[k]] = idx;
    r[k] = idx;
    idx++;
}
```
🔴 **致命错误**：如果**先修改 `r[k]`，就会丢失原来的 `r[k]`**，导致第 4 步找不到原右节点。  
✅ **顺序口诀**：“**先接新客左右手，再改旧邻前后门**。”

**左侧插入**：转化为 `add(l[k], x)`（在 k 的左节点右侧插入）。

---

## 2.4 删除操作 —— 桥接左右

删除节点 k（k 是真实节点下标，不是第几个插入）：

```cpp

void remove(int k) {
    r[l[k]] = r[k];   // 左节点的右指针指向右节点
    l[r[k]] = l[k];   // 右节点的左指针指向左节点
}
```
仅需两步，不需要释放内存。

🔴 **注意**：不要尝试删除哨兵 0 或 1。

---

## 2.5 双链表小结

|操作|时间复杂度|关键点|
|---|---|---|
|右侧插入|O(1)|四步顺序|
|左侧插入|O(1)|转化为右侧|
|删除|O(1)|桥接左右|
|遍历|O(n)|-|

---

# 三、栈与队列 —— 最简单的数组模拟

## 3.1 栈（先进后出）

**数组模拟**：

```cpp

int stk[N], tt = 0;   // tt 指向栈顶（0 表示空）
```
- **插入**：`stk[++tt] = x;`
    
- **弹出**：`tt--;`
    
- **判空**：`tt > 0`（非空），`tt == 0`（空）
    
- **取栈顶**：`stk[tt]`
    

🔴 **习惯差异**：有的模板 `tt` 初始化为 -1，则插入为 `stk[++tt] = x`，判空为 `tt == -1`。**选一种固定即可**。

---

## 3.2 队列（先进先出）

**数组模拟**（非循环）：

```cpp

int q[N], hh = 0, tt = -1;   // hh 队头，tt 队尾
```
- **插入**：`q[++tt] = x;`
    
- **弹出**：`hh++;`
    
- **判空**：`hh <= tt` 非空
    
- **取队头**：`q[hh]`
    
- **取队尾**：`q[tt]`
    

⚠️ **注意**：队尾指针 `tt` **始终指向最后一个元素**，所以初始为 -1。

✅ **循环队列**（节省空间）：

```cpp

int q[N], hh = 0, tt = 0;   // tt 指向下一个插入位置
插入：q[tt++] = x; if (tt == N) tt = 0;
弹出：hh++; if (hh == N) hh = 0;
判空：hh == tt;
```
竞赛中**非循环队列**足够用（总操作次数 ≤ 数组大小）。

---

# 四、单调栈 —— 及时删除无用元素

## 4.1 经典问题：左边第一个比它小的数

给定序列 `a[1..n]`，求每个数左边离它最近且比它小的数（不存在输出 -1）。

**暴力**：向左扫描 O(n²) → 超时。

**优化思路**：

- 如果存在 `a[x] ≥ a[y]` 且 `x < y`，那么当后面元素找左边比它小的数时，**`a[x]` 永远不可能成为答案**（因为 `a[y]` 更小且更近）。
    
- 因此，我们可以维护一个**单调递增栈**，栈内元素从底到顶递增。
    

**算法流程**：

1. 遍历每个元素 `a[i]`
    
2. 当栈非空且栈顶 ≥ `a[i]`，弹出栈顶
    
3. 此时栈顶就是左边第一个比 `a[i]` 小的数（若栈空则 -1）
    
4. 将 `a[i]` 压入栈
    

**代码**（数组模拟栈）：

```cpp

int stk[N], tt = 0;
for (int i = 0; i < n; i++) {
    while (tt > 0 && stk[tt] >= a[i]) tt--;   // 弹出所有≥当前元素的值
    if (tt > 0) cout << stk[tt] << ' ';
    else cout << -1 << ' ';
    stk[++tt] = a[i];
}
```
🔴 **易错点**：

- **比较条件**：找“比它小”用 `≥` 弹出，找“比它大”用 `≤` 弹出。
    
- **输出的是值还是下标**？根据题目要求。若输出下标，栈存下标，比较时用 `a[stk[tt]]`。
    

🟢 **记忆口诀**：“**单调栈，找邻小，弹出大等留栈底**。”

**时间复杂度**：每个元素入栈一次，出栈至多一次 → **O(n)**。

---

## 4.2 拓展应用

- 右边第一个比它大/小的数（从右往左遍历）
    
- 柱状图中最大矩形（LeetCode 84）
    
- 接雨水（LeetCode 42）
    

---

# 五、单调队列 —— 滑动窗口的守护神

## 5.1 经典问题：滑动窗口最大值/最小值

给定数组和窗口大小 k，输出每个窗口的最小值/最大值。

**暴力**：每次扫描窗口 O(nk) → 超时。

**优化思路**：

- 维护一个**单调队列**，队头是当前窗口的最值，队内元素下标递增，值单调（最小值队列单调递增，最大值队列单调递减）。
    
- 当窗口滑动时：
    
    1. **出队**：队头下标如果小于窗口左边界 `i - k + 1`，则弹出队头。
        
    2. **入队**：从队尾开始，将所有**比新元素大（求最小值）** 或 **比新元素小（求最大值）** 的元素弹出，然后新元素下标入队。
        
    3. **输出**：当 `i ≥ k-1` 时，队头元素即为当前窗口最值。
        

**代码**（求最小值，存储下标）：

```cpp

int a[N], q[N];   // q 存储下标
int hh = 0, tt = -1;
for (int i = 0; i < n; i++) {
    // 1. 队头出窗口
    if (hh <= tt && q[hh] < i - k + 1) hh++;
    // 2. 队尾维护单调性（递增）
    while (hh <= tt && a[q[tt]] >= a[i]) tt--;
    // 3. 新元素入队
    q[++tt] = i;
    // 4. 输出
    if (i >= k - 1) cout << a[q[hh]] << ' ';
}
```
**求最大值**：只需将 `>=` 改为 `<=`（维护递减队列）。

🔴 **易错点**：

- **存储下标，不是值**——这样才能判断是否出窗口。
    
- **先出队头，再入队**——顺序不能乱。
    
- **队头弹出条件**：`q[hh] < i - k + 1`（不是 ≤，因为下标从 0 开始，窗口左边界是 i-k+1）。
    
- **队尾弹出用 `while`**——可能不止一个元素要弹出。
    

🟢 **记忆口诀**：“**滑动窗口单调队，下标存入值比对；队头出窗要早判，队尾无用全清退。**”

**时间复杂度**：每个元素入队一次，出队至多一次 → **O(n)**。

---

# 六、KMP 算法 —— 字符串匹配的终极优化

## 6.1 暴力匹配的痛点

**问题**：主串 `s`（长度 n），模式串 `p`（长度 m），找出 `p` 在 `s` 中的所有出现位置。

**暴力**：从每个 `s[i]` 开始尝试匹配，失败则右移一位，**已匹配的部分信息完全丢弃** → O(n×m)。

**KMP 核心**：**利用已匹配部分的最大相同前后缀，让模式串一次性移动多位，主串指针不回退**。

---

## 6.2 next 数组 —— 失配时的“急救手册”

**定义**：`next[i]` 表示**模式串 `p[1..i]` 中，最长相等前后缀的长度**（前缀不包含整个子串，后缀也不包含整个子串）。

**示例**：`p = "ababaca"`

|i|子串|最长相等前后缀|next[i]|
|---|---|---|---|
|1|"a"|无（自身不算）|0|
|2|"ab"|无|0|
|3|"aba"|"a"|1|
|4|"abab"|"ab"|2|
|5|"ababa"|"aba"|3|
|6|"ababac"|无|0|
|7|"ababaca"|"a"|1|

**含义**：当匹配到 `p[i+1]` 失配时，**模式串可以向右移动，使得 `p[1..next[i]]` 与当前对齐的后缀相等**，然后继续比较 `p[next[i]+1]`。

---

## 6.3 next 数组的构建（自匹配）

**思想**：用模式串自己匹配自己。

- 指针 `i` 扫描后缀末尾，指针 `j` 扫描前缀末尾（同时也是当前最长相等长度）。
    
- 初始化：`next[1] = 0`, `j = 0`（`j` 表示已匹配的前缀长度）。
    
- 从 `i = 2` 到 `m`：
    
    1. 当 `j > 0` 且 `p[i] != p[j+1]`，`j = next[j]`（回退到次长前后缀）。
        
    2. 如果 `p[i] == p[j+1]`，`j++`。
        
    3. `next[i] = j`。
        

**代码**（下标从 1 开始）：

```cpp

int ne[N];   // 避免与关键字 next 冲突
for (int i = 2, j = 0; i <= m; i++) {
    while (j && p[i] != p[j+1]) j = ne[j];
    if (p[i] == p[j+1]) j++;
    ne[i] = j;
}
```
🔴 **易错点**：

- **下标从 1 开始**——输入时 `p+1` 或直接 `cin >> p+1`。
    
- **`j` 初始为 0**，表示还没有前缀匹配。
    
- **`while` 条件**：`j` 不为 0 且当前字符不匹配才回退。
    

🟢 **记忆口诀**：“**求 next，自匹配；失配回退 ne[j]；配成功 j 自增，ne[i] 记长度。**”

---

## 6.4 KMP 匹配过程

**指针**：

- `i` 扫描主串，从 1 到 n
    
- `j` 扫描模式串，初始 0（表示已匹配长度）
    

**步骤**：

1. 当 `j > 0` 且 `s[i] != p[j+1]`，`j = ne[j]`。
    
2. 如果 `s[i] == p[j+1]`，`j++`。
    
3. 如果 `j == m`：
    
    - 匹配成功，输出起始位置 `i - m + 1`（如果下标从 1 开始）。
        
    - 然后 `j = ne[j]` 继续寻找下一个匹配（允许重叠）。
        

**代码**：

```cpp

for (int i = 1, j = 0; i <= n; i++) {
    while (j && s[i] != p[j+1]) j = ne[j];
    if (s[i] == p[j+1]) j++;
    if (j == m) {
        cout << i - m + 1 << ' ';
        j = ne[j];
    }
}
```
🔴 **易错点**：

- **比较的是 `s[i]` 和 `p[j+1]`**，因为 `j` 是已匹配长度，下一个要匹配的是 `p[j+1]`。
    
- **匹配成功后必须 `j = ne[j]`**，否则无法找到后续匹配。
    
- **边界条件**：`j = 0` 时不会回退（直接比较 `p[1]` 和 `s[i]`）。
    

🟢 **记忆口诀**：“**主串指针永向前，模式失配查 ne；匹配成功输位置，模式回退再向前。**”

**时间复杂度**：O(n + m)，每个字符比较常数次。

---

## 6.5 KMP 完整模板（下标从 1）

```cpp

#include <iostream>
using namespace std;
const int N = 100010, M = 1000010;
int n, m;
char p[N], s[M];
int ne[N];
int main() {
    cin >> n >> p + 1 >> m >> s + 1;   // 下标从 1 开始
    // 求 next 数组
    for (int i = 2, j = 0; i <= n; i++) {
        while (j && p[i] != p[j+1]) j = ne[j];
        if (p[i] == p[j+1]) j++;
        ne[i] = j;
    }
    // 匹配
    for (int i = 1, j = 0; i <= m; i++) {
        while (j && s[i] != p[j+1]) j = ne[j];
        if (s[i] == p[j+1]) j++;
        if (j == n) {
            cout << i - n << ' ';   // 题目要求下标从 0 则输出 i-n
            j = ne[j];
        }
    }
    return 0;
}
```
---

# 七、输入输出优化 —— 竞赛生存法则

**原则**：当输入规模 ≥ 10⁵ 时，**必须用 `scanf/printf`**，不要用 `cin/cout`（即使关了同步也慢）。

```cpp

int n;
scanf("%d", &n);
printf("%d\n", n);
```
**字符串输入**：

```cpp

char s[N];
scanf("%s", s + 1);   // 下标从 1 开始
```
✅ **为什么快**？

- `cin/cout` 与 `stdio` 默认同步，确保混用不混乱，但带来额外开销。
    
- `ios::sync_with_stdio(false);` 可解除同步，但仍比 `scanf` 慢（因为 `cin` 需要类型安全检查）。
    

🟢 **竞赛建议**：**无脑用 `scanf/printf`，杜绝 `cin/cout`**。

---

# 📊 本章知识小结 —— 考试前夜必看

| 知识点            | 核心思想                 | 零基础理解锚点   | 易错点             | 难度    |
| -------------- | -------------------- | --------- | --------------- | ----- |
| **单链表（静态）**    | e[]存值，ne[]存指针        | 数组下标就是门牌号 | 插入顺序与下标对应、删除头结点 | ★★★★  |
| **双链表（静态）**    | e[], l[], r[], 哨兵0/1 | 双向走廊      | 插入四步顺序、删除两步     | ★★★★★ |
| **栈（数组）**      | stk[], tt            | 单口罐子      | tt 初始值          | ★★    |
| **队列（数组）**     | q[], hh, tt          | 无底圆筒      | 判空条件            | ★★    |
| **单调栈**        | 弹出无用元素，维护单调性         | 老师留优秀作业   | 比较条件（≥ 还是 ≤）    | ★★★★  |
| **单调队列**       | 窗口滑动，队头出窗，队尾单调       | 窗口里留最靓的仔  | 存储下标、队头出窗条件     | ★★★★★ |
| **KMP next数组** | 自匹配，最长公共前后缀          | 失配时查急救手册  | 下标从1、j回退        | ★★★★★ |
| **KMP 匹配**     | 主串不回退，模式串跳着移         | 模版跟着主串走   | 比较 p[j+1]、匹配后回退 | ★★★★★ |
| **输入优化**       | scanf/printf         | 快！        | 字符串读入 +1        | ★     |

---

# 🎓 写在最后：数据结构是算法的骨架

本章我们彻底告别了指针和动态内存，学会了**用数组模拟一切线性结构**。  
这些静态实现不仅是竞赛的标配，更是你**深入理解计算机底层内存管理**的绝佳机会。

**接下来你要做的**：

1. **单链表**：AC 一道「单链表操作」题，故意把 `add` 的顺序写反，看看链表怎么断的。
    
2. **双链表**：在纸上画 10 次插入删除，把四步口诀刻进 DNA。
    
3. **单调栈/队列**：自己造几组数据，用暴力验证单调栈的正确性。
    
4. **KMP**：拿笔手动计算 `"ababaca"` 的 next 数组，再对着代码跑一遍。
    

**当你把这些坑都踩过一遍，再回头看 KMP——你会发现它根本不是传说中那么难，只是之前没人给你讲清楚“前后缀”而已。**
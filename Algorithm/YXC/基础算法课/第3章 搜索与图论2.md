000# 第三章 搜索与图论（二）—— 从起点到终点，最短路算法全景解析

**
> 🎯 **目标**：学完本章，你将彻底掌握**朴素Dijkstra、堆优化Dijkstra、Bellman-Ford、SPFA、Floyd**五大最短路算法，能根据数据范围秒选算法，并能手撕**负环检测**与**边数限制**等变种问题。从此图论最短路不再是“背诵天书”。

---

# 📌 开篇：从一个城市到另一个城市，怎么走最短？

你在地图上，要从北京到上海。

- 如果你知道所有路线的长度，并且**没有收费站**（所有边权为正），你会用**Dijkstra**——每次都走当前最短的路线，贪心地扩展。
    
- 如果路上有**下坡路**（负权边），甚至可能**越走越短**（负权环），Dijkstra就失效了，你需要**Bellman-Ford**或**SPFA**。
    
- 如果你不仅要查北京到上海，还要查**任意两个城市之间的最短路径**，那就用**Floyd**，一次算出所有点对的距离。
    

**这就是最短路问题的全貌**。  
本章，我们把这五种算法的**底层逻辑**、**代码实现**、**适用场景**、**坑点陷阱**，掰开揉碎讲给你听。

---

# 第一部分 · 最短路问题 —— 一张图，一个目标

## 1.1 问题的分类

|类别|定义|典型算法|
|---|---|---|
|**单源最短路**|从一个起点（源点）出发，到所有其他点的最短距离|Dijkstra、Bellman-Ford、SPFA|
|**多源汇最短路**|任意两点之间的最短距离|Floyd|

**单源最短路**还可按边权正负细分为：

- **正权图**：Dijkstra（朴素/堆优化）
    
- **负权图**：Bellman-Ford、SPFA（**不能有负权环**，否则最短路可能为负无穷）
    

---

## 1.2 算法选择 —— 一张表帮你秒杀

|图的特点|推荐算法|时间复杂度|数据范围建议|
|---|---|---|---|
|稠密图，边权为正|**朴素Dijkstra**|O(n²)|n ≤ 5000|
|稀疏图，边权为正|**堆优化Dijkstra**|O(m log n)|n,m ≤ 10⁵|
|存在负权边，无边数限制|**SPFA**|一般 O(m)，最坏 O(nm)|n,m ≤ 10⁵|
|存在负权边，有边数限制|**Bellman-Ford**|O(nm)|n ≤ 500, m ≤ 10000|
|多源汇，n 较小|**Floyd**|O(n³)|n ≤ 500|
|需要判断负权环|**SPFA（判环）** 或 **Bellman-Ford**|O(nm)|n ≤ 2000|

🔴 **致命误区**：**Dijkstra 不能处理负权边**！一旦出现负权边，贪心假设被破坏，必须用 Bellman-Ford/SPFA。

---

# 第二部分 · 朴素 Dijkstra —— 贪心算法的教科书

## 2.1 故事引入：学霸的刷题计划

你是一个学霸，面前有 n 本题集，你想从第 1 本开始，按“当前已做最少题量”的顺序一本本攻克。  
每攻克一本，你就能知道它关联的其他题集需要多做几道题（更新距离）。  
**你永远只做当前总做题数最少的那本**，并保证它不会再被更新（因为所有边权为正，不会出现绕路更短的情况）。

**这就是 Dijkstra 的贪心灵魂**。

---

## 2.2 核心数据结构


```cpp

int g[N][N];   // 邻接矩阵，g[a][b] 表示 a→b 的边权（不存在则为 INF）
int dist[N];   // 从起点到每个点的最短距离
bool st[N];    // 标记该点是否已经确定最短距离
```
- **INF**：通常用 `0x3f3f3f3f`，因为它是一个足够大的数（≈ 10⁹），且 `memset` 按字节赋值很方便。
    

---

## 2.3 算法步骤（四步法）

1. **初始化**：`dist[1] = 0`，其余 `dist[i] = INF`，`st[]` 全 false。
    
2. **找最小**：在所有 `st[i] = false` 的点中，找出 `dist` 最小的点 `t`。
    
3. **标记确定**：`st[t] = true`（t 的最短距离已确定）。
    
4. **松弛更新**：用 t 更新它的所有出边：  
    `if (dist[j] > dist[t] + g[t][j]) dist[j] = dist[t] + g[t][j]`
    

重复 2~4，共 n 次。

```cpp

int dijkstra() {
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    
    for (int i = 0; i < n; i++) {        // 循环 n 次
        int t = -1;
        for (int j = 1; j <= n; j++)     // 找未确定点中 dist 最小的
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        
        st[t] = true;                   // 确定 t 的最短路
        
        for (int j = 1; j <= n; j++)     // 用 t 更新其他点
            if (!st[j] && dist[j] > dist[t] + g[t][j])
                dist[j] = dist[t] + g[t][j];
    }
    
    if (dist[n] == INF) return -1;
    return dist[n];
}
```
🔴 **易错点**：

- **INF 的判断**：不能直接 `== INF`，因为后面更新时可能 `INF + 负数` 变小，但仍是无穷大。正确判断：`if (dist[n] > INF/2)`。
    
- **重边处理**：邻接矩阵存图时，初始化全 INF，读入时取 `g[a][b] = min(g[a][b], c)`。
    
- **自环**：正权图中自环不影响最短路，可忽略。
    

🟢 **记忆口诀**：“**Dijkstra 贪心法，未定点里找最小；标记确定不再改，松弛更新用此点。**”

---

## 2.4 时间复杂度与适用场景

- 找最小：O(n²)
    
- 松弛更新：O(m)（邻接矩阵遍历所有点，实际 O(n²)）
    
- **总 O(n²)**，适合**稠密图**（m ≈ n²）。
    

**经典例题**：AcWing 849. Dijkstra求最短路 I（n ≤ 500, m ≤ 10⁵）

---

# 第三部分 · 堆优化 Dijkstra —— 稀疏图的救星

## 3.1 为什么需要堆优化？

当 n = 10⁵，朴素版 O(n²) = 10¹⁰，肯定超时。  
**瓶颈**：每次找最小点都要 O(n) 扫描。  
**优化**：用**优先队列（小根堆）** 维护所有未确定点的距离，每次 O(log n) 取出堆顶。

---

## 3.2 存储方式切换

稠密图用邻接矩阵，**稀疏图必须用邻接表**（否则内存爆炸）。

```cpp

int h[N], e[M], ne[M], w[M], idx;
void add(int a, int b, int c) {
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}
```
---

## 3.3 算法流程（与朴素版对比）

```cpp

int dijkstra() {
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    
    // 小根堆：pair<距离, 节点编号>
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});
    
    while (heap.size()) {
        auto t = heap.top(); heap.pop();
        int ver = t.second, distance = t.first;
        
        if (st[ver]) continue;      // 该点已经确定最短路，跳过（冗余备份）
        st[ver] = true;
        
        for (int i = h[ver]; i != -1; i = ne[i]) {
            int j = e[i];
            if (dist[j] > distance + w[i]) {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});  // 可能有多个相同节点的不同距离入堆
            }
        }
    }
    
    if (dist[n] == INF) return -1;
    return dist[n];
}
```
🔴 **易错点**：

- **冗余备份**：同一个节点可能被多次入堆（因为距离不断变小），必须用 `st[]` 过滤已经确定最短路的点。
    
- **优先队列默认是大根堆**，要小根堆必须加 `greater` 参数。
    
- **邻接表初始化**：`memset(h, -1, sizeof h)`。
    

🟢 **记忆口诀**：“**堆优 Dijkstra，小根堆里拿最小；冗余备份用 st，邻接表存稀疏图。**”

---

## 3.4 时间复杂度

- 堆操作：每次 push/pop O(log n)
    
- 总次数：每个节点入堆一次，每条边可能引发一次 push
    
- **总 O(m log n)**，适合稀疏图（m 与 n 同阶）。
    

---

# 第四部分 · Bellman-Ford —— 负权边的“老实人”

## 4.1 故事引入：限次中转的旅行

你买了一张**只能转机 k 次**的特价机票，想知道从北京到上海的最低成本。  
路径中可能有**负票价**（航空公司倒贴钱），但你不能无限转机（限制边数）。

**Dijkstra 在此失效**，因为负权边会破坏贪心假设。  
**Bellman-Ford** 则是老实人——**我不管什么贪心，我每条边都试 k 遍，总能找到最优解**。

---

## 4.2 核心思想：迭代松弛

- 做 **k 次迭代**（k 是限制边数，若无限制则做 n-1 次）。
    
- 每次迭代，**遍历所有边**，尝试用 `dist[a] + w` 更新 `dist[b]`。
    
- 第 i 次迭代后，`dist[b]` 表示**从起点出发，经过不超过 i 条边**的最短距离。
    

**关键**：**必须用上一轮迭代的 dist 副本（backup）来更新**，防止“串联更新”导致边数超标。

---

## 4.3 代码模板

```cpp

struct Edge {
    int a, b, w;
} edges[M];
int bellman_ford() {
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    
    for (int i = 0; i < k; i++) {      // 限制 k 条边
        memcpy(backup, dist, sizeof dist);   // 🔴 备份！防止串联
        for (int j = 0; j < m; j++) {
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            if (backup[a] != INF)      // 可选优化，不加也没事
                dist[b] = min(dist[b], backup[a] + w);
        }
    }
    
    if (dist[n] > INF / 2) return -1;  // 不可达
    return dist[n];
}
```
🔴 **易错点**：

- **备份数组**：必须用 `backup`，否则会出现本轮先更新 `dist[2]`，然后用新 `dist[2]` 更新 `dist[3]`，相当于**一条边用了两次**，违背“不超过 i 条边”的限制。
    
- **无穷大判断**：不能 `== INF`，因为负权边可能让 INF 稍微变小一点，但仍是无穷大。经验值：`> INF/2`。
    
- **负权回路**：如果第 n 次迭代仍能更新，说明存在负权回路（且从起点可达），此时最短路可能为负无穷，但若有限制边数，则仍可求解。
    

🟢 **记忆口诀**：“**Bellman-Ford 老实人，边边都试 k 轮；备份数组防串联，负环检测第 n 轮。**”

---

## 4.4 应用场景

- **有负权边，且限制最短路径最多经过 k 条边**（如航班最多转 k 次）。
    
- 若无边数限制，一般用 SPFA 效率更高。
    

---

# 第五部分 · SPFA —— Bellman-Ford 的队列优化

## 5.1 优化思想：只有变小的点才能更新别人

Bellman-Ford 每次迭代都遍历所有边，但很多边的起点距离并没有变小，用它们更新是**无效松弛**。  
**SPFA** 用一个队列维护**距离变小的点**，只从这些点出发松弛邻边。

**生活类比**：公司里只有**涨工资的人**才可能给下属涨工资；没涨工资的人，下属工资也不会变。

---

## 5.2 代码模板（求最短路）

```cpp

int spfa() {
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    queue<int> q;
    q.push(1);
    st[1] = true;          // 标记在队列中
    
    while (q.size()) {
        int t = q.front(); q.pop();
        st[t] = false;
        
        for (int i = h[t]; i != -1; i = ne[i]) {
            int j = e[i];
            if (dist[j] > dist[t] + w[i]) {
                dist[j] = dist[t] + w[i];
                if (!st[j]) {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    
    if (dist[n] == INF) return -1;
    return dist[n];
}
```
🔴 **易错点**：

- **队列标记**：必须用 `st[]` 标记节点是否在队列中，防止重复入队。
    
- **无负权环**：SPFA 不能处理负权环（会无限循环），需额外判环。
    
- **被卡风险**：有些出题人会构造数据使 SPFA 退化为 O(nm)，此时应换堆优化 Dijkstra（若边权为正）或 Bellman-Ford。
    

🟢 **记忆口诀**：“**SPFA 像 BFS，只有变小的点入队；队列标记防重入，负权边也能跑。**”

---

## 5.3 扩展：SPFA 判负环

**原理**：维护一个数组 `cnt[x]`，表示从起点到 x 的最短路径经过的**边数**。  
当某次更新后 `cnt[x] ≥ n`，说明路径上有 n+1 个点，根据**抽屉原理**，必有环，且这个环一定是**负环**（否则不会让路径变短）。

**代码改造**：

```cpp

bool spfa_neg_cycle() {
    queue<int> q;
    // 所有点入队，因为负环不一定从 1 出发
    for (int i = 1; i <= n; i++) {
        q.push(i);
        st[i] = true;
    }
    
    while (q.size()) {
        int t = q.front(); q.pop();
        st[t] = false;
        
        for (int i = h[t]; i != -1; i = ne[i]) {
            int j = e[i];
            if (dist[j] > dist[t] + w[i]) {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= n) return true;   // 存在负环
                if (!st[j]) {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    return false;
}
```
🔴 **易错点**：

- **初始将所有点入队**，否则可能漏判从起点不可达的负环。
    
- **`dist` 数组无需初始化为 INF**（可以全 0），因为我们只关心相对大小变化。
    
- **`cnt` 数组更新**：`cnt[j] = cnt[t] + 1`，记录边数。
    

---

# 第六部分 · Floyd —— 动态规划解决所有点对

## 6.1 故事引入：全班同学的最短距离表

你要制作一张表格，记录班级里**任意两个同学**之间的最短距离。  
你可以一个一个地引入“中介人”：先考虑只允许经过 1 号同学，再允许经过 1 或 2 号……直到允许经过所有同学。  
**每引入一个中介，就更新一次表格**。

**这就是 Floyd 的动态规划思想**。

---

## 6.2 核心代码（三行！）

```cpp

void floyd() {
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
```
**状态定义**：`d[i][j]` 表示从 i 到 j 的最短距离。  
**初始化**：

- `d[i][i] = 0`
    
- `d[i][j] = INF`（无边）
    
- 读入边时取最小值（处理重边）
    

**为什么 k 在最外层？**  
因为这是动态规划的阶段——**前 k 个节点**作为中介点。必须从小到大枚举 k，才能保证状态转移正确。

---

## 6.3 特性与限制

- **时间复杂度**：O(n³)，n ≤ 500 左右可用。
    
- **空间复杂度**：O(n²)，邻接矩阵。
    
- **适用性**：
    
    - 多源最短路
        
    - 可处理负权边（但不能有负权回路）
        
- **判不可达**：`if (d[a][b] > INF/2)` 认为无通路。
    

🔴 **易错点**：

- **三重循环顺序**：k 必须在外层！写成 i,j,k 是错误的。
    
- **INF 取值**：同样用 0x3f3f3f3f，防止加法溢出。
    
- **自环**：初始化 `d[i][i] = 0`，即使有负权自环也要设 0（负权自环不会减少从 i 到 i 的距离）。
    

🟢 **记忆口诀**：“**Floyd 三重循环，k 在最外中介点；动态规划慢慢扩，n³ 搞定多源路。**”

---

# 第七部分 · 建图技巧与常见坑

## 7.1 邻接矩阵 vs 邻接表

|存储方式|适用场景|优点|缺点|
|---|---|---|---|
|邻接矩阵|稠密图|O(1) 查询边，代码简单|O(n²) 空间，n ≤ 5000|
|邻接表|稀疏图|O(n+m) 空间|代码稍复杂，遍历所有边 O(m)|

**建议**：n ≤ 5000 且 m ≈ n² 用邻接矩阵；否则用邻接表。

---

## 7.2 重边与自环

- **重边**：保留最短的那条即可。
    
- **自环**：
    
    - 正权图：忽略，不影响最短路。
        
    - 负权图：若为负自环，且该点可达，则最短路为 -∞（需特判）。
        

---

## 7.3 INF 的选值与判断

- **为什么是 0x3f3f3f3f？**
    
    - 0x3f3f3f3f ≈ 1.06×10⁹，比常见数据范围（如 10⁹）大，不会溢出。
        
    - `memset` 按字节赋值，`memset(dist, 0x3f, sizeof dist)` 会将每个字节设为 0x3f，正好每个 int 为 0x3f3f3f3f。
        
- **判断不可达**：  
    因为负权边可能让 INF 减小一点，但 INF 极大，减小后仍远大于真实路径长度。**推荐用 `dist[n] > INF/2`**。
    

---

## 7.4 最短路问题解题步骤

1. **读题**：判断是单源还是多源，有无负权边，有无边数限制。
    
2. **建图**：根据数据范围选邻接矩阵/邻接表，处理重边自环。
    
3. **选算法**：根据算法选择表秒杀。
    
4. **敲模板**：默写对应的最短路模板。
    
5. **判无解**：根据算法特点判断（Dijkstra：`==INF`；Bellman/SPFA/Floyd：`>INF/2`）。
    
6. **输出**：按要求输出。
    

---

# 📊 本章知识小结 —— 考试前夜必看

|算法|核心思想|时间复杂度|适用场景|易错点|
|---|---|---|---|---|
|**朴素Dijkstra**|贪心，每次选最小未确定点|O(n²)|稠密正权图|INF 判断、重边取 min|
|**堆优化Dijkstra**|小根堆优化找最小值|O(m log n)|稀疏正权图|冗余备份、邻接表|
|**Bellman-Ford**|迭代松弛，备份数组|O(nm)|负权边，边数限制|备份、INF 判断|
|**SPFA**|队列优化，只更新变小的点|一般 O(m)|负权图（无环）|队列标记、被卡风险|
|**SPFA判负环**|维护 cnt[]，≥n 即环|O(nm)|检测负权回路|所有点入队、dist 随意|
|**Floyd**|DP，k 为中转点|O(n³)|多源，n ≤ 500|三重循环顺序|

---

# 🎓 写在最后：最短路 —— 图论世界的“四则运算”

最短路算法就像加减乘除，是图论的基本功。  
**它们的区别不在于谁更高级，而在于适用场景**：

- **Dijkstra** 是加法，只能处理正数；
    
- **Bellman-Ford** 是减法的引入，但必须小心“借位”（备份）；
    
- **SPFA** 是乘法，效率高但有风险；
    
- **Floyd** 是矩阵运算，一劳永逸。
    

**给你的硬核建议**：

1. **朴素Dijkstra**：手写 5 遍，直到 2 分钟内无错。
    
2. **堆优化Dijkstra**：与朴素版对比着写，理解“优化点”。
    
3. **Bellman-Ford**：故意去掉备份数组，看看会发生什么。
    
4. **SPFA**：自己构造一个网格图，体验它如何被卡成 O(nm)。
    
5. **Floyd**：把 k 循环放到最内层，看看为什么结果是错的。
    

**当你把这些坑都踩过一遍，你会发现——最短路算法，不过是一堆“松弛操作”的排列组合。**

🚀 **下一章，我们将进入最小生成树与二分图，敬请期待。**
# 第五章 动态规划（三）—— 数位统计、状态压缩、树形DP与记忆化搜索

**
> 🎯 **目标**：学完本章，你将彻底掌握**数位统计DP的分情况讨论**、**状态压缩DP的二进制思想**、**树形DP的递归设计**以及**记忆化搜索的实现技巧**。从此DP不再是“看懂答案但自己写不出”。

---

# 📌 开篇：DP的四种新形态

前两章我们学了**背包问题**（组合优化）、**线性DP**（序列递推）和**区间DP**（区间合并）。  
本章我们将进入DP的另外四个重要领域：

1. **数位统计DP** —— 统计数字在区间中出现的次数，核心是**分情况讨论**。
    
2. **状态压缩DP** —— 用小整数表示集合，处理**小规模但状态复杂**的问题（如棋盘覆盖、旅行商）。
    
3. **树形DP** —— 在树上做DP，利用**递归**天然处理子树。
    
4. **记忆化搜索** —— 用递归实现DP，**不用思考循环顺序**，适合拓扑序不明确的问题。
    

**这些DP形态看似迥异，但核心依然是状态表示与状态转移。**  
**让我们从最“麻烦”的数位统计开始。**

---

# 第一部分 · 数位统计DP —— 区间数字出现次数

## 一、故事引入：统计1~n中数字x的出现次数

老师布置了一个任务：统计从1到1000000中，数字`7`一共出现了多少次。  
你可以写个循环，从1枚举到1000000，每个数拆位统计——**但这样太慢**。  
有没有办法**直接通过数学计算**得到答案？

**这就是数位统计DP**：利用数字的十进制位，分类讨论每一位上目标数字出现的次数。

---

## 二、问题模型：求[a,b]中0~9各自出现次数

给定两个整数 a, b（1 ≤ a,b < 10⁸），求 a 到 b 之间的所有数字中，0~9 每个数字出现的总次数。  
（例如数字 112 中，1 出现 2 次，2 出现 1 次。）

**思路**：

- 实现函数 `count(n, x)`：统计 1 到 n 中数字 x 出现的次数。
    
- 答案 = `count(b, x) - count(a-1, x)`（前缀和思想）。
    
- 重点：如何高效实现 `count(n, x)`，复杂度 O(位数) 而不是 O(n)。
    

---

## 三、核心方法：分情况讨论每一位

假设 n 是一个 k 位数，我们考虑**第 i 位**（从低位0开始，或者从高位1开始，两种常见定义，本文采用**从高位1开始，第 i 位**，方便对应前缀）。  
更常见的套路是：将 n 的十进制各位存入数组 `num[]`，从高位到低位，下标从1到len。

对于第 i 位，其权重为 `10^(len-i)`。我们计算这一位上 x 出现的次数，分成**三类情况**（以数字 x 为例，x=0 需特殊处理）。

---

### 3.1 通用公式推导（以数字 x = 1~9 为例）

设当前处理到第 i 位，记：

- `left` = 高位部分（第 1 到 i-1 位组成的数字）
    
- `right` = 低位部分（第 i+1 到 len 位组成的数字）
    
- `digit` = 第 i 位上的数字
    
- `pow` = 10^(len-i) （低位数字的取值范围大小）
    

**情况1：高位取 0 到 left-1**  
此时第 i 位可以任意取（0~9），但我们要固定第 i 位为 x，且高位小于 left，则**第 i 位为 x** 是允许的。  
该情况下，第 i 位固定为 x，低位可取 0 ~ (pow-1) 任意值，共 `pow` 种。  
所以次数 = `left * pow`。

**情况2：高位正好等于 left**

- 子情况2.1：`digit < x` → 第 i 位取 x 会大于原数，不合法 → 0。
    
- 子情况2.2：`digit == x` → 第 i 位可以取 x，低位只能取 0 ~ right，共 `right + 1` 种。
    
- 子情况2.3：`digit > x` → 第 i 位取 x 小于原数，低位可取 0 ~ pow-1，共 `pow` 种。
    

**因此，第 i 位上 x 出现的次数** =


```text

left * pow + 
(digit == x ? (right + 1) : (digit > x ? pow : 0))
```
---

### 3.2 特殊处理：数字 0

数字 0 不能出现在**最高位**（否则是前导零，不是有效的数字表示）。  
因此：

- 当计算第 i 位为 0 时，**高位不能全为 0**，即 left 必须从 1 开始，而不是从 0 开始。
    
- 所以在情况1中，left 实际可取值 1 ~ left-1（如果 left-1 ≥ 1），共 `left - 1` 种，而不是 left 种。
    
- 此外，如果 x=0，**第 i 位本身不能是最高位**（i=1 时，该位是最高位，不能为0），所以我们应该从第 2 位开始枚举。
    

**修正后的 0 的统计公式**（假设 i 不是最高位）：

```text

(left - 1) * pow + 
(digit == 0 ? (right + 1) : (digit > 0 ? pow : 0))
```
若 i = 1（最高位），则跳过（不加任何贡献）。

---

## 四、代码实现（逐行注释）

```cpp

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
// 获取 num 中从 l 位到 r 位组成的数字（l,r 从 1 开始，高位到低位）
int get(vector<int> &num, int l, int r) {
    int res = 0;
    for (int i = l; i >= r; i--) res = res * 10 + num[i];
    return res;
}
// 计算 10^x
int power10(int x) {
    int res = 1;
    while (x--) res *= 10;
    return res;
}
// 统计 1~n 中数字 x 出现的次数
int count(int n, int x) {
    if (n <= 0) return 0;
    vector<int> num;
    while (n) {
        num.push_back(n % 10);
        n /= 10;
    }
    reverse(num.begin(), num.end());   // 现在 num[0] 是最高位
    int len = num.size();
    int res = 0;
    
    for (int i = 0; i < len; i++) {    // i 从 0 开始，表示当前处理第 i 位（0 是最高位）
        int left = get(num, 0, i-1);   // 高位数字（0 ~ i-1 位）
        int right = get(num, i+1, len-1); // 低位数字（i+1 ~ len-1 位）
        int digit = num[i];            // 当前位数字
        int pow = power10(len - i - 1); // 低位的范围大小
        
        // 情况1：高位取 0 ~ left-1
        if (x != 0) res += left * pow;
        else {   // x == 0，高位不能全0，所以 left 从 1 开始
            if (left > 0) res += (left - 1) * pow;
        }
        
        // 情况2：高位 = left
        if (digit > x) {
            if (x != 0 || i > 0) res += pow;   // x=0 且 i=0 时无贡献（最高位）
        } else if (digit == x) {
            if (x != 0 || i > 0) res += right + 1;
        }
    }
    return res;
}
int main() {
    int a, b;
    while (cin >> a >> b, a || b) {
        if (a > b) swap(a, b);
        for (int i = 0; i <= 9; i++) {
            cout << count(b, i) - count(a-1, i) << ' ';
        }
        cout << endl;
    }
    return 0;
}
```
🔴 **易错点**：

- **高位 left 的计算**：当 i=0 时，left 应取 0（没有高位），get 函数需处理区间 l < r 的情况（我们此处简化，实际应判断 i>0）。
    
- **0 的特殊处理**：情况1 中 left 要减 1；情况2 中要加上 `i>0` 的条件。
    
- **power10 边界**：当 i 是最后一位时，len-i-1 = 0，pow = 1，正确。
    
- **输入终止条件**：a=b=0 时停止，注意 a,b 可能无序，需 swap。
    

🟢 **记忆口诀**：“**数位统计分情况，高位低位次幂清；非0正常乘左位，0需减一避前零；当前位大加满，相等加右下加一。**”

---

# 第二部分 · 状态压缩DP —— 小状态的大智慧

状态压缩DP的核心：用一个**整数的二进制位**表示一个集合（哪些元素已选、哪些位置已占等）。  
适用于**状态数 ≤ 2^20** 的问题。

---

## 一、蒙德里安的梦想 —— 1×2 长方形覆盖棋盘

### 1.1 故事引入：铺地砖

你要用 1×2 的长方形地砖铺满一个 N×M 的矩形地面，不能重叠，不能留空。问有多少种铺法。  
N, M ≤ 11。

**关键观察**：如果我们把所有**横向放置**的砖块都确定下来，那么**纵向放置**的砖块就被唯一确定了（因为剩下的空位必须用纵向砖填满）。  
因此，**方案总数 = 合法横向放置方案数**。

---

### 1.2 状态表示

我们**一列一列**地铺砖。  
定义 `f[i][j]`：**已经铺完前 i-1 列，且第 i 列的状态为 j 的方案数**。  
这里的“状态” j 是一个二进制数，**长度 = 行数 N**，  
其中第 k 位为 1 表示第 i-1 列有一个横向砖块**伸到了第 i 列**（即第 i 列的第 k 行被占用了）。  
为 0 表示没有被占。

**初始状态**：`f[0][0] = 1`（第0列没有伸出）。  
**目标状态**：`f[M][0]`（处理完 M 列，最后一列没有砖块伸出，即完全铺满）。

---

### 1.3 状态转移

从第 i-1 列到第 i 列：

- 当前列的状态 j 已知（由前 i-2 列伸过来的）。
    
- 我们要决定第 i 列如何放置横向砖块，这些砖块会**向右伸到第 i+1 列**，产生下一列的状态 k。
    
- 同时，当前列 j 中为 1 的位置已经被占，不能再放砖（也无需处理，因为已经被覆盖）。
    
- 我们还需要保证**当前列的空隙能被纵向砖块填满**。
    

**条件1**：`j & k == 0`  
第 i 列上，伸进来的砖（来自 j）和自己要伸出去的砖（来自 k）不能重叠。

**条件2**：`st[j | k]` 为真  
`j | k` 表示第 i 列最终被覆盖的情况（哪些行已经被占）。剩下的连续 0 必须是**偶数长度**，才能用纵向砖块填满。  
纵向砖块是 2×1，占连续两行。所以 `j | k` 的二进制表示中不能有**连续的奇数个0**。  
我们可以预处理一个数组 `st[]`，标记所有不含连续奇数个0的状态。

---

### 1.4 预处理 st 数组

```cpp

const int N = 12, M = 1 << N;
bool st[M];
long long f[N][M];
// 预处理所有状态是否合法
for (int i = 0; i < 1 << N; i++) {
    st[i] = true;
    int cnt = 0;   // 连续0的个数
    for (int j = 0; j < N; j++) {
        if (i >> j & 1) {
            if (cnt & 1) { st[i] = false; break; }
            cnt = 0;
        } else cnt++;
    }
    if (cnt & 1) st[i] = false;
}
```
---

### 1.5 DP 过程

```cpp

int n, m;
while (cin >> n >> m, n || m) {
    memset(f, 0, sizeof f);
    f[0][0] = 1;
    int state_cnt = 1 << n;
    
    for (int i = 1; i <= m; i++)
        for (int j = 0; j < state_cnt; j++)
            for (int k = 0; k < state_cnt; k++)
                if ((j & k) == 0 && st[j | k])
                    f[i][j] += f[i-1][k];
    
    cout << f[m][0] << endl;
}
```
🔴 **易错点**：

- **n 是行数，m 是列数**，题目中常写反，注意定义。
    
- **状态范围**：1 << n，n ≤ 11，可接受。
    
- **st 数组**：必须严格检查连续0的个数，最后也要检查尾部连续0。
    
- **long long**：结果可能很大，必须用 long long。
    

🟢 **记忆口诀**：“**蒙德里安铺砖法，列列状态二进制；不冲突出不重叠，连续零偶才合法。**”

---

## 二、最短 Hamilton 路径 —— 旅行商问题（TSP）的简化版

### 2.1 故事引入：一次性逛完所有景点

你要从起点 0 出发，恰好经过每个景点一次，最后到达终点 n-1，求最短路径长度。  
景点数量 n ≤ 20。

**暴力**：枚举所有 n! 种排列，不可行。  
**状态压缩DP**：用二进制数 i 表示**当前已经走过的景点集合**，同时记录当前在哪个景点 j。

---

### 2.2 状态表示

`f[i][j]`：**当前已访问过的景点集合为 i，且当前位于 j 的最短路径长度**。

- i 是一个二进制数，第 k 位为 1 表示景点 k 已访问过。
    
- j 是当前所在的景点编号（j ∈ [0, n-1]）。
    
- 属性：最小值。
    

**初始状态**：`f[1][0] = 0`（起点0已访问，集合为 1<<0，距离0）。  
**目标状态**：`f[(1<<n)-1][n-1]`（所有点都访问过，终点为 n-1）。

---

### 2.3 状态转移

枚举**倒数第二个访问的点 k**，即路径为 `0 -> ... -> k -> j`。  
那么：

```text

f[i][j] = min_{k ∈ i, k ≠ j} ( f[i - (1<<j)][k] + w[k][j] )
```
条件：集合 i 包含 j，也包含 k，且去掉 j 后（`i - (1<<j)`）包含 k。

**实现**：

```cpp

int f[1 << N][N];
memset(f, 0x3f, sizeof f);
f[1][0] = 0;
for (int i = 0; i < 1 << n; i++)
    for (int j = 0; j < n; j++)
        if (i >> j & 1)
            for (int k = 0; k < n; k++)
                if (i >> k & 1)
                    f[i][j] = min(f[i][j], f[i - (1<<j)][k] + w[k][j]);
```
🔴 **易错点**：

- **i 的枚举顺序**：必须从小集合到大集合，但这里我们用双重循环，`i - (1<<j)` 一定比 i 小，所以没问题。
    
- **INF 初始化**：0x3f3f3f3f 常用，注意加法时可能溢出（但 w ≤ 10⁶，n ≤ 20，不会）。
    
- **起点固定**：必须从0开始，且经过所有点一次。
    

🟢 **记忆口诀**：“**哈密顿路径压缩，状态集合二进制；倒数第二点枚举，去掉当前再转移。**”

---

# 第三部分 · 树形DP —— 树上动态规划

## 一、没有上司的舞会 —— 最大独立集

### 1.1 故事引入：公司年会

公司有 n 个员工，上下级关系构成一棵树。如果某个员工参加晚会，他的直接上级和直接下级都不能参加。每个员工有一个快乐值，求最大快乐值总和。

**这就是树形DP的经典问题**：**树上最大权独立集**。

---

### 1.2 状态表示

`f[u][0]`：**以 u 为根的子树，且 u 不参加晚会**时的最大快乐值。  
`f[u][1]`：**以 u 为根的子树，且 u 参加晚会**时的最大快乐值。

**属性**：最大值。

**初始化**：叶子节点 `f[u][0] = 0`，`f[u][1] = happy[u]`。

---

### 1.3 状态转移

- **如果 u 参加**：它的所有子节点 v 都不能参加。  
    `f[u][1] = happy[u] + Σ f[v][0]`
    
- **如果 u 不参加**：子节点 v 可以参加也可以不参加，取较大值。  
    `f[u][0] = Σ max(f[v][0], f[v][1])`
    

**答案**：`max(f[root][0], f[root][1])`。

---

### 1.4 代码实现（递归）

```cpp

#include <iostream>
#include <cstring>
using namespace std;
const int N = 6010;
int n;
int happy[N];
int h[N], e[N], ne[N], idx;
bool has_father[N];
int f[N][2];
void add(int a, int b) {
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}
void dfs(int u) {
    f[u][1] = happy[u];
    for (int i = h[u]; i != -1; i = ne[i]) {
        int v = e[i];
        dfs(v);
        f[u][0] += max(f[v][0], f[v][1]);
        f[u][1] += f[v][0];
    }
}
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> happy[i];
    memset(h, -1, sizeof h);
    for (int i = 0; i < n-1; i++) {
        int a, b;
        cin >> a >> b;
        add(b, a);          // b 是 a 的父节点
        has_father[a] = true;
    }
    int root = 1;
    while (has_father[root]) root++;
    dfs(root);
    cout << max(f[root][0], f[root][1]) << endl;
    return 0;
}
```
🔴 **易错点**：

- **建树方向**：题目给出“a b”表示 b 是 a 的父节点，所以 add(b, a)。
    
- **找根**：开一个 `has_father` 数组，没有父节点的就是根。
    
- **递归深度**：n ≤ 6000，递归没问题，若 n 很大需用栈模拟。
    

🟢 **记忆口诀**：“**树形DP递归好，子节点状态传父老；选父则子全不选，不选父子随意挑。**”

---

# 第四部分 · 记忆化搜索 —— 用递归写DP

## 一、滑雪问题 —— 有向无环图上的最长路径

### 1.1 故事引入：高山滑雪

给你一个 m×n 的网格，每个格子有高度。滑雪只能从高到低滑（严格下降），可以向上下左右四个方向移动。求最长能滑多少步（经过的格子数）。

**这是典型的**：**网格图上的最长路径问题**，因为高度严格递减，所以图是**有向无环图（DAG）**，可以用DP或记忆化搜索。

---

### 1.2 状态表示

`f[i][j]`：**从 (i,j) 出发，能滑的最长路径长度**（包括当前格子）。

**答案**：所有 `f[i][j]` 的最大值。

---

### 1.3 状态转移

从 (i,j) 可以向四个方向滑到更低的格子。

```text

f[i][j] = 1 + max{ f[nx][ny] | 高度[nx][ny] < 高度[i][j] }
```
如果没有任何方向可滑，`f[i][j] = 1`。

---

### 1.4 记忆化搜索实现

由于转移方向是向更低高度，我们不知道循环顺序，但可以**递归 + 记忆化**：当需要 `f[nx][ny]` 时，如果没算过，递归计算。

```cpp

#include <iostream>
#include <cstring>
using namespace std;
const int N = 310;
int h[N][N];
int f[N][N];
int n, m;
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
int dp(int x, int y) {
    int &v = f[x][y];
    if (v != -1) return v;      // 已经算过，直接返回
    v = 1;                      // 至少滑自己这一格
    for (int i = 0; i < 4; i++) {
        int a = x + dx[i], b = y + dy[i];
        if (a >= 0 && a < n && b >= 0 && b < m && h[a][b] < h[x][y])
            v = max(v, dp(a, b) + 1);
    }
    return v;
}
int main() {
    cin >> n >> m;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            cin >> h[i][j];
    memset(f, -1, sizeof f);
    int res = 0;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            res = max(res, dp(i, j));
    cout << res << endl;
    return 0;
}
```
🔴 **易错点**：

- **记忆化数组初始化**：必须初始化为 -1 表示未计算。
    
- **引用 `int &v = f[x][y]`**：可以简化代码，后面修改 f[x][y] 时直接修改 v。
    
- **方向数组**：上下左右顺序任意，但要对应。
    
- **严格下降**：条件必须是 `<`，不能是 `<=`。
    

🟢 **记忆口诀**：“**滑雪记忆化搜索，递归四方向走低；算过直接取缓存，答案取所有最大。**”

---

# 📊 本章知识小结 —— 考试前夜必看

|问题类型|状态表示|转移方程|边界/初始化|复杂度|易错点|
|---|---|---|---|---|---|
|**数位统计**|逐位分类讨论|分高位<、=、>|n≤0返回0，0的特殊处理|O(位数)|前导零，0在最高位|
|**蒙德里安梦想**|f[i][j]：第i列状态j|f[i][j] += f[i-1][k] (j&k=0且st[j|k])|f[0][0]=1，预处理st|O(m·4^n)|n行m列混淆|
|**最短Hamilton路径**|f[i][j]：集合i终点j|f[i][j]=min(f[i-1<<j][k]+w[k][j])|f[1][0]=0|O(n²·2ⁿ)|起点0，集合包含判断|
|**树形DP（舞会）**|f[u][0/1]：选/不选u|f[u][1]=happy[u]+Σf[v][0]；f[u][0]=Σmax(f[v][0],f[v][1])|叶子节点|O(n)|找根，建树方向|
|**记忆化搜索（滑雪）**|f[i][j]：从(i,j)出发最长|f[i][j]=1+max(四个方向中更低)|f初始-1，递归|O(nm)|严格下降，边界检查|

---

# 🎓 写在最后：DP的“万变不离其宗”

本章的四种DP类型，表面上天差地别，但内核完全一致：

- **状态表示**：想清楚用什么维度描述子问题，集合是什么，属性是什么。
    
- **状态转移**：想清楚当前状态可以从哪些子状态得到，对应哪种决策（选/不选、从哪来、从哪分、往哪走）。
    
- **初始化与边界**：最小的子问题是什么，数组边界如何防止越界。
    
- **计算顺序**：递推时按什么顺序循环，递归时如何保证子问题先算（记忆化搜索自动满足）。
    

**数位DP**：按位讨论，本质是“高位决策”影响后续。  
**状压DP**：用二进制代表集合，是**指数级状态**的优雅表示。  
**树形DP**：递归处理子树，是**天然的分治**。  
**记忆化搜索**：递归+数组，是**DP的另一种写法**，尤其适合复杂转移。

**给你的硬核建议**：

1. **数位统计**：手动模拟 n=123, x=1，验证公式的每一步。
    
2. **蒙德里安**：用 n=2,m=4 手动在纸上画状态转移，理解 j|k 的意义。
    
3. **Hamilton**：用 n=3 手写DP表格，验证状态压缩的正确性。
    
4. **树形DP**：自己构建一棵小树，递归模拟 f 的计算过程。
    
5. **滑雪**：在矩阵中画一条最长路径，手动递归计算 f 值，体验记忆化的威力。
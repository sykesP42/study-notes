# 基础算法课 Week3 习题课 —— 从最大异或对到食物链，并查集与 Trie 的进阶应用


> 🔴 **阅读提示**：本章是**第三周习题课**，针对**进阶数据结构**进行题目精讲。  
> 涵盖 **最大异或对（Trie 优化）、食物链（带权并查集）、模拟堆（ph/hp 映射）** 三大经典难题。  
> 每一题都会从**暴力思路**开始，引出**优化算法**，**逐行拆解代码**，并总结**易错点 + 记忆口诀**。  
> 🎯 **目标**：通过习题课，让你彻底理解**二进制 Trie 的贪心查找**、**带权并查集的关系维护**以及**带映射堆的双向索引**，从此不再畏惧这类“套路题”。

---

# 📌 开篇：为什么这些题是“进阶”？

本周习题课的三道题，分别对应三种**高级数据结构技巧**：

- **最大异或对** —— 把整数看成二进制串，用 Trie 树加速，**将 O(n²) 降为 O(31n)**。
    
- **食物链** —— 在并查集基础上**维护每个节点到根的距离**，通过模 3 余数表示种类关系。
    
- **模拟堆** —— 手写堆并支持**删除/修改任意元素**，通过 `ph` 和 `hp` 数组建立**插入顺序 ↔ 堆下标**的双向映射。
    

这三道题**代码不长，但思维跳跃大**，是检验你是否真正掌握数据结构的试金石。

---

# 第一部分 · 最大异或对 —— Trie 树存二进制

## 一、故事引入：如何快速找到异或最大的两个数？

给你一堆整数，要从中挑两个数，使它们的异或结果最大。  
**异或**（XOR）就是**二进制下不进位加法**，对应位不同为 1，相同为 0。  
**直觉**：为了让结果更大，我们希望高位尽量为 1 —— 所以**优先保证最高位不同**。

如果暴力枚举所有数对，复杂度 O(n²)，n = 10⁵ 时直接爆炸。  
**优化**：用 Trie 树存储所有数的二进制串，对于每个数，在 Trie 中**贪心找一条尽量每位都相反的分支**。

---

## 二、问题定义

> 给定 n 个整数 A₁, A₂, …, Aₙ，0 ≤ Aᵢ < 2³¹，从中选出两个数进行异或，求最大可能值。  
> 数据范围：1 ≤ n ≤ 10⁵。

---

## 三、暴力枚举 —— 你能想到的第一种方法


```cpp

int res = 0;
for (int i = 0; i < n; i++)
    for (int j = i + 1; j < n; j++)
        res = max(res, a[i] ^ a[j]);
```
**时间复杂度**：O(n²)，n = 10⁵ 时需 10¹⁰ 次运算 → **必超时**。

---

## 四、优化思路 —— 把数看成二进制串，用 Trie 加速

### 1. 核心观察

异或结果的大小**取决于高位**。  
对于当前数 x，我们想找到之前的一个数 y，使 x ^ y 最大。  
从二进制最高位（第 30 位）开始，我们希望这一位异或结果为 1，即 y 的这一位与 x 相反。  
如果存在这样的 y，就选它；否则只能选相同的位。

**这正是一个贪心查找过程**，可以用 Trie 树快速实现。

---

### 2. Trie 树存二进制

每个数都写成 31 位二进制串（高位在前）。  
Trie 节点只有两个分支：0 和 1。  
**插入**：从高位到低位依次检查，若当前分支不存在则创建新节点。  
**查询**：对当前数 x，从高位到低位，**优先走与 x 当前位相反的分支**，若不存在则走相同分支。  
走完所有位后，路径对应的二进制串就是能使异或最大的数 y。

---

### 3. 算法步骤（边插入边查询）

我们可以**一边插入一边查询**：

- 先插入第一个数（此时 Trie 为空，查询无意义）。
    
- 对于后面的每个数 x：
    
    1. 在已有 Trie 中查询与 x 异或最大的数 t，更新答案。
        
    2. 将 x 插入 Trie。
        

**注意**：数与自身异或为 0，不会影响最大值，所以插入顺序不影响结果。

---

## 五、代码模板（带防呆注释）

```cpp

#include <iostream>
using namespace std;
const int N = 100010, M = 31 * N;  // M: Trie 最大节点数，31 位 * 1e5
int son[M][2], idx;                // son 存储子节点下标，0 表示空
void insert(int x) {
    int p = 0;
    for (int i = 30; i >= 0; i--) {  // 从高位到低位
        int u = (x >> i) & 1;        // 取出当前位
        if (!son[p][u]) son[p][u] = ++idx;
        p = son[p][u];
    }
}
int query(int x) {
    int p = 0, res = 0;
    for (int i = 30; i >= 0; i--) {
        int u = (x >> i) & 1;
        // 优先走相反位
        if (son[p][!u]) {
            p = son[p][!u];
            res = (res << 1) | 1;   // 当前位异或为 1
        } else {
            p = son[p][u];
            res = (res << 1) | 0;   // 当前位异或为 0
        }
    }
    return res;
}
int main() {
    int n;
    scanf("%d", &n);
    int res = 0;
    for (int i = 0; i < n; i++) {
        int x;
        scanf("%d", &x);
        if (i) res = max(res, query(x));  // 第一个数不查询（Trie 为空）
        insert(x);
    }
    printf("%d\n", res);
    return 0;
}
```
---

## 六、易错点与细节（🔴必看）

1. **节点数估算**：每个数最多 31 位，n ≤ 10⁵，所以 Trie 节点数 ≤ 31 × 10⁵ ≈ 3.1×10⁶。数组 M 开 `31 * N` 安全。
    
2. **位运算顺序**：必须**从高位到低位**（i = 30 → 0），因为高位权重高，贪心策略依赖高位优先。
    
3. **查询结果的构建**：`res = (res << 1) | 1` 表示将当前位的异或结果追加到二进制串末尾。例如当前 res 二进制是 `101`，再添加一位 1 变成 `1011`。
    
4. **先插入还是先查询？** 两种顺序均可。先插入第一个数，然后对每个 x **先查询再插入** 也可，但第一次查询时 Trie 非空，需注意特判。上述代码用 `if (i)` 跳过第一次查询，更清晰。
    
5. **数据范围**：0 ≤ Aᵢ < 2³¹，所以最高位是 30（从 0 开始计数），循环到 30 即可。
    

🟢 **记忆口诀**：“**最大异或对，二进制串 Trie 存；高位优先贪心走，相反分支必定赢。**”

---

## 七、复杂度分析

- 插入/查询一次：O(31) ≈ O(1)
    
- 总复杂度：O(31n) ≈ 3×10⁶ 次操作，**1 秒内轻松完成**。
    

---

# 第二部分 · 食物链 —— 带权并查集维护相对关系

## 一、故事引入：环形食物链中的真假话

动物王国有三类动物 A、B、C，构成环形食物链：A 吃 B，B 吃 C，C 吃 A。  
现在有 N 个动物（编号 1~N），每个动物属于其中一类，但你不知道具体哪一类。  
有人按顺序说 K 句话，每句话要么说 “X 和 Y 是同类”，要么说 “X 吃 Y”。  
你要判断每句话**是真话还是假话**，并输出假话总数。

**条件**：

- 当前的话与之前**已经确定为真的话**冲突 → 假话。
    
- X 或 Y 编号 > N → 假话。
    
- X 吃 X → 假话。
    

**难点**：动物种类未知，关系需要动态维护。

---

## 二、核心思想 —— 并查集 + 节点到根的距离

如果我们把**有关系的动物**（同类或捕食）放在同一个集合中，那么**只要知道每个动物与根节点的关系**，就能推出任意两个动物的关系。

定义每个节点到父节点的距离 `d[x]`，路径压缩时更新为到根的距离。  
**距离 mod 3 的意义**：

- `d[x] % 3 == 0`：x 与根同类。
    
- `d[x] % 3 == 1`：x 可以吃根。
    
- `d[x] % 3 == 2`：x 被根吃。
    

**为什么是 mod 3？** 因为只有 3 种动物，且食物链是 3 元环。

---

## 三、关系判断 —— 利用距离差

设 `px = find(x)`, `py = find(y)`，且 `dx = d[x]`, `dy = d[y]`（已路径压缩到根）。

- **同类关系（t = 0）**：要求 `(dx - dy) % 3 == 0`。
    
- **捕食关系（t = 1）**：要求 `(dx - dy - 1) % 3 == 0`（即 x 吃 y）。
    

---

## 四、集合合并 —— 根据关系调整距离

如果 `px != py`，需要将 px 合并到 py（或反过来），并**设置 px 到 py 的距离**。

### 1. 同类（t = 0）

已知 `(dx + ? - dy) % 3 == 0`，其中 `?` 是我们要赋给 `d[px]` 的值。  
所以 `d[px] = dy - dx`。

### 2. 捕食（t = 1）

已知 x 吃 y，即 `(dx + ? - dy - 1) % 3 == 0`，  
所以 `d[px] = dy - dx + 1`。

**注意**：计算出的 `d[px]` 可能为负，但取模运算（在 C++ 中用 % 会得到负余数）不影响后续判断，因为我们在判断时都会取模并调整为正。  
但为了安全，可以写成 `(dy - dx + t)` 并手动调整正负，但通常直接存整数（允许负）即可，因为比较时会做 `% 3`。

---

## 五、代码模板（带详细注释）

```cpp

#include <iostream>
using namespace std;
const int N = 50010;
int p[N], d[N];   // p 父节点，d 到父节点的距离（路径压缩后变成到根的距离）
int find(int x) {
    if (p[x] != x) {
        int u = find(p[x]);      // 先递归找到根
        d[x] += d[p[x]];         // 更新 x 到根的距离（累加父节点到根的距离）
        p[x] = u;               // 路径压缩
    }
    return p[x];
}
int main() {
    int n, k;
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= n; i++) p[i] = i, d[i] = 0;
    int res = 0;
    while (k--) {
        int t, x, y;
        scanf("%d%d%d", &t, &x, &y);
        if (x > n || y > n) { res++; continue; }
        int px = find(x), py = find(y);
        if (t == 1) {   // 同类
            if (px == py) {
                if ((d[x] - d[y]) % 3 != 0) res++;  // 冲突
            } else {
                p[px] = py;
                d[px] = d[y] - d[x];   // 使 (d[x] + d[px] - d[y]) % 3 == 0
            }
        } else {        // x 吃 y
            if (px == py) {
                if ((d[x] - d[y] - 1) % 3 != 0) res++;
            } else {
                p[px] = py;
                d[px] = d[y] - d[x] + 1;   // 使 (d[x] + d[px] - d[y] - 1) % 3 == 0
            }
        }
    }
    printf("%d\n", res);
    return 0;
}
```
---

## 六、易错点与细节（🔴必看）

1. **路径压缩时距离的累加**：
    
    ```cpp
    
    int u = find(p[x]);
    d[x] += d[p[x]];   // 此时 p[x] 还是原父节点，d[p[x]] 是父节点到根的距离（已更新）
    p[x] = u;
    ```
    **顺序不能错**！必须先递归，再用原父节点的距离累加。
    
2. **取模判断**：C++ 中 `%` 可能得到负数，例如 `(-1) % 3 = -1`。  
    但我们只关心是否为 0，负余数也能正确判断（因为 `(a-b)%3 == 0` 在数学上等价于 `(a-b) mod 3 == 0`，即使 C++ 负数也能用，因为负数 -1 ≠ 0，且 -3 也是 0？实际上 `-3 % 3 = 0`，没问题）。  
    **但为了可读性**，可以统一写成 `( (d[x] - d[y]) % 3 + 3 ) % 3 != 0`。
    
3. **合并时 d[px] 的赋值**：  
    公式推导时假设 `px` 指向 `py`，`d[px]` 是 px 到 py 的距离。  
    **不要写成** `d[px] = d[y] - d[x]` 忘记 `% 3`，因为直接存真实距离（可正可负）即可，取模判断时自然会归约。
    
4. **编号范围**：动物编号 1~N，读入时可能 > N，直接判假。
    
5. **自吃**：当 t = 2 且 x = y，直接是假话，但我们的判断条件中 `(d[x] - d[x] - 1) % 3 = -1 != 0`，也能判假，但为了清晰，建议显式判断 `if (x == y) { res++; continue; }`。
    

🟢 **记忆口诀**：“**食物链，带权并查集；距离模三定关系，同类差 0 吃差 1；合并公式代进去，路径压缩累距离。**”

---

## 七、复杂度分析

- 路径压缩 + 按秩合并（代码未实现按秩，但路径压缩已足够）的并查集，单次操作均摊 O(α(N)) ≈ O(1)。
    
- 总复杂度 O(Kα(N))，K ≤ 10⁵，轻松通过。
    

---

# 第三部分 · 模拟堆 —— 支持删除/修改任意元素

## 一、故事引入：STL 优先队列做不到的事

STL 的 `priority_queue` 只能操作堆顶，无法**删除堆中任意一个元素**，也无法**修改某个元素的值**。  
但是在一些算法（如 Dijkstra 堆优化）中，我们需要更新某个点的距离，这时就需要**修改堆中元素**。  
**手写堆 + 映射数组** 就是解决方案。

---

## 二、数据结构设计 —— ph 和 hp

我们需要两个额外数组：

- `ph[k]`：**第 k 个插入的数在堆数组中的下标**（pointer from heap index to node）。
    
- `hp[i]`：**堆数组中下标为 i 的元素是第几个插入的**（heap index to pointer）。
    

**为什么需要两个？**

- 当我们知道插入序号 `k`，需要定位到堆中的位置 → `ph[k]`。
    
- 当我们交换堆中两个节点时，它们的插入序号也交换了，需要同步更新 `ph[hp[a]]` 和 `ph[hp[b]]`。  
    这需要通过 `hp[i]` 知道当前位置对应的是第几个插入的。
    

**三者关系**：

- `ph[k] = i` ⇔ `hp[i] = k` （双向映射）
    

---

## 三、核心操作 —— 堆交换（heap_swap）

交换堆中两个节点 `a` 和 `b` 时，必须同步交换三样东西：

1. 值数组 `h[a]` 和 `h[b]`。
    
2. `ph[hp[a]]` 和 `ph[hp[b]]`（因为这两个插入序号的堆下标变了）。
    
3. `hp[a]` 和 `hp[b]`（因为这两个位置的插入序号交换了）。
    

**顺序**：一般先交换 `ph`，再交换 `hp`，最后交换 `h`。顺序并不绝对，只要全部交换即可，但务必**全部交换**，漏一个就全乱。

```cpp

void heap_swap(int a, int b) {
    swap(ph[hp[a]], ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}
```
---

## 四、基本操作（down 和 up）

与普通堆完全一样，只是**交换时用 `heap_swap`**，而不是直接 `swap(h[a], h[b])`。

```cpp

void down(int u) {
    int t = u;
    if (u * 2 <= siz && h[u * 2] < h[t]) t = u * 2;
    if (u * 2 + 1 <= siz && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    if (t != u) {
        heap_swap(u, t);
        down(t);
    }
}
void up(int u) {
    while (u / 2 && h[u / 2] > h[u]) {
        heap_swap(u / 2, u);
        u /= 2;
    }
}
```
---

## 五、五种操作的实现

假设全局变量：

```cpp

int h[N], ph[N], hp[N], siz, m;   // m 记录当前插入序号
```
### 1. 插入一个数 `x`

```cpp

void insert(int x) {
    siz++; m++;
    ph[m] = siz;
    hp[siz] = m;
    h[siz] = x;
    up(siz);
}
```
### 2. 求最小值

```cpp

int get_min() {
    return h[1];
}
```
### 3. 删除最小值

```cpp

void remove_min() {
    heap_swap(1, siz);
    siz--;
    down(1);
}
```
### 4. 删除第 k 个插入的数

```cpp

void remove_kth(int k) {
    int pos = ph[k];
    heap_swap(pos, siz);
    siz--;
    down(pos);
    up(pos);   // 同时调用，只会执行一个
}
```
### 5. 修改第 k 个插入的数为 `x`

```cpp

void update_kth(int k, int x) {
    int pos = ph[k];
    h[pos] = x;
    down(pos);
    up(pos);
}
```
---

## 六、易错点与细节（🔴必看）

1. **ph 和 hp 必须同步维护**，缺一不可。
    
    - 没有 `hp`，交换时无法知道 `ph` 应该改哪个下标。
        
    - 没有 `ph`，就无法根据插入序号定位。
        
2. **堆数组下标从 1 开始**，方便父子节点计算（左儿子 2_i，右儿子 2_i+1）。
    
3. **删除/修改任意元素后，必须同时调用 `down` 和 `up`**，因为新值可能变大也可能变小，但这两个函数中**只有一个会执行**（条件不满足则立即返回）。**不要写 if 判断**，直接调用两个即可。
    
4. **插入时 `m` 先自增**，然后 `ph[m] = siz`，`hp[siz] = m`。  
    `m` 是插入顺序编号，从 1 开始递增。
    
5. **堆的 `siz`**：当前堆中元素个数，不是总插入个数。
    
6. **初始化**：`siz = 0, m = 0`。
    

🟢 **记忆口诀**：“**模拟堆，双映射，ph 记位置，hp 记序号；交换先改 ph，再改 hp，最后改值；删改任意 up down 一起叫。**”

---

# 📊 习题课知识小结

|题目|核心算法|关键代码/公式|易错点|难度|
|---|---|---|---|---|
|**最大异或对**|Trie 存二进制|`son[p][!u]` 优先选择，`res = (res<<1)\|1`|高位优先，节点数估算|★★★★★|
|**食物链**|带权并查集|`d[px] = d[y] - d[x] + (t==1?1:0)`|路径压缩时距离累加顺序，取模判断|★★★★★|
|**模拟堆**|带映射堆|`heap_swap` 三交换，`ph`+`hp`|双向映射同步，`down`+`up` 同时调用|★★★★★|

---

# 🎓 写在最后：进阶数据结构题的“套路”

本周的三道题，代表了三类进阶技巧：

- **最大异或对** —— **用 Trie 优化“按位贪心”**，将整数看作二进制串，空间换时间。
    
- **食物链** —— **带权并查集**，通过**维护节点到根的距离**，将复杂的关系判断转化为简单的模运算。
    
- **模拟堆** —— **双向映射 + 堆操作**，让堆不再是“只能动堆顶”的黑盒。
    

这些技巧并不神秘，只是**在基础数据结构上增加了一点“额外信息”**：

- Trie 加一个 `son[][]` → 支持二进制串查找。
    
- 并查集加一个 `d[]` → 支持相对关系维护。
    
- 堆加两个数组 `ph` 和 `hp` → 支持任意位置删除/修改。
    

**当你真正理解这些“额外信息”如何设计时，你就能自己创造出新的数据结构。**

**给你的硬核建议**：

1. **最大异或对**：自己把 5, 6, 3, 4, 7 这几个数的二进制写出来，手动模拟 Trie 插入和查询过程。
    
2. **食物链**：用样例数据，在纸上画并查集树，手动更新 d 数组，验证每句话的真假。
    
3. **模拟堆**：用 `insert` 插入 3 个数，然后删除第 2 个插入的数，手动画出 ph, hp 的变化过程。
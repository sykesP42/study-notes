# 第二章 数据结构（二）—— 从“字典树”到“堆”，用数组构建高级数据结构

> 🎯 **目标**：学完本章，你将彻底掌握**Trie树、并查集、堆（含带映射堆）** 的原理与实现，并能独立解决**字符串统计、集合合并、堆排序、动态优先队列**等经典问题。

---

# 📌 开篇：从线性结构到树形结构

在前一章，我们用数组模拟了**单链表、双链表、栈、队列**——这些都是**线性结构**。  
但现实中的关系往往是**层次化**的：

- 字典的字母目录（一个字母后跟着多个字母）
    
- 公司的组织架构（一个部门下有多个员工）
    
- 优先级队列（父子间的大小关系）
    

**本章的三员大将**正是为了解决这类问题而生：

- **Trie树** —— 字符串的“高速公路”
    
- **并查集** —— 集合的“快速合查”
    
- **堆** —— 优先级的“完全二叉树”
    

**它们都有一个共同点**：用**数组**模拟**树**，既保留了树的逻辑，又获得了数组的速度。

---

# 一、Trie树（字典树）—— 像查字典一样找字符串

## 1.1 故事引入：如何快速查单词？

想象你面前有一本**英文字典**，你要查 `"apple"` 是否存在。  
你不会一页页翻，而是：

1. 先翻到 `a` 开头的部分
    
2. 再找 `ap` 开头的单词
    
3. 再找 `app`、`appl`……直到 `apple`
    

**Trie树**就是这种“逐字母查找”思想的**数据结构化**。  
它将所有单词**按公共前缀合并**，**共享相同前缀的路径**，**极大节省空间**，且**查询速度只与单词长度有关**。

---

## 1.2 核心数据结构定义（数组模拟）

我们用**三个全局数组 + 一个指针**来模拟整棵树：


```cpp

const int N = 100010;  // 总节点数（根据题目数据范围设定）
int son[N][26];  // 每个节点的 26 个子节点下标（0 表示不存在）
int cnt[N];      // 以当前节点结尾的单词数量
int idx = 0;     // 当前已使用的节点下标（0 号点既是根节点，也表示空节点）
```
🔵 **理解 `son[N][26]`**：

- 第一维 `N`：**节点的编号**（就像单链表的 `idx`）
    
- 第二维 `26`：**26 个小写字母**，每个字母对应一条出边
    
- `son[i][j] = k`：**节点 i 的 ‘a’+j 这条边指向节点 k**（k 为 0 表示不存在）
    

🟢 **特殊约定**：

- **下标 `0` 的点既是根节点，也表示空节点**（类似单链表中 `-1` 表示空指针）。
    
- 根节点不存储字符，只作为起点。
    

---

## 1.3 插入操作 —— 逐层创建/遍历

**故事类比**：往字典里添加一个新单词，遇到没见过的字母组合就“加一页”。

```cpp

void insert(char str[]) {
    int p = 0;  // 从根节点开始
    for (int i = 0; str[i]; i++) {
        int u = str[i] - 'a';          // 将字母映射到 0~25
        if (!son[p][u])               // 如果当前节点没有这个字母的子节点
            son[p][u] = ++idx;        // 创建新节点
        p = son[p][u];                // 移动到子节点
    }
    cnt[p]++;                        // 在单词结尾节点计数 +1
}
```
🔴 **易错点**：

- **忘记初始化 `son` 数组**：全局变量默认全 0，刚好表示空节点，**不需要 memset**。
    
- **字符映射**：必须 `- 'a'`，不能直接使用字符的 ASCII 码（数值太大）。
    
- **`cnt[p]++` 的位置**：一定要放在循环**结束之后**，表示“以这个节点结尾的单词数加 1”。
    

🟢 **记忆口诀**：“**根零开始逐字符，无子则创建，有子则移步，结尾计数器加一。**”

---

## 1.4 查询操作 —— 沿着路径走到底

**故事类比**：查单词，只要某一步字母找不到，字典里就没有这个词；走到底还要看结尾标记。

```cpp

int query(char str[]) {
    int p = 0;
    for (int i = 0; str[i]; i++) {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;    // 路径中断 → 不存在
        p = son[p][u];
    }
    return cnt[p];                  // 返回以该节点结尾的单词数量
}
```
🔴 **易错点**：

- **查询时不能创建新节点**——只读不写。
    
- **返回的是 `cnt[p]`**，不是 `1`（因为可能插入重复单词）。
    
- **路径存在但 `cnt[p] == 0`**：表示该路径是一个**前缀**，但不是完整的单词（如插入了 `"apple"`，查询 `"app"` 返回 0）。
    

---

## 1.5 经典例题：Trie字符串统计（AcWing 835）

**题目**：维护一个字符串集合，支持两种操作：

- `I x`：插入字符串 x（仅含小写字母）
    
- `Q x`：查询字符串 x 在集合中出现的次数
    

**完整代码**：

```cpp

#include <iostream>
using namespace std;
const int N = 100010;
int son[N][26], cnt[N], idx;
void insert(char str[]) {
    int p = 0;
    for (int i = 0; str[i]; i++) {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++idx;
        p = son[p][u];
    }
    cnt[p]++;
}
int query(char str[]) {
    int p = 0;
    for (int i = 0; str[i]; i++) {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
int main() {
    int n;
    scanf("%d", &n);
    char op[2], str[N];
    while (n--) {
        scanf("%s%s", op, str);
        if (op[0] == 'I') insert(str);
        else printf("%d\n", query(str));
    }
    return 0;
}
```
---

## 1.6 应用扩展：最大异或对（整数Trie）

Trie 不仅可以存字符串，**也可以存整数的二进制位**。  
**思路**：将每个整数看成 31 位二进制串（0~30 位），从高位到低位插入 Trie。  
查询时，对于当前位，**尽量走相反的分支**（异或为 1 最大）。

```cpp

// 插入整数
void insert(int x) {
    int p = 0;
    for (int i = 30; i >= 0; i--) {
        int u = x >> i & 1;
        if (!son[p][u]) son[p][u] = ++idx;
        p = son[p][u];
    }
}
// 查询与 x 异或的最大值
int query(int x) {
    int p = 0, res = 0;
    for (int i = 30; i >= 0; i--) {
        int u = x >> i & 1;
        if (son[p][!u]) {          // 存在相反位 → 异或为 1
            p = son[p][!u];
            res = res * 2 + 1;
        } else {                  // 只能走相同位 → 异或为 0
            p = son[p][u];
            res = res * 2 + 0;
        }
    }
    return res;
}
```
🔴 **注意**：整数 Trie 的节点分支数是 2（0/1），所以 `son[N][2]`。

---

# 二、并查集 —— 帮派合并与查找

## 2.1 故事引入：武林门派的合并

假设江湖上有许多独立的侠客，一开始**各自为派**（每个人是自己的掌门）。  
两个操作：

1. **合并**：两个门派决定合并，推举其中一位掌门为总掌门。
    
2. **查询**：问两位侠客是否在同一门派。
    

**并查集**就是用来**高效处理这类集合合并与归属查询**的数据结构。

---

## 2.2 核心思想：树形结构，父节点数组

- 每个集合用**一棵树**表示，**树根**是集合的代表元素（掌门）。
    
- 用一个数组 `p[]` 存储每个节点的**父节点**：`p[x] = 父节点下标`。
    
- **根节点**的特征：`p[x] == x`（自己是自己的父节点）。
    

**初始化**：

```cpp

for (int i = 1; i <= n; i++) p[i] = i;   // 每个元素自成一个集合
```
---

## 2.3 核心操作：find —— 找掌门（路径压缩）

**问题**：如何找到 `x` 所在集合的根节点？  
**朴素**：不断往上爬 `while (p[x] != x) x = p[x];` —— 最坏 O(n)。  
**优化**：**路径压缩**——在查找过程中，**把路径上所有节点直接挂到根节点下**。

**递归实现（最简洁）**：

```cpp

int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);   // 递归找根，并更新父节点为根
    return p[x];
}
```
🔵 **理解递归**：

- 调用 `find(x)`，如果 `x` 不是根，先递归找到根 `find(p[x])`，**然后把返回值赋给 `p[x]`**（路径压缩）。
    
- 最终返回根节点编号。
    

**非递归实现**（稍长，但更直观）：

```cpp

int find(int x) {
    int root = x;
    while (p[root] != root) root = p[root];  // 找根
    while (p[x] != root) {                  // 压缩路径
        int nx = p[x];
        p[x] = root;
        x = nx;
    }
    return root;
}
```
✅ **效果**：经过一次 `find`，该路径上所有节点直接指向根，后续查找 O(1)。

---

## 2.4 合并操作 —— 掌门挂掌门

```cpp

void merge(int a, int b) {
    int pa = find(a), pb = find(b);
    if (pa != pb) p[pa] = pb;   // 将 a 的掌门挂到 b 的掌门下
}
```
🔴 **易错点**：

- **合并前必须先找根**，不能直接用 `p[a] = b`。
    
- **不需要特殊处理相等情况**（已在同一集合），但可以提前返回避免多余操作。
    

---

## 2.5 例题1：合并集合（AcWing 836）

**题目**：有 n 个数（1~n），初始各自成集合。m 个操作：

- `M a b`：合并 a 和 b 所在集合
    
- `Q a b`：查询 a 和 b 是否在同一集合
    

**代码**：

```cpp

int p[N];
int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}
int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) p[i] = i;
    
    while (m--) {
        char op[2];
        int a, b;
        scanf("%s%d%d", op, &a, &b);
        if (op[0] == 'M') p[find(a)] = find(b);
        else {
            if (find(a) == find(b)) puts("Yes");
            else puts("No");
        }
    }
    return 0;
}
```
🔴 **易错点**：

- **字符读入**：用 `char op[2]` 而不是 `%c`，避免空格/换行残留。
    
- **合并时**：`p[find(a)] = find(b)`，顺序无所谓，但习惯写成将 a 的根挂到 b 的根下。
    

---

## 2.6 维护集合大小（连通块中点的数量）

**需求**：除了合并和查询连通性，还要**快速知道某个点所在集合的元素个数**。

**方法**：额外维护一个数组 `size[N]`，**只对根节点有效**，存储该集合的元素总数。

**初始化**：

```cpp

for (int i = 1; i <= n; i++) {
    p[i] = i;
    size[i] = 1;
}
```
**合并时**：

```cpp

int pa = find(a), pb = find(b);
if (pa != pb) {
    p[pa] = pb;
    size[pb] += size[pa];   // 将 pa 集合的大小加到 pb 上
}
```
**查询大小**：

```cpp

printf("%d\n", size[find(a)]);
```
🔴 **易错点**：

- **合并时必须先累加 size 再改父节点**（顺序无所谓，但必须**只改根节点的 size**）。
    
- **查询时一定要用 `size[find(a)]`**，不能直接用 `size[a]`（a 可能不是根）。
    
- **自环/重边**：题目允许，不影响并查集操作。
    

---

## 2.7 并查集小结

|操作|代码|时间复杂度|
|---|---|---|
|初始化|`p[i] = i; size[i] = 1;`|O(n)|
|find（路径压缩）|`if (p[x] != x) p[x] = find(p[x]);`|**均摊 O(α(n))**|
|合并|`p[find(a)] = find(b); size[pb] += size[pa];`|O(α(n))|
|查询同一集合|`find(a) == find(b)`|O(α(n))|

🟢 **记忆口诀**：  
“**并查集，找掌门；递归压缩一步到位；合并掌门挂掌门，大小只在根上存。**”

---

# 三、堆 —— 完全二叉树的数组魔法

## 3.1 故事引入：班级成绩排名

老师要**随时知道全班的最低分**，并且支持：

- 插入一个新成绩
    
- 删除最低分
    
- 修改某个同学的成绩
    

用普通数组找最小值需要 O(n)，太慢。  
**堆**就是专门解决**动态集合的最值问题**的神器。

---

## 3.2 堆的基本性质（小根堆为例）

- **结构性质**：**完全二叉树**（除最后一层外全满，最后一层左对齐）
    
- **堆序性质**：**每个节点的值 ≤ 左右子节点的值**（递归定义）
    
- 推论：**根节点是整个堆的最小值**。
    

**完全二叉树的数组存储**（下标从 1 开始）：

- 根节点：下标 `1`
    
- 节点 `i` 的左儿子：`2*i`
    
- 节点 `i` 的右儿子：`2*i + 1`
    
- 节点 `i` 的父节点：`i/2`（整数除法）
    

✅ **为什么下标从 1 不是 0？**  
如果从 0 开始，左儿子 = `2*i+1`，右儿子 = `2*i+2`，父节点 = `(i-1)/2`，也能实现。  
**但** `0` 的左儿子还是 `0`（`2*0=0`），容易混淆。**竞赛习惯下标从 1 开始**，清晰且不易错。

---

## 3.3 核心操作：down —— 下沉（节点值变大时）

**场景**：某个节点的值变大了（或刚交换上来），可能破坏堆序，需要**向下调整**。

**步骤**：

1. 设当前节点为 `u`，用 `t` 记录 `u` 和它的左右儿子中**最小值的下标**。
    
2. 如果左儿子存在且值更小，更新 `t`。
    
3. 如果右儿子存在且值更小，更新 `t`。
    
4. 如果 `t != u`（说明子节点有更小值），交换 `h[u]` 和 `h[t]`，并**递归处理 `t`**。
    

```cpp

int h[N];   // 堆数组
int siz;    // 当前堆的大小（元素个数）
void down(int u) {
    int t = u;
    if (u * 2 <= siz && h[u * 2] < h[t]) t = u * 2;
    if (u * 2 + 1 <= siz && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    if (t != u) {
        swap(h[u], h[t]);
        down(t);
    }
}
```
---

## 3.4 核心操作：up —— 上浮（节点值变小时）

**场景**：某个节点的值变小了（或刚插入末尾），可能比父节点小，需要**向上调整**。

**步骤**：

1. 只要当前节点 `u` 不是根（`u > 1`）且父节点 `u/2` 的值大于当前值，就交换。
    
2. 将 `u` 更新为父节点下标，继续比较。
    

```cpp

void up(int u) {
    while (u / 2 > 0 && h[u / 2] > h[u]) {
        swap(h[u / 2], h[u]);
        u /= 2;
    }
}
```
---

## 3.5 五个基本操作实现

|操作|实现方式|时间复杂度|
|---|---|---|
|**1. 插入一个数**|`h[++siz] = x; up(siz);`|O(log n)|
|**2. 求最小值**|`h[1]`|O(1)|
|**3. 删除最小值**|`h[1] = h[siz--]; down(1);`|O(log n)|
|**4. 删除任意元素**（已知下标 k）|`h[k] = h[siz--]; down(k); up(k);`|O(log n)|
|**5. 修改任意元素**（已知下标 k）|`h[k] = x; down(k); up(k);`|O(log n)|

🔴 **删除/修改任意元素**的要点：

- **用堆尾元素覆盖目标位置**，然后 `siz--`。
    
- 覆盖后，新值可能变大（需要 `down`）也可能变小（需要 `up`）。
    
- **直接同时调用 `down(k)` 和 `up(k)`**，实际只会执行其中一个（另一个条件不满足）。**简化实现，不必判断方向**。
    

---

## 3.6 建堆 —— O(n) 的优化方法

**常规建堆**：逐个插入，每个 O(log n)，总 O(n log n)。

**优化建堆**：**从最后一个非叶子节点开始，向前依次 down**。

```cpp

for (int i = n / 2; i; i--) down(i);
```
**为什么是 O(n)？**

- 叶子节点（约 n/2 个）不需要 down。
    
- 倒数第二层节点（约 n/4 个）最多 down 1 层。
    
- 倒数第三层节点（约 n/8 个）最多 down 2 层。
    
- ……  
    总操作次数 = `n/4 * 1 + n/8 * 2 + n/16 * 3 + ...` < n（等比 * 等差，收敛）。
    

✅ **结论**：**从 n/2 开始 down 是线性时间复杂度**。

---

## 3.7 例题：堆排序（AcWing 838）

**题目**：输入 n 个数，从小到大输出前 m 小的数。

**思路**：

1. 将 n 个数建成小根堆。
    
2. 重复 m 次：输出堆顶，删除堆顶。
    

```cpp

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%d", &h[i]);
    siz = n;
    
    // 建堆
    for (int i = n / 2; i; i--) down(i);
    
    while (m--) {
        printf("%d ", h[1]);
        h[1] = h[siz--];
        down(1);
    }
    return 0;
}
```
---

## 3.8 进阶：带映射的堆（ph 与 hp）

**需求**：在堆中，不仅要支持**删除/修改任意位置的元素**，还要**根据插入顺序（第 k 个插入的数）进行操作**。  
例如：删除第 k 个插入的数，修改第 k 个插入的数。

**STL 优先队列做不到**，必须手写堆并维护**两个映射数组**。

### 📌 双映射的作用

- `ph[k]`：**第 k 个插入的数在堆数组中的下标**（pointer from heap index to node）。
    
- `hp[i]`：**堆数组中下标 i 的节点是第几个插入的**（pointer from node to heap index）。
    

**为什么需要两个？**

- 当我们知道插入序号 `k`，需要定位到堆中的位置 → `ph[k]`
    
- 当我们在堆中交换两个节点时，除了交换值，还要交换它们的**插入序号**，因此需要 `hp[i]` 知道这个位置原本是第几个插入的，然后更新 `ph[hp[i]]`。
    

**交换操作**（必须同时维护三个内容）：

```cpp

void heap_swap(int a, int b) {
    swap(ph[hp[a]], ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}
```
### 📌 插入操作（带映射）

```cpp

int m = 0;   // 当前插入的序号
void insert(int x) {
    siz++;
    m++;
    ph[m] = siz;
    hp[siz] = m;
    h[siz] = x;
    up(siz);
}
```
### 📌 删除第 k 个插入的数

```cpp

void del_kth(int k) {
    int pos = ph[k];          // 第 k 个插入的数在堆中的下标
    heap_swap(pos, siz);      // 与末尾交换
    siz--;
    down(pos);
    up(pos);
}
```
### 📌 修改第 k 个插入的数

```cpp

void update_kth(int k, int x) {
    int pos = ph[k];
    h[pos] = x;
    down(pos);
    up(pos);
}
```
🔴 **易错点**：

- **`ph` 和 `hp` 必须同步维护**，缺一不可。
    
- 交换时**必须先交换 ph，再交换 hp**（或顺序无所谓，但必须用 `heap_swap` 函数统一）。
    
- `down` 和 `up` 都要调用，因为新值可能大也可能小。
    

🟢 **记忆口诀**：  
“**双映射，双交换；ph 查位置，hp 记序号；交换节点三同步，删除修改两调整。**”

---

## 3.9 堆小结

| 场景               | 实现方式                     | 时间复杂度       |
| ---------------- | ------------------------ | ----------- |
| 普通堆（仅最值）         | `h`, `siz`, `down/up`    | O(log n) 单次 |
| 堆排序              | 建堆 O(n) + 取堆顶 O(n log n) | O(n log n)  |
| 带映射堆（Dijkstra 等） | 增加 `ph`、`hp`、`heap_swap` | O(log n) 单次 |

---

# 📊 本章知识小结 —— 考试前夜必看

|知识点|核心思想|零基础理解锚点|易错点|难度|
|---|---|---|---|---|
|**Trie树**|共享前缀的字符串树|查字典翻页|字符映射、结尾标记|★★★|
|**整数Trie**|二进制位串|优先走相反位|高位开始|★★★★|
|**并查集**|树形集合，根为代表|武林门派掌门|未初始化、忘记路径压缩|★★★★|
|**维护 size**|只对根有效|帮派人数|合并前找根|★★★★|
|**堆（数组）**|完全二叉树，父≤子|班级成绩树|下标从1开始|★★★|
|**down/up**|下沉/上浮|冒泡调整|递归边界、交换条件|★★★★|
|**建堆**|从 n/2 开始 down|从下往上修|循环条件 i--|★★★★|
|**带映射堆**|ph/hp 双射|插入顺序查位置|交换时三同步|★★★★★|

---

# 🎓 写在最后：树形结构的数组艺术

本章的三个数据结构——**Trie、并查集、堆**——都用**数组模拟了树**，却各有侧重：

- **Trie** 是多叉树，用 `son[N][26]` 存储孩子指针；
    
- **并查集** 是反向树（子→父），用 `p[N]` 存储父节点；
    
- **堆** 是完全二叉树，用数组下标计算父子关系。
    

**它们共同的灵魂**：**用下标代替指针，用数组模拟内存**。  
掌握它们，你不仅能在竞赛中写出高效代码，更能**从底层理解计算机如何管理层次化数据**。

**接下来你要做的**：

1. **Trie**：在纸上画出插入 `"abc"`、`"abd"` 后的 son 数组状态。
    
2. **并查集**：手写递归 `find`，模拟路径压缩过程。
    
3. **堆**：用 `n=10` 的数据，手动模拟从 `n/2` 开始建堆。
    
4. **带映射堆**：跟着代码走一遍插入、删除第 k 个的全过程。
# 第四章 数学知识（一）—— 从质数到最大公约数，数论的基石

**献给所有被试除范围、筛法边界、约数公式绕晕过的初学者**

> 🔴 **阅读提示**：本章延续**零基础友好型**写作风格——每个知识点先用**生活故事**引入，再用**代码逐行拆解**，最后用**易错点 + 记忆口诀**固化。  
> 🎯 **目标**：学完本章，你将彻底掌握**质数判定与分解**、**三大筛法（朴素/埃氏/线性）**、**约数的枚举与计数**、**约数和公式**以及**欧几里得算法**。从此数论入门不再劝退。

---

# 📌 开篇：数论 —— 算法竞赛的“数学味”

数论是研究整数性质的分支，在算法竞赛中无处不在。  
你可能害怕那些公式和定理，但**竞赛数论 90% 都是“暴力枚举 + 一点优化”**。

本章我们从最基础的**质数**开始，一路走到**最大公约数**，**不涉及高深数学**，**只讲代码怎么写、为什么这样写、坑在哪里**。

---

# 第一部分 · 质数 —— 整数的“原子”

## 一、质数的定义

> **质数（素数）**：大于 1 的自然数，如果只有 1 和它本身两个正约数，就是质数。  
> 例如：2, 3, 5, 7, 11, …  
> **合数**：除了 1 和本身还有其他约数。  
> **1 不是质数也不是合数**。

**生活类比**：质数就像**化学元素**，不能再分解成更小的整数乘积（除了 1×本身）。

---

## 二、质数的判定 —— 试除法

### 2.1 朴素想法：从 2 试到 n-1

最直观：检查 n 能否被 2,3,…,n-1 整除，只要有一个能整除，n 就是合数。


```cpp

bool is_prime(int n) {
    if (n < 2) return false;
    for (int i = 2; i < n; i++)
        if (n % i == 0) return false;
    return true;
}
```
**时间复杂度**：O(n) → 当 n = 10⁹ 时直接爆炸。

---

### 2.2 优化原理：约数成对出现

如果 d 是 n 的约数，那么 n/d 也是 n 的约数。  
且 **d 和 n/d 一个 ≤ √n，一个 ≥ √n**（除非 d = √n）。  
因此，**我们只需要检查 2 到 √n 之间是否有 n 的约数**。

**例子**：n = 36，约数对 (1,36), (2,18), (3,12), (4,9), (6,6)。  
√36 = 6，只需检查 2,3,4,5,6，发现 2 整除，即判定为合数。

---

### 2.3 循环条件的三种写法（🔥易错点）

|写法|代码|问题|
|---|---|---|
|❌ 错误|`for (int i = 2; i <= sqrt(n); i++)`|每次循环都调用 sqrt，效率低；sqrt 是浮点运算，可能产生精度误差|
|⚠️ 有风险|`for (int i = 2; i * i <= n; i++)`|当 n 接近 `INT_MAX`（约 21亿），`i*i` 可能溢出（如 i=46341 时平方 ≈ 21.5亿 > 2³¹-1）|
|✅ 推荐|`for (int i = 2; i <= n / i; i++)`|**无溢出，无浮点，最快**|

**为什么推荐 `i <= n / i`？**

- 避免了乘法溢出，且除法与乘法速度几乎无差异。
    
- 编译器会优化为一次计算，循环条件里 n/i 每次都会重新计算，但通常仍比 sqrt 快。
    

🔴 **记忆口诀**：“**判定质数试除法，根号范围最优化；循环条件写 n/i，安全高效不溢出。**”

---

### 2.4 完整代码

```cpp

bool is_prime(int n) {
    if (n < 2) return false;
    for (int i = 2; i <= n / i; i++)
        if (n % i == 0) return false;
    return true;
}
```
**时间复杂度**：O(√n)，n ≤ 10⁹ 轻松跑完。

---

## 三、分解质因数 —— 试除法

### 3.1 算术基本定理

> 任何一个大于 1 的自然数 n，都可以唯一地分解成有限个质数的乘积：
> 
> **n = p₁^α₁ × p₂^α₂ × … × pₖ^αₖ**  
> 其中 p₁ < p₂ < … < pₖ 均为质数，αᵢ 为正整数。

**生活类比**：质因数分解就像**给整数做基因测序**，每个质因子都是它的“基因片段”。

---

### 3.2 朴素思路：从小到大试除

从 i = 2 开始，如果 n % i == 0，就把 i 除干净（统计指数），然后 i++。  
直到 n 变成 1。

**问题**：如果 n 本身是质数，循环要一直试到 √n 吗？不需要——当 i 试到 √n 后，如果 n 还 >1，那剩下的 n 一定是质数（且 >√n）。

**关键性质**：**n 中最多只包含一个大于 √n 的质因子**。  
证明：如果有两个大于 √n 的质因子，乘积就大于 n，矛盾。

---

### 3.3 算法步骤

1. 从 i = 2 开始，当 i ≤ n / i 时循环：
    
    - 如果 n % i == 0，说明 i 是质因子（为什么是质数？因为之前已经把 2~i-1 的所有因子除干净了，所以 i 一定是质数）。
        
    - 统计 i 的指数，并不断 n /= i。
        
    - 完成后 i++。
        
2. 循环结束后，如果 n > 1，说明剩下的 n 就是那个大于 √n 的质因子，直接输出。
    

---

### 3.4 代码模板

```cpp

void divide(int n) {
    for (int i = 2; i <= n / i; i++) {
        if (n % i == 0) {
            int s = 0;
            while (n % i == 0) {
                n /= i;
                s++;
            }
            cout << i << ' ' << s << endl;   // 质因子 和 指数
        }
    }
    if (n > 1) cout << n << ' ' << 1 << endl; // 剩余的大质因子
}
```
🔴 **易错点**：

- **循环条件必须用 `i <= n / i`**，否则当 n 是质数时，循环会空转，但最后 `n > 1` 会处理，不会出错，但效率略低（其实没问题）。
    
- **不要修改外层循环的 i**，n 不断缩小，但 i 依然递增。
    
- **剩余因子判断**：必须用 `n > 1`，不能是 `n != 1`（当然可以），且确保这是质数。
    

**时间复杂度**：最好情况（n 是 2 的幂）O(log n)，最坏情况（n 是质数）O(√n)。  
平均远优于单纯的质数判定。

---

# 第二部分 · 筛法 —— 批量生成质数

## 一、朴素筛法 —— 把合数全部“叉掉”

### 1.1 思想

从 2 到 n，对于每个数 i，把它的所有倍数（2i, 3i, 4i, …）标记为合数。  
最后没被标记的就是质数。

**生活类比**：你有一张 1~n 的名单，从 2 开始，每遇到一个没被划掉的人，他就是“质数英雄”，然后把他所有的“小弟”（倍数）都开除。

---

### 1.2 代码实现

```cpp

const int N = 1000010;
int primes[N], cnt;     // 存储质数
bool st[N];             // st[x] = true 表示 x 是合数
void get_primes(int n) {
    for (int i = 2; i <= n; i++) {
        if (!st[i]) primes[cnt++] = i;
        for (int j = i + i; j <= n; j += i)
            st[j] = true;
    }
}
```
**时间复杂度**：

- i = 2 时，标记 n/2 次
    
- i = 3 时，标记 n/3 次
    
- …  
    总次数 = n(1/2 + 1/3 + … + 1/n) ≈ n(ln n + γ)  
    **O(n log n)**。
    

**实测**：n = 10⁶ 时约 146ms，勉强可用，但可优化。

---

## 二、埃氏筛法 —— 只筛质数的倍数

### 2.1 优化思路

朴素筛法对每个数 i 都筛倍数，但**如果 i 是合数，它的倍数其实已经被它的质因子筛过了**。  
例如：i = 6，倍数 12,18,… 已经被 i = 2 或 3 筛过。  
因此我们**只让质数来筛倍数**。

**实现**：把筛倍数的循环放到 `if (!st[i])` 内部。

---

### 2.2 代码模板

```cpp

void get_primes(int n) {
    for (int i = 2; i <= n; i++) {
        if (!st[i]) {
            primes[cnt++] = i;
            for (int j = i + i; j <= n; j += i)  // 也可以用 j = i*i 优化
                st[j] = true;
        }
    }
}
```
**进一步优化**：

- 从 `j = i * i` 开始，因为小于 `i*i` 的倍数已经被更小的质数筛过了（例如 i=5，5×2 被 2 筛，5×3 被 3 筛，5×4 被 2 筛）。
    
- 注意 **`i*i` 可能溢出**，但通常 n ≤ 10⁷，i ≤ 3162，没问题。若 n 更大，可强制转 `long long` 或仍用 `j = i + i`。
    

```cpp

if (!st[i]) {
    primes[cnt++] = i;
    for (long long j = (long long)i * i; j <= n; j += i)
        st[j] = true;
}
```
**时间复杂度**：  
由质数定理，1~n 中约有 n/ln n 个质数，每个质数筛倍数的次数 ≈ n/p。  
总次数 = n × (1/2 + 1/3 + 1/5 + … + 1/质数) ≈ n log log n。  
**O(n log log n)**，n = 10⁶ 时约 54ms，比朴素快 3 倍。

---

## 三、线性筛法（欧拉筛）—— 每个合数只被最小质因子筛一次

### 3.1 埃氏筛的缺陷

埃氏筛中，一个合数可能被多个质因子重复筛。  
例如 30 = 2×3×5，会被 2、3、5 各筛一次。  
我们希望**每个合数只被它的最小质因子筛一次**，达到 O(n) 线性复杂度。

---

### 3.2 核心思想

从小到大枚举每个数 i：

- 如果 i 没被筛过，它就是质数，加入 primes。
    
- 然后**不论 i 是质数还是合数**，都**用当前 i 去乘已筛出的质数**（从小到大），标记乘积为合数。
    
- 关键：**当 i % primes[j] == 0 时，停止内层循环**。
    

**为什么这样能保证每个合数只被最小质因子筛一次？**  
设合数 x = p_min × y，其中 p_min 是 x 的最小质因子。  
当 i = y 时，我们枚举到 p_min，此时 i % p_min == 0，标记 x 后 break。  
后续更大的质数 p' > p_min，标记的 x' = p' × y 的最小质因子是 p' 还是 p_min？  
由于 p' > p_min，且 p_min 整除 y，所以 p' × y 的最小质因子仍然是 p_min（因为 p_min < p'），不应该由 p' 来筛。  
因此 break 后，x 只被 p_min 筛一次。

---

### 3.3 代码模板

```cpp

const int N = 1000010;
int primes[N], cnt;
bool st[N];
void get_primes(int n) {
    for (int i = 2; i <= n; i++) {
        if (!st[i]) primes[cnt++] = i;
        for (int j = 0; primes[j] <= n / i; j++) {   // primes[j] * i <= n
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
```
🔴 **易错点**：

- **内层循环条件**：`primes[j] <= n / i`，防止 `primes[j] * i` 溢出，同时确保不越界。
    
- **不需要 `j < cnt`**，因为当 `i` 是合数时，`primes[j]` 会超过 n/i 而自然停止，或者遇到 `i % primes[j] == 0` 而 break；当 `i` 是质数时，`primes[j]` 会达到 `i` 本身，此时 `i % i == 0` 触发 break。
    
- **`st` 数组标记的是 `primes[j] * i`**，注意下标不要搞错。
    

**时间复杂度**：O(n)，每个合数被标记一次，每个质数被枚举若干次，总操作次数接近 n。  
**实测**：n = 10⁷ 时线性筛 155ms，埃氏筛 295ms，线性筛快一倍。

---

### 3.4 三种筛法对比

|算法|时间复杂度|空间复杂度|核心思想|适用 n 范围|
|---|---|---|---|---|
|朴素筛|O(n log n)|O(n)|筛每个数的倍数|≤ 10⁶|
|埃氏筛|O(n log log n)|O(n)|只筛质数的倍数|≤ 10⁷|
|线性筛|**O(n)**|O(n)|每个合数只被最小质因子筛一次|≤ 10⁷ 以上|

**建议**：竞赛中**无脑用线性筛**，代码短，效率高，思想清晰。  
但埃氏筛的思想（只筛质数倍数）在其他问题中很有用（如积性函数筛），需要理解。

🟢 **记忆口诀**：“**朴素筛，全筛遍；埃氏筛，只质数；线性筛，最小质，一次过，break停。**”

---

# 第三部分 · 约数 —— 整数的“因子”

## 一、试除法求一个数的所有约数

### 1.1 成对枚举

利用约数成对性质：若 d 是 n 的约数，则 n/d 也是 n 的约数。  
因此只需枚举 d ≤ √n，同时加入 d 和 n/d。  
**注意**：当 d == n/d 时（即 n 是完全平方数），只加入一次。

---

### 1.2 代码模板

```cpp

vector<int> get_divisors(int n) {
    vector<int> res;
    for (int i = 1; i <= n / i; i++) {
        if (n % i == 0) {
            res.push_back(i);
            if (i != n / i) res.push_back(n / i);
        }
    }
    sort(res.begin(), res.end());
    return res;
}
```
**时间复杂度**：O(√n) 枚举 + O(d log d) 排序（d 为约数个数，通常很小）。

🔴 **易错点**：

- **边界条件**：`i <= n / i` 而不是 `i <= sqrt(n)`，理由同质数判定。
    
- **去重**：当 i == n / i 时，不要重复加入。
    
- **排序**：约数通常按升序输出，需要排序（因为成对加入导致乱序）。
    

---

## 二、约数个数公式

### 2.1 公式推导

若 n = p₁^α₁ × p₂^α₂ × … × pₖ^αₖ，则 n 的任意约数 d 可写为  
d = p₁^β₁ × p₂^β₂ × … × pₖ^βₖ，其中 0 ≤ βᵢ ≤ αᵢ。  
每个 βᵢ 有 (αᵢ + 1) 种选择，因此**约数个数** = (α₁+1)×(α₂+1)×…×(αₖ+1)。

**生活类比**：你有 k 种口味的糖果，每种糖果有 αᵢ+1 种数量选择（0 颗到 αᵢ 颗），组合起来就是不同的“糖果礼盒”（约数）。

---

### 2.2 代码实现（基于质因数分解）

```cpp

unordered_map<int, int> factors; // 质因子 -> 指数
void get_factors(int n) {
    for (int i = 2; i <= n / i; i++) {
        while (n % i == 0) {
            factors[i]++;
            n /= i;
        }
    }
    if (n > 1) factors[n]++;
}
int divisor_count() {
    int res = 1;
    for (auto &p : factors) {
        res = res * (p.second + 1);
        // 若题目要求取模，则 res = (res * (p.second + 1)) % MOD;
    }
    return res;
}
```
---

## 三、约数和公式

### 3.1 公式推导

$$n 的所有正约数之和 = $$$$ (1 + p₁ + p₁² + … + p₁^α₁) × (1 + p₂ + p₂² + … + p₂^α₂) × … × (1 + pₖ + pₖ² + … + pₖ^αₖ)$$

**证明**：展开后每一项都是 p₁^β₁ × p₂^β₂ × … × pₖ^βₖ，且 βᵢ 取遍 0~αᵢ，正好是 n 的所有约数。  
项数 = (α₁+1)×…×(αₖ+1)，与约数个数公式一致。

---

### 3.2 等比数列求和优化

对于每个质因子 p，等比数列求和公式为：  
$$S = (p^(α+1) - 1) / (p - 1)  $$
但竞赛中常用**递推**以避免除法取模（若需要模 MOD，需用逆元）。

**递推**：  
初始 sum = 1  
循环 α 次： $$sum = sum * p + 1  $$
为什么？  
1 → 1×p + 1 = p+1 → (p+1)×p + 1 = p² + p + 1 → … 恰好是等比数列和。

```cpp

int divisor_sum(int p, int a) {
    int res = 1;
    while (a--) res = res * p + 1;   // 递推求 1 + p + ... + p^a
    return res;
}
```
---

## 四、经典例题 —— 求多个数乘积的约数个数

**题目**：给定 n 个数 a₁, a₂, …, aₙ，求它们乘积的约数个数，结果对 MOD=1e9+7 取模。

**思路**：

1. 将每个数质因数分解，用哈希表（unordered_map）累计所有质因子的总指数。
    
2. 应用约数个数公式，遍历哈希表，累乘 (指数+1) 并取模。
    

**代码框架**：

```cpp

unordered_map<int, int> mp;
for (int i = 0; i < n; i++) {
    int x; cin >> x;
    // 对 x 质因数分解，并累加到 mp 中
}
long long res = 1;
for (auto &[p, cnt] : mp) {
    res = res * (cnt + 1) % MOD;
}
cout << res << endl;
```
**易错点**：

- **指数可能很大**，需要开 long long 或直接取模。
    
- **质因数分解时注意最后剩余的大于 1 的因子**。
    

---

# 第四部分 · 最大公约数 —— 欧几里得算法

## 一、辗转相除法（欧几里得算法）

### 1.1 核心公式

**gcd(a, b) = gcd(b, a % b)**  
递归边界：当 b == 0 时，gcd(a, 0) = a。

**证明思路**：

- 若 d | a 且 d | b，则 d | (a - k×b) 对任意整数 k 成立，取 k = a/b 下取整，则 d | (a % b)。
    
- 反之，若 d | b 且 d | (a % b)，则 d | (a % b + b × (a/b)) = d | a。  
    因此 a,b 的公约数集合与 b,a%b 的公约数集合完全相同，最大公约数也相等。
    

---

### 1.2 代码实现

```cpp

int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}
```
**一行代码，堪称完美**。

**时间复杂度**：O(log min(a,b))，最坏情况是斐波那契数列相邻项。

---

### 1.3 最小公倍数

利用公式：**lcm(a, b) = a / gcd(a, b) * b**  
**注意**：先除后乘，防止溢出。

```cpp

int lcm(int a, int b) {
    return a / gcd(a, b) * b;
}
```
---

# 📊 本章知识小结 —— 考试前夜必看

| 知识点        | 核心思想                | 零基础理解锚点          | 易错点              | 难度    |
| ---------- | ------------------- | ---------------- | ---------------- | ----- |
| **质数判定**   | 试除法，枚举到 √n          | 找约数，成对出现         | 循环条件用 `i <= n/i` | ★★★   |
| **分解质因数**  | 从小到大除干净，剩余大质因子      | 质因数分解            | 剩余因子判断           | ★★★   |
| **朴素筛法**   | 筛每个数的倍数             | 全员标记             | 效率低              | ★★    |
| **埃氏筛法**   | 只筛质数的倍数             | 质数小弟清除           | `j=i*i` 防溢出      | ★★★   |
| **线性筛法**   | 每个合数只被最小质因子筛一次      | 质数乘当前 i，整除 break | break 条件         | ★★★★★ |
| **试除法求约数** | 成对枚举，注意去重           | 约数成双             | `i != n/i` 判断    | ★★★   |
| **约数个数公式** | (α₁+1)×...×(αₖ+1)   | 指数+1 相乘          | 别忘了取模            | ★★★★  |
| **约数和公式**  | (1+p+...+p^α) 相乘    | 等比数列积            | 递推求等比和           | ★★★★  |
| **欧几里得算法** | gcd(a,b)=gcd(b,a%b) | 大数变小             | 递归终止条件           | ★★    |

---

# 🎓 写在最后：数论不可怕，怕的是不落地

本章的每一个知识点，都不是用来背诵的，而是**用来写的**。

- 试除法边界写错一次，以后就会条件反射写 `i <= n/i`。
    
- 线性筛的 break 条件推导一遍，就再也不会忘。
    
- 约数个数公式推一遍，就明白为什么是“指数+1”相乘。
    

**给你的硬核建议**：

1. **质数判定**：手写 5 遍，故意写错 `i*i <= n` 看看溢出会发生什么。
    
2. **分解质因数**：用 `n = 2, 3, 4, ..., 100` 全部分解，验证唯一性。
    
3. **筛法**：三种筛法各写 3 遍，对比运行时间，理解线性筛的 break。
    
4. **约数**：手动计算 720 的约数个数和约数和，验证公式。
    
5. **欧几里得**：用 `gcd(1071, 462)` 手算一遍辗转相除过程。
# 基础算法课 Week1 习题课 —— 从快速选择到差分，代码与思维的磨刀石

**献给所有在习题课上“听懂但自己写不对”的初学者**

> 🔴 **阅读提示**：本章是算法基础课的**第一次习题课**，针对第一周讲授的**基础算法**进行题目精讲。  
> 涵盖 **快速选择、逆序对、浮点数二分、前缀和、差分（一维/二维）** 七道经典题目。  
> 每一题都会从**暴力思路**开始，引出**优化算法**，**逐行拆解代码**，并总结**易错点 + 记忆口诀**。  
> 🎯 **目标**：通过习题课，让你真正把“听懂的算法”变成“能AC的代码”。

---

# 📌 开篇：习题课的意义

很多同学听课很明白，一上机就懵。  
**这是因为“听懂”和“会写”之间隔着 100 行 bug。**  
习题课的目的就是**填平这道鸿沟**——通过手把手带写代码、分析边界、总结套路，让你下次遇到同类题时，**条件反射般写出正确代码**。

---

# 第一部分 · 快速选择 —— 第 k 个数

## 一、问题引入

> 给定一个长度为 n 的整数数组，求第 k 小的数。  
> 要求用**快速选择算法**，平均时间复杂度 O(n)。  
> 数据范围：n ≤ 10⁵，k ∈ [1, n]。

**如果不要求算法**：直接排序，输出第 k 个 → O(n log n)，也能过。  
**但面试/竞赛常考**：你能写出 O(n) 的快速选择吗？

---

## 二、快速选择 vs 快速排序

|算法|策略|时间复杂度|空间复杂度|
|---|---|---|---|
|快速排序|每次递归处理**左右两边**|O(n log n)|O(log n) 栈空间|
|快速选择|每次只递归**一边**（根据 k 的位置）|**平均 O(n)**，最坏 O(n²)|O(log n) 栈空间|

**核心区别**：快排需要把两边都排好序，快速选择只需要找到第 k 小的数，**不需要两边都有序**。

---

## 三、算法步骤

1. **确定分界点** x：取 q[l]、q[(l+r)/2] 或 q[r]（通常取中间值避免边界陷阱）。
    
2. **划分区间**：用双指针 i, j 将数组分成两部分，使得：
    
    - 左区间 [l, j] 的所有数 ≤ x
        
    - 右区间 [j+1, r] 的所有数 ≥ x
        
    - （注意：分界点 x 不一定在分界位置）
        
3. **计算左区间长度**：`sl = j - l + 1`。
    
4. **判断**：
    
    - 如果 k ≤ sl，则第 k 小的数在**左区间**，递归 `quick_select(l, j, k)`。
        
    - 否则，第 k 小的数在**右区间**，递归 `quick_select(j+1, r, k - sl)`。
        

---

## 四、代码模板（带防呆注释）



```cpp

#include <iostream>
using namespace std;
const int N = 100010;
int q[N];
int quick_select(int l, int r, int k) {
    if (l >= r) return q[l];          // 区间只剩一个数，就是答案
    int i = l - 1, j = r + 1;
    int x = q[l + r >> 1];            // 取中间值为分界点
    while (i < j) {
        do i++; while (q[i] < x);     // 找到左边第一个 >= x 的位置
        do j--; while (q[j] > x);     // 找到右边第一个 <= x 的位置
        if (i < j) swap(q[i], q[j]);
    }
    int sl = j - l + 1;               // 左区间长度
    if (k <= sl) return quick_select(l, j, k);
    else return quick_select(j + 1, r, k - sl);
}
int main() {
    int n, k;
    scanf("%d%d", &n, &k);
    for (int i = 0; i < n; i++) scanf("%d", &q[i]);
    printf("%d\n", quick_select(0, n - 1, k));
    return 0;
}
```
---

## 五、易错点与细节（🔴必看）

1. **指针初始值**：`i = l - 1, j = r + 1`，配合 `do-while` 确保指针先移动再判断。  
    ❌ 如果写成 `i = l, j = r` 并用 `while`，很可能导致边界问题。
    
2. **分界点选择**：推荐取 `q[(l+r)/2]`，可有效避免**左右边界陷阱**。  
    若取 `q[l]` 且数组已有序，则每次递归左区间为空，会无限递归 → 死循环。
    
3. **区间长度计算**：`sl = j - l + 1`，这是**左区间的元素个数**。  
    例如 `j = 3, l = 1`，则元素下标为 1,2,3 → 3-1+1=3 个 ✅
    
4. **递归终止条件**：`l >= r` 即可，因为保证答案一定在区间内，不会出现找不到的情况。
    
5. **时间复杂度**：
    
    - **平均**：每层递归处理 n, n/2, n/4, ... → 总操作 ≤ 2n → **O(n)**。
        
    - **最坏**：每次划分都极不平衡（例如数组已有序且分界点取边界）→ O(n²)。  
        但在竞赛中，取中间值作为分界点可**大概率避免**最坏情况。
        

🟢 **记忆口诀**：“**快速选择找第 k，划分只进一边去；左长 sl = j-l+1，k 小左大右减之。**”

---

## 六、举一反三

- 求第 k 大：转化为第 n-k+1 小。
    
- 求前 k 小（不要求顺序）：快速选择后，左区间即为前 k 小（无需完整排序）。
    

---

# 第二部分 · 归并排序求逆序对

## 一、故事引入

你是一名股票分析师，给定一支股票 n 天的价格，**如果某天价格高于之后某天的价格**，就是一次“卖出机会”。问总共有多少对这样的“高价在前、低价在后”的情况？

**这就是逆序对计数**。

---

## 二、逆序对的定义

对于数组 `a[1..n]`，若 `i < j` 且 `a[i] > a[j]`，则称 `(i, j)` 是一个逆序对。

**示例**：`[3, 2, 1, 4]`

- (3,2), (3,1), (2,1) → 共 3 个。
    

**最大数量**：当数组严格递减时，逆序对 = n(n-1)/2。  
当 n = 10⁵ 时，最大约 5×10⁹，**必须用 long long**。

---

## 三、暴力枚举 → O(n²) → 不可行

```cpp

long long cnt = 0;
for (int i = 0; i < n; i++)
    for (int j = i+1; j < n; j++)
        if (a[i] > a[j]) cnt++;
```
n=10⁵ 时约 5×10⁹ 次比较 → 绝对超时。

---

## 四、利用归并排序统计 —— 分治思想

归并排序的过程天然可以统计逆序对。

**分类**：一个区间 [l, r] 的逆序对 =

1. **左半内部**的逆序对（递归）
    
2. **右半内部**的逆序对（递归）
    
3. **跨左右**的逆序对（归并时统计）
    

**跨左右统计方法**：  
当 `q[i] > q[j]` 时（i 在左半，j 在右半），  
由于左半和右半都已经有序，那么**左半从 i 到 mid** 的所有数都 > q[j]，  
这些数与 q[j] 都构成逆序对，数量 = `mid - i + 1`。

---

## 五、代码模板

```cpp

#include <iostream>
using namespace std;
typedef long long LL;
const int N = 100010;
int q[N], tmp[N];
LL merge_sort(int l, int r) {
    if (l >= r) return 0;
    int mid = l + r >> 1;
    LL res = merge_sort(l, mid) + merge_sort(mid + 1, r);
    // 归并过程
    int i = l, j = mid + 1, k = 0;
    while (i <= mid && j <= r) {
        if (q[i] <= q[j]) tmp[k++] = q[i++];
        else {
            tmp[k++] = q[j++];
            res += mid - i + 1;      // 🔴 统计逆序对
        }
    }
    while (i <= mid) tmp[k++] = q[i++];
    while (j <= r) tmp[k++] = q[j++];
    for (i = l, k = 0; i <= r; i++, k++) q[i] = tmp[k];
    return res;
}
```
---

## 六、易错点与细节（🔴必看）

1. **统计时机**：**只有**在 `q[i] > q[j]` 时才累加，不要加在 `else` 外面。
    
2. **扫尾不统计**：左右剩余的元素不可能再构成跨逆序对（因为一边已空）。
    
3. **数据类型**：逆序对数量最大约 5×10⁹，**必须用 long long**。
    
4. **数组下标**：模板使用 0-based 或 1-based 均可，只要递归区间统一。
    

🟢 **记忆口诀**：“**逆序对，归并找，跨边统计 mid-i+1；左右递归各自算，扫尾莫加勿忘了。**”

---

# 第三部分 · 浮点数二分 —— 三次方根

## 一、问题引入

给定一个浮点数 x，求它的三次方根（保留 6 位小数）。  
要求：用二分法，精度控制到 1e-8。

---

## 二、浮点数二分的特殊性

- 无需考虑整数二分的 `±1` 边界问题。
    
- 唯一需要确定的是**区间范围**。
    
- **错误示范**：若 x = 0.01，直接取 [0, x] 作为区间，三次方根 0.1 不在区间内 → 找不到！
    
- **正确做法**：区间必须**覆盖所有可能解**。题目给的范围是 `-10000 ≤ x ≤ 10000`，而三次方根不会超出 `[-10000, 10000]`，所以取 `l = -10000, r = 10000`。
    

---

## 三、精度设置

保留 6 位小数时，**经验值**：`while (r - l > 1e-8)`。  
原理：保留 n 位小数，精度设为 `1e-(n+2)` 可保证四舍五入正确。

---

## 四、代码模板

```cpp

#include <iostream>
using namespace std;
int main() {
    double x;
    cin >> x;
    double l = -10000, r = 10000;
    while (r - l > 1e-8) {
        double mid = (l + r) / 2;
        if (mid * mid * mid >= x) r = mid;
        else l = mid;
    }
    printf("%.6lf\n", l);
    return 0;
}
```
🔴 **注意**：`mid * mid * mid` 不要写成 `mid^3`，因为 `^` 在 C++ 中是**按位异或**，不是乘方！

🟢 **记忆口诀**：“**浮点二分很简单，区间覆盖所有解；精度设为 1e-8，六位小数稳稳拿。**”

---

# 第四部分 · 前缀和 —— 快速区间求和

## 一、一维前缀和

### 1.1 问题

给定数组 a[1..n]，多次询问 [l, r] 的和。  
暴力每次 O(n)，不可行。  
**前缀和**：预处理 O(n)，查询 O(1)。

### 1.2 定义与公式

- `s[i] = a[1] + a[2] + ... + a[i]`，特别定义 `s[0] = 0`。
    
- 区间和：`sum[l, r] = s[r] - s[l-1]`。
    

### 1.3 代码

```cpp

int a[N], s[N];
for (int i = 1; i <= n; i++) {
    cin >> a[i];
    s[i] = s[i-1] + a[i];
}
while (m--) {
    int l, r;
    cin >> l >> r;
    cout << s[r] - s[l-1] << endl;
}
```
🔴 **易错点**：下标必须从 1 开始，否则 s[0] 无法定义为 0，且 `s[l-1]` 会越界。

---

## 二、二维前缀和

### 2.1 问题

给定 n×m 矩阵，多次询问子矩阵的和。  
**预处理** O(n×m)，**查询** O(1)。

### 2.2 递推公式

`S[i][j] = S[i-1][j] + S[i][j-1] - S[i-1][j-1] + a[i][j]`

**几何理解**（画图记忆）：

- `S[i-1][j]`：上方矩形
    
- `S[i][j-1]`：左方矩形
    
- `S[i-1][j-1]`：左上角矩形（被加了两次，需减去一次）
    
- 最后加上当前格子 `a[i][j]`
    

### 2.3 子矩阵求和公式

对于左上角 (x1,y1) 到右下角 (x2,y2)：

`sum = S[x2][y2] - S[x1-1][y2] - S[x2][y1-1] + S[x1-1][y1-1]`

同样遵循**容斥原理**。

### 2.4 代码模板

```cpp

int a[N][N], s[N][N];
// 预处理
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++) {
        cin >> a[i][j];
        s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j];
    }
// 查询
while (q--) {
    int x1, y1, x2, y2;
    cin >> x1 >> y1 >> x2 >> y2;
    cout << s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1] << endl;
}
```
🔴 **易错点**：

- 数组下标从 1 开始，输入时直接存入 `a[1][1]` 即可。
    
- 子矩阵求和时注意减 1 的位置，尤其是 `x1-1, y1-1`。
    
- 当 x1=1 或 y1=1 时，`x1-1=0` 行/列恰好为 0，需要提前将 `s[0][*]` 和 `s[*][0]` 初始化为 0（全局变量自动为 0）。
    

🟢 **记忆口诀**：“**二维前缀和，容斥要记牢：加左加上，减左上；子矩阵求和，大减小，加回左上角。**”

---

# 第五部分 · 差分 —— 区间修改的 O(1) 魔法

## 一、一维差分

### 1.1 问题

给定数组 a[1..n]，多次操作：将 [l, r] 区间每个数加上 c。最后输出整个数组。  
**暴力**：每次 O(n)，不可行。  
**差分**：构造差分数组 b，使得 a 是 b 的前缀和。

### 1.2 核心操作

- 对原数组 a 区间 [l, r] 加 c  
    ⇔ 差分数组：`b[l] += c`，`b[r+1] -= c`
    

**原理**：对 b 求前缀和后，l 及之后都会加上 c，直到 r+1 处减 c 抵消。

### 1.3 初始化

将原数组 a 初始视为全 0，然后通过 n 次插入操作构造 b：  
`for (int i = 1; i <= n; i++) insert(i, i, a[i]);`

其中 `insert` 函数就是上面的核心操作。

### 1.4 代码模板

```cpp

int a[N], b[N];
void insert(int l, int r, int c) {
    b[l] += c;
    b[r+1] -= c;
}
int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    // 初始化差分数组
    for (int i = 1; i <= n; i++) insert(i, i, a[i]);
    // 处理区间加操作
    while (m--) {
        int l, r, c;
        cin >> l >> r >> c;
        insert(l, r, c);
    }
    // 通过前缀和还原原数组
    for (int i = 1; i <= n; i++) {
        b[i] += b[i-1];
        cout << b[i] << ' ';
    }
    return 0;
}
```
🔴 **易错点**：

- `b[r+1]` 可能越界，数组大小至少开到 n+2。
    
- 还原时直接用 `b[i] += b[i-1]` 覆盖成前缀和，此时 b[i] 就是最终 a[i]。
    
- 初始化也可直接 `b[i] = a[i] - a[i-1]`，但 insert 法更统一，不易错。
    

🟢 **记忆口诀**：“**一维差分 O1 改，左加右减界外开；前缀和后得原值，初始化用插入来。**”

---

## 二、二维差分

### 2.1 问题

给定 n×m 矩阵，多次操作：将子矩阵 (x1,y1)~(x2,y2) 每个元素加 c。最后输出整个矩阵。

### 2.2 核心操作

对差分矩阵 b，使 a 是 b 的二维前缀和。  
**子矩阵加 c** ⇔ 修改 b 的四个角：

```text

b[x1][y1]     += c
b[x1][y2+1]   -= c
b[x2+1][y1]   -= c
b[x2+1][y2+1] += c
```
**几何解释**：

- `b[x1][y1] += c`：影响整个右下区域。
    
- 减去 `b[x1][y2+1]` 和 `b[x2+1][y1]` 消除多余部分。
    
- 加上 `b[x2+1][y2+1]` 补回多减的交集。
    

### 2.3 初始化

同样采用插入法：每个元素 `a[i][j]` 视为对子矩阵 (i,j)~(i,j) 加 `a[i][j]`。

### 2.4 代码模板

```cpp

int a[N][N], b[N][N];
void insert(int x1, int y1, int x2, int y2, int c) {
    b[x1][y1] += c;
    b[x1][y2+1] -= c;
    b[x2+1][y1] -= c;
    b[x2+1][y2+1] += c;
}
int main() {
    int n, m, q;
    cin >> n >> m >> q;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) {
            cin >> a[i][j];
            insert(i, j, i, j, a[i][j]);
        }
    while (q--) {
        int x1, y1, x2, y2, c;
        cin >> x1 >> y1 >> x2 >> y2 >> c;
        insert(x1, y1, x2, y2, c);
    }
    // 对 b 求二维前缀和得到最终矩阵
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1];
            cout << b[i][j] << ' ';
        }
        cout << endl;
    }
    return 0;
}
```
🔴 **易错点**：

- **数组大小**：b 至少开到 `[n+2][m+2]`，因为操作中有 `x2+1, y2+1`。
    
- **前缀和还原公式**：`b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1]`，这与二维前缀和预处理公式**不同**（这里是把 b 本身当作差分，对它求前缀和得到原数组），不要混淆。
    
- **输入顺序**：先输入矩阵，再输入 q 次操作。
    

🟢 **记忆口诀**：“**二维差分四角标，加左上加右减，左下减右下加，对称记忆不会差。**”

---

# 第六部分 · 社区运营答疑（简记）

本部分为课程附带的社区运营答疑，记录如下：

- **运营定位**：以低价优质课程（200元对应3000元服务）吸引用户，壮大技术社区。
    
- **留存手段**：题库 + 博客 + 问答 + 直播。
    
- **现存问题**：用户粘性不足，互动形式单一。
    
- **发展方向**：强化社区功能，增加互动场景。
    
- **邀请**：欢迎通过私聊加入运营团队。
    

_（该部分非算法内容，仅作课程记录保留。）_

---

# 📊 习题课知识小结

|题目|核心算法|关键代码/公式|易错点|难度|
|---|---|---|---|---|
|**第 k 个数**|快速选择|`quick_select(l,r,k)`，`sl = j-l+1`|指针初始化，分界点选择|★★★☆|
|**逆序对数量**|归并排序|`res += mid - i + 1`|统计时机，扫尾不加|★★★★|
|**数的三次方根**|浮点二分|`while(r-l > 1e-8)`|区间范围，`mid^3` 写法|★★★|
|**前缀和**|一维前缀和|`s[i]=s[i-1]+a[i]`，`sum=s[r]-s[l-1]`|下标从 1 开始|★★★|
|**子矩阵的和**|二维前缀和|`s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j]`|容斥公式|★★★★★|
|**差分**|一维差分|`insert(l,r,c)`：`b[l]+=c,b[r+1]-=c`|`b[r+1]` 越界|★★★☆|
|**差分矩阵**|二维差分|四角标记法|数组大小，还原公式|★★★★★|

---

# 🎓 写在最后：习题课的本质是“纠错”

很多同学抱怨：“我思路都对，为什么总是 WA？”  
**因为细节是魔鬼。**

- 快速选择的指针初始值错一个符号 → 死循环。
    
- 逆序对统计错放在 else 外面 → 答案翻倍。
    
- 二维差分数组开小 → 下标越界，直接 RE。
    
- 前缀和忘记 `s[0]=0` → 第一个查询永远错。
    

**习题课的意义，就是把这些魔鬼一个个揪出来，让你下次遇见它们时，能淡定地说：“我知道这里要小心。”**

**请你务必**：

- 每道题自己**手写三遍**，第一遍对着模板，第二遍半默写，第三遍完全闭卷。
    
- 把易错点整理成自己的“bug 清单”。
    
- 用测试样例故意把代码改错，看看会触发什么错误现象。
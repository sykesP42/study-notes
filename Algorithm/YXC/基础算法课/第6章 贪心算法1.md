# 第六章 贪心算法（一）—— 从“区间”到“果子”，局部最优的艺术


> 🎯 **目标**：学完本章，你将彻底掌握**区间选点、最大不相交区间、区间分组、区间覆盖**四大区间贪心模型，以及**合并果子（Huffman树）**的贪心策略与证明。从此贪心不再是“玄学”，而是有规律可循的“模型匹配”。

---

# 📌 开篇：贪心算法 —— 每一步都选当前最好的

**贪心算法**（Greedy Algorithm）是一种**在每一步选择中都采取当前状态下最好/最优的选择**，从而希望导致结果是全局最优的算法策略。

**生活类比**：

- 换零钱时，优先拿大面额硬币（但可能不是最优，例如币值1、3、4时凑6，贪心选4+1+1共3枚，而最优是3+3共2枚）。
    
- 所以**贪心不是万能**的，它只适用于具有**贪心选择性质**的问题——局部最优能推出全局最优。
    

本章我们重点攻克**区间类贪心**和**哈夫曼树**这两个最经典的贪心模型。  
**它们的共同特点**：先**排序**，再**扫描**，在扫描过程中做“短视”的决策。

---

# 第一部分 · 区间贪心四连 —— 排序是灵魂

## 一、区间选点 —— 最少的点覆盖所有区间

### 1.1 故事引入：雷达安装

海岸线是一条直线，海上有许多小岛，需要在海岸线上安装雷达，每个雷达覆盖半径为 d。  
问最少需要多少个雷达才能覆盖所有小岛？  
**等价问题**：每个小岛对应一个区间（雷达能覆盖该岛的x轴范围），选最少的点（雷达位置）使所有区间至少包含一个点。

**这就是区间选点问题**。

---

### 1.2 问题定义

给定 N 个闭区间 [aᵢ, bᵢ]，在数轴上选尽可能少的点，使得每个区间内**至少包含一个点**。  
输出最少点数。

**数据范围**：N ≤ 10⁵，坐标 ≤ 10⁹。

---

### 1.3 贪心策略 —— 按右端点排序，每次选右端点

**步骤**：

1. 将所有区间**按右端点从小到大排序**。
    
2. 初始化 `ed = -∞`（上一个选点的位置）。
    
3. 遍历每个区间：
    
    - 如果当前区间的左端点 > `ed`（说明该区间与之前选的点无交集）：
        
        - 选择**当前区间的右端点**作为新点。
            
        - `ed = 当前区间的右端点`。
            
        - 点数 +1。
            
    - 否则，该区间已被覆盖，跳过。
        

**为什么选右端点？**  
因为右端点是最靠右的位置，能最大可能地覆盖后续区间。

---

### 1.4 正确性证明（双向证明法）

设贪心算法得到的点数为 `cnt`，最优解点数为 `ans`。

- **`ans ≤ cnt`**：贪心算法给出的是一种合法方案，最优解是所有合法方案的最小值，所以 `ans ≤ cnt`。
    
- **`ans ≥ cnt`**：关键。贪心算法每次新增点，都是因为遇到了一个**与之前所有选点都不相交**的区间。这些区间彼此互不相交，且贪心算法在它们中各选了1个点。覆盖这些互不相交的区间**至少需要 cnt 个点**（每个区间至少1个点，且不能共用），所以 `ans ≥ cnt`。
    

因此 `ans = cnt`，贪心最优。

---

### 1.5 代码实现


```cpp

#include <iostream>
#include <algorithm>
using namespace std;
const int N = 100010;
struct Range {
    int l, r;
    bool operator< (const Range &W) const {
        return r < W.r;          // 按右端点排序
    }
} range[N];
int main() {
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) scanf("%d%d", &range[i].l, &range[i].r);
    
    sort(range, range + n);
    
    int res = 0, ed = -2e9;      // ed 上一个选的点，初始负无穷
    for (int i = 0; i < n; i++) {
        if (range[i].l > ed) {   // 当前区间与已选点无交集
            res++;
            ed = range[i].r;
        }
    }
    printf("%d\n", res);
    return 0;
}
```
🔴 **易错点**：

- **排序依据**：必须按右端点升序，不能是左端点（试一下就知错误）。
    
- **初始值**：`ed` 要足够小，例如 `-2e9` 或 `-1e9-10`，因为坐标可能为负数。
    
- **边界情况**：区间右端点可以重复，不影响算法。
    

🟢 **记忆口诀**：“**区间选点右端排，不交则选右端点。**”

---

## 二、最大不相交区间数量 —— 选最多的互不重叠区间

### 2.1 故事引入：活动安排

你需要安排活动，每个活动有开始时间和结束时间，同一时刻只能进行一个活动。  
问最多能安排多少个互不重叠的活动？

**这就是最大不相交区间数量问题**。

---

### 2.2 问题定义

给定 N 个区间 [aᵢ, bᵢ]，选择尽量多的区间，使得它们**两两不相交**（端点可以相交吗？通常开区间？闭区间时端点重合算相交吗？一般题目规定：**端点重合不算相交**，即可接在一起）。  
输出最大数量。

---

### 2.3 贪心策略 —— 与区间选点**完全一样**的代码

**步骤**：

1. 按右端点从小到大排序。
    
2. 初始化 `ed = -∞`。
    
3. 遍历每个区间：
    
    - 如果当前区间的左端点 > `ed`：
        
        - 选择该区间。
            
        - `ed = 当前区间的右端点`。
            
        - 数量 +1。
            
    - 否则跳过。
        

**为什么选右端点最小的？**  
这样能留下更多的空间给后面的区间。

---

### 2.4 证明

该算法选出的区间数量 = 区间选点问题中的点数。  
实际上，这两个问题是**对偶**的：

- 区间选点：点数 = 最大不相交区间数量。
    
- 最大不相交区间：数量 = 最少选点数。
    

证明思路类似：算法选出的区间互不相交，且数量等于贪心点数，而任何最优方案都不能超过这个数（因为需要那么多点来覆盖这些区间）。

**直接记忆**：**两个问题代码完全一样**，只是输出含义不同。

---

### 2.5 代码

完全复用区间选点的代码，输出 `res` 即为答案。

---

## 三、区间分组 —— 最少组数，组内区间互不重叠

### 3.1 故事引入：教室分配

有很多课程，每个课程有开始和结束时间，同一间教室同一时间只能上一节课。  
问最少需要多少间教室，才能安排所有课程？

**这就是区间分组问题**。

---

### 3.2 问题定义

给定 N 个区间 [aᵢ, bᵢ]，将它们分成尽量少的组，使得每组内的区间**两两不相交**。  
输出最少组数。

---

### 3.3 贪心策略 —— 按左端点排序，用小根堆维护各组最右端点

**关键观察**：当处理一个新区间时，如果它能够放入某个已有组，一定是**该组当前的最后一个区间的右端点 < 新区间的左端点**（因为组内区间不重叠，且我们已经按左端点排序处理，组内最后一个区间的右端点就是当前组的“边界”）。

为了快速找到这样的组，我们只需要**维护所有组当前右端点的最小值**（因为只有右端点最小的组最有可能接纳新区间）。  
如果新区间的左端点 > 最小右端点，则放入该组，并更新该组的右端点；否则，需要开新组。

**数据结构**：小根堆（优先队列）存储各组当前的右端点。

**步骤**：

1. 将所有区间**按左端点从小到大排序**。
    
2. 初始化一个空的小根堆。
    
3. 遍历每个区间：
    
    - 如果堆非空且堆顶（最小右端点）< 当前区间左端点，则说明可以放入该组：
        
        - 弹出堆顶。
            
        - 将当前区间的右端点入堆（更新该组的右端点）。
            
    - 否则：
        
        - 需要开新组，将当前区间的右端点入堆。
            
4. 最终堆的大小即为最少组数。
    

---

### 3.4 正确性证明

**可行性**：算法保证组内区间按左端点递增且不重叠（因为每次放入时都检查了左端点 > 组的最右端点）。  
**最优性**：当算法创建第 m+1 组时，说明当前区间与前面 m 个组的最后一个区间都有交集（即左端点 ≤ 那些组的右端点），因此存在 m+1 个区间**共享一个公共点**（可以证明是这个新区间的左端点被这些区间共同覆盖），所以至少需要 m+1 组。因此算法得到的组数是最少的。

---

### 3.5 代码实现

```cpp

#include <iostream>
#include <algorithm>
#include <queue>
using namespace std;
const int N = 100010;
struct Range {
    int l, r;
    bool operator< (const Range &W) const {
        return l < W.l;          // 按左端点排序
    }
} range[N];
int main() {
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) scanf("%d%d", &range[i].l, &range[i].r);
    
    sort(range, range + n);
    
    priority_queue<int, vector<int>, greater<int>> heap; // 小根堆，存各组右端点
    for (int i = 0; i < n; i++) {
        if (heap.size() && heap.top() < range[i].l) {
            heap.pop();                // 放入现有组
            heap.push(range[i].r);
        } else {
            heap.push(range[i].r);     // 开新组
        }
    }
    
    printf("%d\n", heap.size());
    return 0;
}
```
🔴 **易错点**：

- **排序规则**：区间分组必须**按左端点排序**，而不是右端点（可以思考反例）。
    
- **比较条件**：`heap.top() < range[i].l`，注意是严格小于（因为端点重合不算重叠）。
    
- **堆的更新**：放入现有组时，是弹出旧右端点，压入新区间的右端点。
    
- **初始堆空**：第一个区间直接入堆（开新组）。
    

🟢 **记忆口诀**：“**区间分组左端排，小根堆里存右界；左大堆顶可入组，否则新组建堆塞。**”

---

## 四、区间覆盖 —— 用最少区间覆盖目标线段

### 4.1 故事引入：水管维修

有一段从 s 到 t 的水管需要覆盖，你有许多长度不一的胶带（区间），每段胶带可以覆盖一段连续区域。  
问最少需要多少段胶带才能完全覆盖 [s, t]？

**这就是区间覆盖问题**。

---

### 4.2 问题定义

给定一个目标区间 [s, t]，以及 N 个区间 [aᵢ, bᵢ]。  
选择最少的区间，使得它们的并集**完全覆盖** [s, t]。  
如果无法覆盖，输出 -1。

---

### 4.3 贪心策略 —— 按左端点排序，每次选能覆盖起点且右端点最远的

**步骤**：

1. 将所有区间**按左端点从小到大排序**。
    
2. 初始化当前覆盖起点 `start = s`，结果计数 `res = 0`。
    
3. 使用指针 `i = 0` 扫描所有区间。
    
4. 当 `start < t` 时循环：
    
    - 在左端点 ≤ `start` 的区间中，选择右端点最大的那个，记为 `max_r`。
        
    - 如果 `max_r < start`（没有能覆盖当前起点的区间），则无解，返回 -1。
        
    - 否则，`res++`，`start = max_r`，更新起点。
        
    - 继续扫描（注意：已经处理过的区间可以跳过，但下一轮仍需从未处理的、左端点 ≤ 新 start 的区间中选择）。
        
5. 循环结束后，如果 `start ≥ t` 则输出 `res`，否则输出 -1。
    

**注意**：这需要使用**双指针**技巧：用 `i` 遍历区间，每次从 `i` 开始找所有左端点 ≤ 当前 start 的区间，同时记录最大右端点，然后 `i` 移到下一个未处理的区间。

---

### 4.4 正确性证明

**可行性**：算法每次都能覆盖一段，直到覆盖完目标或找不到。  
**最优性**：每次选择能覆盖当前起点且右端点最远的区间，这是局部最优，因为这样剩下的覆盖任务最短。可用**调整法**证明：任何最优方案中，第一次选择的区间若右端点不是最大，则可替换为最大右端点，不增加区间数量且不会使后续更难覆盖。

---

### 4.5 代码实现

```cpp

#include <iostream>
#include <algorithm>
using namespace std;
const int N = 100010;
struct Range {
    int l, r;
    bool operator< (const Range &W) const {
        return l < W.l;
    }
} range[N];
int main() {
    int st, ed, n;
    scanf("%d%d%d", &st, &ed, &n);
    for (int i = 0; i < n; i++) scanf("%d%d", &range[i].l, &range[i].r);
    
    sort(range, range + n);
    
    int res = 0;
    bool success = false;
    for (int i = 0; i < n; i++) {
        int j = i, max_r = -2e9;
        // 在所有左端点 ≤ st 的区间中，找右端点最大值
        while (j < n && range[j].l <= st) {
            max_r = max(max_r, range[j].r);
            j++;
        }
        
        if (max_r < st) {    // 没有能覆盖当前起点的区间
            res = -1;
            break;
        }
        
        res++;
        if (max_r >= ed) {
            success = true;
            break;
        }
        
        st = max_r;          // 更新起点
        i = j - 1;           // 跳过已经处理过的区间（注意循环后 i++）
    }
    
    if (!success) res = -1;
    printf("%d\n", res);
    return 0;
}
```
🔴 **易错点**：

- **双指针的 i 更新**：内层 while 会把 j 推到第一个左端点 > st 的区间，下一轮外循环 i 应该从 j 开始，但由于外循环 i++，所以我们设置 `i = j - 1`。
    
- **max_r 初始值**：必须足够小，例如 `-2e9`。
    
- **覆盖成功判断**：当 `max_r ≥ ed` 时即可终止。
    
- **无解判断**：`max_r < st` 表示当前起点无法被任何区间覆盖。
    

🟢 **记忆口诀**：“**区间覆盖左端排，双指针找最大右；无解即停更新点，成功覆盖终出界。**”

---

# 第二部分 · 哈夫曼树 —— 合并果子的贪心

## 一、故事引入：合并果子

你有一堆果子，每个果子有重量（正整数）。每次你可以合并任意两堆果子，消耗的体力等于两堆重量之和。  
你想把所有果子合并成一堆，问最少消耗多少体力？

**这就是哈夫曼树（Huffman Tree）问题**，也是最优二叉树问题。

---

## 二、贪心策略 —— 每次合并重量最小的两堆

**算法步骤**：

1. 将所有堆的重量放入一个小根堆（优先队列）。
    
2. 重复以下操作直到堆中只剩一堆：
    
    - 取出堆中最小的两个值 `a, b`。
        
    - 累加体力 `res += a + b`。
        
    - 将 `a + b` 入堆。
        
3. 输出 `res`。
    

**为什么正确？**  
这是一个典型的**贪心选择性质**问题：每次合并最小的两堆，得到的方案一定是最优的。  
证明方法通常采用**交换论证**或**归纳法**。

---

## 三、正确性证明（交换论证）

**核心命题**：在最优方案中，**权值最小的两个节点一定在树的**最深层**，并且可以互为兄弟。

**证明思路**：

1. 设最小的两个节点为 x, y。
    
2. 假设最优方案中，x 不在最深层，那么存在某个节点 z 比 x 大且比 x 深。交换 x 和 z 的位置，总代价会减少（因为 x 权值小，放在更深层会减少总路径长度）。矛盾。
    
3. 同理，x 和 y 可以交换到同一层成为兄弟节点，不影响总代价。
    
4. 因此，第一步合并 x 和 y 不会使总代价变差。
    

**递归证明**：合并 x 和 y 后，问题规模减1，且新堆权值为 x+y，剩余堆权值不变。对新问题继续应用贪心策略，由归纳法知整体最优。

---

## 四、代码实现

```cpp

#include <iostream>
#include <queue>
using namespace std;
int main() {
    int n;
    scanf("%d", &n);
    priority_queue<int, vector<int>, greater<int>> heap; // 小根堆
    while (n--) {
        int x;
        scanf("%d", &x);
        heap.push(x);
    }
    
    int res = 0;
    while (heap.size() > 1) {
        int a = heap.top(); heap.pop();
        int b = heap.top(); heap.pop();
        int c = a + b;
        res += c;
        heap.push(c);
    }
    
    printf("%d\n", res);
    return 0;
}
```
🔴 **易错点**：

- **数据类型**：结果可能较大，用 `int` 可能溢出，建议用 `long long`。
    
- **堆操作**：优先队列默认是大根堆，小根堆需要加 `greater` 参数。
    
- **循环条件**：`while (heap.size() > 1)`。
    

🟢 **记忆口诀**：“**合并果子用小根堆，每次取两最小堆；累加和再入堆，直到只剩一堆归。**”

---

# 📊 本章知识小结 —— 考试前夜必看

|问题类型|排序依据|核心数据结构|贪心决策|时间复杂度|易错点|
|---|---|---|---|---|---|
|**区间选点**|右端点|无|不交则选右端点|O(n log n)|ed 初始值|
|**最大不相交区间**|右端点|无|同上|O(n log n)|与上题代码相同|
|**区间分组**|左端点|小根堆（存各组右端点）|堆顶 < 左端则入组，否则新组|O(n log n)|排序规则、堆顶判断|
|**区间覆盖**|左端点|无（双指针）|左≤st时选最大右|O(n log n)|双指针 i 更新、无解|
|**合并果子**|无需排序|小根堆（存全部）|每次取两最小合并|O(n log n)|用 long long|

---

# 🎓 写在最后：贪心 = 排序 + 堆/双指针 + 证明

贪心算法的代码往往极其简短，但证明往往长而复杂。  
**对于竞赛，大多数时候我们不需要现场证明，而是要**识别模型**，并**套用模板**。

**区间问题四连**的共同模式：

- **排序**：按左端点或右端点，取决于目标。
    
- **扫描**：一次遍历，根据条件选择当前最优。
    
- **证明套路**：要么是**双向证明**（ans ≤ cnt, ans ≥ cnt），要么是**调整法**（若最优解与贪心解不同，可调整成贪心解且不更差）。
    

**哈夫曼树**：用小根堆模拟，证明用交换论证 + 归纳。

**给你的硬核建议**：

1. **区间选点**：手写并测试几组数据，理解为什么按右端点排序。
    
2. **区间分组**：自己构造反例，测试如果按右端点排序会错在哪里。
    
3. **区间覆盖**：重点理解双指针的移动过程，可以画图模拟。
    
4. **合并果子**：手动模拟小根堆过程，体会每次选最小的正确性。
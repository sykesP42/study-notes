# 基础算法课 Week4 习题课 —— 八数码问题，状态图与 BFS 的经典碰撞

“怎么表示状态”、“怎么判重”、“怎么恢复现场”???

> 🔴 **阅读提示**：本章是**第四周习题课**，专讲一道经典搜索题——**八数码问题**。  
> 这道题将 **BFS、状态表示、哈希判重、坐标转换** 等多个核心技巧融为一体，是**图论隐式建图**的绝佳范例。  
> 我们会从**暴力思路**出发，一步步推导出**BFS + 字符串 + 队列 + unordered_map** 的标准解法，**逐行拆解代码**，并总结**易错点 + 记忆口诀**。  
> 🎯 **目标**：学完本题，你将彻底掌握**如何把一个“移动拼图”抽象成图上最短路问题**，并能独立写出 BFS 状态搜索的完整框架。

---

# 📌 开篇：八数码 —— 人工智能的“启蒙题”

八数码问题（8-puzzle）是人工智能历史上赫赫有名的题目。  
一个 3×3 的棋盘，1~8 八个数字各出现一次，剩下一个格子是空格（记为 `x`）。  
每次只能将空格与**上、下、左、右**四个方向的数字交换位置。  
给定初始状态，问**最少需要几步**才能变成目标状态（通常为 `12345678x`）？

**难点**：

- 状态太多（9! = 362880 种排列），无法开普通数组存储。
    
- 每一步移动都会产生新状态，状态之间的关系构成**一张巨大的隐式图**。
    
- 要求**最短步数** → 必须用 **BFS**。
    

---

# 第一部分 · 问题建模 —— 状态就是图上的节点

## 一、状态表示 —— 如何把 3×3 矩阵存进队列？

我们不可能直接在 BFS 里存二维数组，那样判重、入队都很麻烦。  
**标准解法**：把矩阵**按行展开**，变成一个**长度为 9 的字符串**。

例如：


```text

1 2 3
4 x 5
6 7 8   →   "1234x5678"
```
**为什么用字符串？**

- 可以轻松放入 `unordered_map` 做判重。
    
- 交换空格和数字，就是交换字符串中两个字符。
    
- 输出路径时也很直观。
    

🔵 **关键**：**一维下标 ↔ 二维坐标** 的互相转换。

- 一维下标 `k` → 二维 `(x, y)`：`x = k / 3, y = k % 3`
    
- 二维 `(x, y)` → 一维下标：`idx = x * 3 + y`
    

---

## 二、状态转移 —— 移动空格

空格 `'x'` 可以在四个方向移动（上、下、左、右），与相邻位置的数字交换。  
**移动合法性**：新坐标必须在 [0, 2] 范围内。

**方向数组**（常用套路）：

```cpp

int dx[4] = {-1, 0, 1, 0};
int dy[4] = {0, 1, 0, -1};
```
顺序无所谓，常用**上、右、下、左**。

**转移步骤**（以一次移动为例）：

1. 找到 `'x'` 的一维下标 `k` → 二维 `(x, y)`。
    
2. 枚举四个方向，计算新坐标 `(a, b)`。
    
3. 若 `(a, b)` 合法：
    
    - 将字符串中 `k` 位置与 `a*3+b` 位置的字符**交换**，得到新状态 `new_s`。
        
    - 如果 `new_s` 未被访问过，记录距离，入队。
        
    - **必须把字符串换回来**（恢复现场），以便尝试下一个方向。
        

---

## 三、BFS 框架 —— 队列 + 哈希表

```cpp

queue<string> q;          // 存储待扩展的状态
unordered_map<string, int> d;   // 状态 → 步数（距离）
```
**过程**：

1. 初始状态入队，距离为 0。
    
2. 当队列非空：
    
    - 取出队头 `t`。
        
    - 如果 `t` 是目标状态，返回 `d[t]`。
        
    - 找到 `'x'` 位置，枚举四个方向，生成新状态 `new_t`。
        
    - 如果 `d.count(new_t) == 0`（未访问过），则 `d[new_t] = d[t] + 1`，`new_t` 入队。
        
3. 队列空了还没找到目标，返回 -1（无解）。
    

---

# 第二部分 · 代码实现 —— 逐行拆解

## 一、完整代码（AcWing 845）

```cpp

#include <iostream>
#include <algorithm>
#include <queue>
#include <unordered_map>
using namespace std;
int bfs(string start) {
    string end = "12345678x";          // 目标状态
    queue<string> q;
    unordered_map<string, int> d;
    
    q.push(start);
    d[start] = 0;
    
    int dx[4] = {-1, 0, 1, 0};
    int dy[4] = {0, 1, 0, -1};
    
    while (q.size()) {
        auto t = q.front();
        q.pop();
        
        if (t == end) return d[t];    // 找到目标
        
        int k = t.find('x');          // 空格的一维下标
        int x = k / 3, y = k % 3;     // 转为二维坐标
        
        for (int i = 0; i < 4; i++) {
            int a = x + dx[i], b = y + dy[i];
            if (a >= 0 && a < 3 && b >= 0 && b < 3) {
                swap(t[k], t[a * 3 + b]);   // 交换空格与数字 → 新状态
                if (!d.count(t)) {          // 判重
                    d[t] = d[t] + 1;        // 注意：这里的 t 已经是交换后的字符串
                    q.push(t);
                }
                swap(t[k], t[a * 3 + b]);   // 🔴 恢复现场！非常重要
            }
        }
    }
    return -1;   // 无解
}
int main() {
    string start;
    for (int i = 0; i < 9; i++) {
        char c;
        cin >> c;
        start += c;
    }
    cout << bfs(start) << endl;
    return 0;
}
```
---

## 二、逐行精讲（初学者必读）

### 🔵 第 7~10 行：初始化

```cpp

queue<string> q;
unordered_map<string, int> d;
```
- `queue` 存储**待扩展的状态**，先进先出，保证按层搜索。
    
- `unordered_map` 充当**访问标记 + 距离数组**，O(1) 平均判重。
    

### 🔵 第 15~17 行：取队头

```cpp

auto t = q.front(); q.pop();
if (t == end) return d[t];
```
- BFS 首次到达目标一定是最短距离，直接返回。
    

### 🔵 第 19~20 行：定位空格

```cpp

int k = t.find('x');    // 一维下标
int x = k / 3, y = k % 3;
```
- `string::find` 返回字符第一次出现的位置，空格唯一，放心用。
    

### 🔵 第 22~30 行：四个方向尝试

```cpp

for (int i = 0; i < 4; i++) {
    int a = x + dx[i], b = y + dy[i];
    if (a >= 0 && a < 3 && b >= 0 && b < 3) {
        swap(t[k], t[a * 3 + b]);          // 生成新状态
        if (!d.count(t)) {                 // 判重
            d[t] = d[t] + 1;               // 注意：这里 d[t] 是新的距离
            q.push(t);
        }
        swap(t[k], t[a * 3 + b]);          // 🔴 恢复现场！
    }
}
```
**最关键的一步**：先 `swap` 得到新状态，判重后**必须再 `swap` 回来**！  
如果不恢复，下一次循环的 `t` 已经被修改，方向就乱了。

---

# 第三部分 · 易错点与细节（🔴必看）

## 1. 恢复现场（最容易被忽略）

**为什么必须恢复？**  
因为我们要在**同一个原始状态 `t`** 的基础上尝试四个方向。  
如果不恢复，第一个方向成功交换后，`t` 已经变成了新状态，第二个方向操作的是这个新状态，而不是原来的状态。  
**后果**：状态错乱，BFS 变成无头苍蝇。

✅ **正确做法**：每次交换后，判断完立刻换回来。

---

## 2. 判重必须用 `d.count(t)`

```cpp

if (!d.count(t)) { ... }
```
因为 `unordered_map` 中不存在的键会返回 `end`，`count` 函数返回 0/1。  
**不要写** `if (d[t] == 0)`，因为 `d[t]` 如果不存在，会**默认插入一个值为 0 的元素**，这样判重就失效了！

---

## 3. 坐标转换别弄反

- 一维下标 `k` → 二维：`x = k / 3, y = k % 3`（行 = 除以3，列 = 余3）
    
- 二维 → 一维：`idx = x * 3 + y`
    

可以用小例子验证：第 0 行第 0 列 → `0*3+0=0` ✅；第 2 行第 2 列 → `2*3+2=8` ✅

---

## 4. 输入处理

题目输入是**一行 9 个字符**，可能有空格？通常是一行无空格字符串。  
保险起见，用循环读 9 个 `char` 并拼成 `string`。

---

## 5. 无解判断

BFS 结束后队列为空，返回 -1。  
**但是**：八数码问题**并非所有初始状态都有解**。  
无解判定可以通过**逆序对奇偶性**快速判断，与 BFS 无关，这里不展开（后文扩展有讲）。

---

## 6. 字符串效率

`string` 的 `swap` 是常数时间吗？实际上是**交换两个字符**，O(1)。  
`t.find('x')` 是 O(长度) = O(9)，常数极小，可以接受。  
`unordered_map` 操作 O(1) 均摊。  
总复杂度 O(9!)，但实际剪枝后远小于此。

🟢 **记忆口诀**：“**八数码，BFS，字符串里找位置；方向数组四行移，合法交换判重记；换完别忘恢复原，目标出现即距离。**”

---

# 第四部分 · 扩展知识 —— 不仅仅是 BFS

## 一、如何判断八数码是否有解？

**定理**：  
将 `x` 视为数字 0，把状态展成一维序列（去掉空格）。  
若初始序列的**逆序对数量**与目标序列的逆序对数量**奇偶性相同**，则有解；否则无解。

**原因**：空格左右移动不改变逆序对奇偶性，上下移动会改变偶数个逆序对（3 个位置循环移位，逆序对变化 ±2 或 0）。  
所以奇偶性不变。

**对于目标 `12345678x`**，展开为 `12345678`，逆序对为 0（偶数）。  
所以**初始状态去掉 x 后的序列逆序对数量必须是偶数**才有解。

**代码实现**（快速判断无解）：

```cpp

bool solvable(string s) {
    int cnt = 0;
    for (int i = 0; i < 9; i++)
        for (int j = i + 1; j < 9; j++)
            if (s[i] != 'x' && s[j] != 'x' && s[i] > s[j]) cnt++;
    return cnt % 2 == 0;
}
```
如果无解，直接输出 -1，不用 BFS。

---

## 二、A* 算法 —— 启发式搜索

八数码也是 A* 算法的经典例题。  
**估价函数**（曼哈顿距离）：每个数字当前位置到目标位置的**曼哈顿距离**之和。  
**优先队列**按 `f = g + h` 排序，效率远超 BFS。

但基础课只要求 BFS 版本，A* 属于提高内容。

---

## 三、双向 BFS

从起点和目标**同时 BFS**，相遇即找到最短路径，状态空间可减少约一半。  
实现时用两个队列和两个距离表，每轮扩展节点少的一边。

---

# 第五部分 · 小结 —— 八数码的通用价值

八数码问题虽然小，但包含的知识点非常密集：

|技巧|应用场景|
|---|---|
|**状态压缩**|字符串表示矩阵，通用方法|
|**坐标转换**|一维 ↔ 二维，任何棋盘问题|
|**隐式图 BFS**|状态空间不显式给出，通过移动生成新状态|
|**判重哈希表**|`unordered_map` 存储状态距离|
|**恢复现场**|在枚举方向时，必须恢复原状态|
|**方向数组**|二维平面移动的标准写法|
|**无解判定**|逆序对奇偶性，数论应用|

**掌握八数码 = 掌握状态搜索类问题的 70% 套路**。

---

# 📊 知识小结

|模块|核心内容|易错点|难度|
|---|---|---|---|
|**状态表示**|3×3 展成字符串|坐标转换|★★★|
|**状态转移**|交换空格与数字，方向数组|恢复现场|★★★★|
|**BFS 框架**|队列 + unordered_map|`d.count` 判重|★★★|
|**无解判断**|逆序对奇偶性|忽略空格|★★★☆|
|**代码实现**|读入、BFS、输出|输入格式|★★☆|

---

# 🎓 写在最后：从八数码看“状态搜索”的思维模型

很多初学者面对八数码时最大的困惑是：**我怎么知道要用 BFS？**  
**我怎么想到用字符串表示矩阵？**  
**我怎么处理判重和方向？**

其实，这是一套**通用解题流程**：

1. **定义状态** —— 找一个方便存储、比较、操作的数据结构。
    
2. **定义转移** —— 每个状态可以通过哪些规则生成新状态。
    
3. **明确目标** —— 我们需要找到从初始状态到目标状态的**最短路径**。
    
4. **选择算法** —— 所有边权为 1 → BFS；边权不同 → Dijkstra；状态空间巨大 → A*。
    
5. **实现框架** —— 队列/优先队列 + 判重数组/哈希表 + 前驱记录（如果需要路径）。
    

八数码正是这套流程的完美演示。  
**当你熟练掌握了这道题，你就掌握了状态搜索类问题（华容道、推箱子、拼图等）的核心套路**。

**给你的硬核建议**：

1. 把代码抄三遍，第一遍边抄边想，第二遍默写，第三遍闭卷。
    
2. 故意删掉恢复现场的那一行，看看会发生什么（会无限循环或错解）。
    
3. 自己构造一个无解的初始状态（比如 `12345678x` 交换两个非空数字），验证逆序对判断。
    
4. 尝试用 `vector<string>` 存路径（在 `d` 基础上加一个 `pre` 映射），输出完整移动步骤。
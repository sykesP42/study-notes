# 第一章 基础算法（三）—— 从“双指针”到“区间合并”，手把手带你吃透每一行代码


---

# 📌 开篇：这些算法到底在解决什么问题？

- **双指针**：把双重循环 O(n²) 变成单层循环 O(n) —— 靠的是**单调性**。
    
- **位运算**：直接操作二进制位，速度极快 —— 靠的是**补码**。
    
- **离散化**：把稀疏的大坐标压缩成连续的小下标 —— 靠的是**排序+二分**。
    
- **区间合并**：把一堆乱序区间合并成互不重叠的大区间 —— 靠的是**贪心**。
    

**它们都没有复杂的数学推导，但都是“思维体操”**。  
**当你学完本章，你会发现自己看问题的角度变了：**  
**从“我能暴力吗”变成“这里能用双指针吗？”**  
**从“数组开不下”变成“我可以离散化”。**

---

# 一、双指针算法 —— 两根手指，横扫 O(n²)

## 1.1 双指针是什么？—— 就像两根手指在纸上滑动

想象你在读一本密密麻麻的英文书，要找出**所有以字母 ‘a’ 开头的单词**。

**朴素做法**：

- 左手按在每个单词开头，右手从左手位置开始向右扫描，直到遇到空格，判断第一个字母是不是 ‘a’。
    
- 左手移动到下一个单词开头，重复。
    
- **每个字符被右手扫描多次**（每个单词都会被完整扫描一次），复杂度 O(n²) ❌
    

**双指针做法**（快慢指针）：

- 右指针 `i` 负责“探路”，不断向右移动。
    
- 左指针 `j` 负责“守门”，指向当前单词的开头。
    
- 当 `i` 遇到空格，输出 `s[j..i-1]`，然后把 `j` 直接跳到 `i+1`（跳过空格）。
    
- **每个字符只被访问一次**，复杂度 O(n) ✅
    

🔵 **这就是双指针的核心价值：利用“指针不回退”的性质，把嵌套循环变成并列循环。**

---

## 1.2 入门级案例：单词输出（保证每个单词间一个空格）

**题目**：输入一个由空格分隔的字符串（首尾无多余空格），输出每个单词（每行一个）。

**零基础手推**：


```text

字符串： "hello world algorithm"
指针 i = 0, j = 0
i = 0 → s[0]='h' ≠ ' ', i++
i = 1 → s[1]='e' ≠ ' ', i++
...
i = 4 → s[4]='o' ≠ ' ', i++
i = 5 → s[5]=' ' → 输出 s[j..i-1]="hello"
         j = i+1 = 6
i++ ...
```
**代码模板**（C风格，适合初学者理解指针移动）：

```cpp

char str[1010];
gets(str);
int n = strlen(str);
for (int i = 0, j = 0; i < n; i++) {
    if (str[i] == ' ') {
        // 输出单词
        for (int k = j; k < i; k++) cout << str[k];
        cout << endl;
        j = i + 1;   // j 跳到下一个单词开头
    }
}
// 处理最后一个单词（末尾没有空格）
if (j < n) {
    for (int k = j; k < n; k++) cout << str[k];
    cout << endl;
}
```
🔴 **易错点**：

- **忘记处理最后一个单词**：循环只在遇到空格时输出，字符串末尾可能没有空格。
    
- **`j = i + 1` 写成 `j = i`**：会导致下一个单词开头包含空格。
    
- **使用 `gets` 已被 C++14 移除**：竞赛中常用 `cin.getline()` 或 `fgets()`。
    

🟢 **记忆口诀**：  
“**双指针，同向走；右探路，左守门；遇空格，就输出；左跳右，不回头。**”

---

## 1.3 核心案例：最长连续不重复子序列（AcWing 799）

这是双指针**最经典、最能体现“单调性”**的题目。  
**很多同学能看懂代码，但想不通为什么它是 O(n)，今天就带你彻底搞懂。**

### 📌 问题重述

给定数组 `a[0..n-1]`，找出最长的连续子数组，其中没有重复元素。  
例：`[1,2,2,3,5]` → 最长是 `[2,3,5]` 或 `[1,2]`，长度 3。

### 📌 暴力枚举（你一定会）

```cpp

int res = 0;
for (int i = 0; i < n; i++)           // 子数组右端点
    for (int j = 0; j <= i; j++) {    // 子数组左端点
        if (check_no_repeat(j, i))    // O(n) 检查，总 O(n³)
            res = max(res, i - j + 1);
    }
```
**三个循环 → O(n³)**，不可接受。

### 📌 优化一：检查重复用哈希表

```cpp

for (int i = 0; i < n; i++)
    for (int j = 0; j <= i; j++) {
        // 用一个 bool 数组标记 [j,i] 内是否重复，O(i-j+1) → 总 O(n²)
    }
```
还是 O(n²)，n=10⁵ 依然超时。

### 📌 优化二：双指针 + 单调性

**关键观察**：  
当我们固定右端点 `i`，左端点 `j` **不会向左移动**（只会向右或不动）。  
为什么？

- 假设对于 `i`，最左边的无重复起点是 `j`。
    
- 当 `i` 向右移动到 `i+1`，新加入一个元素 `a[i+1]`。
    
- 如果 `a[i+1]` 在 `[j,i]` 中没有出现过，那么 `j` 可以不动，区间更长。
    
- 如果 `a[i+1]` 在 `[j,i]` 中出现了，那么 `j` 必须向右移动，**直到把那个重复元素排除出去**。
    
- **`j` 从来不需要向左移动** → 单调性成立。
    

**因此，我们可以用一个指针 `j` 表示当前区间左端点，并随着 `i` 增加而单调不减。**

### 📌 双指针滑动窗口代码（带逐行注释）

```cpp

#include <iostream>
using namespace std;
const int N = 100010;
int a[N], cnt[N];   // cnt[x] 记录数字 x 在当前窗口出现的次数
int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];
    
    int res = 0;
    for (int i = 0, j = 0; i < n; i++) {
        cnt[a[i]]++;                  // 1. 右指针扩展，加入新元素
        while (cnt[a[i]] > 1) {       // 2. 出现重复（一定是刚加的 a[i] 导致）
            cnt[a[j]]--;              //   左指针右移，移除 a[j]
            j++;                     
        }
        res = max(res, i - j + 1);    // 3. 更新答案
    }
    cout << res << endl;
    return 0;
}
```
🔴 **初学者最容易卡住的三个地方**：

1. **为什么 while 条件里检查的是 `cnt[a[i]] > 1` 而不是 `cnt[a[j]] > 1`？**  
    答：因为**重复一定是刚刚加入的 `a[i]` 导致的**（之前窗口是无重复的）。所以我们只盯着 `a[i]` 的出现次数，一旦它变成 2，说明窗口里有另一个和它相等的数，我们就移动 `j` 直到把它排出去。
    
2. **`cnt[a[j]]--` 之后为什么 j 要 ++？**  
    答：`a[j]` 被移出窗口，它的计数减 1，然后左指针指向下一个元素。这一行等价于：
    
    ```cpp
    
    cnt[a[j]]--;
    j++;
    ```
    习惯写法是 `cnt[a[j++]]--;`。
    
3. **为什么这个双循环是 O(n)？**  
    答：外层循环 `i` 走 n 步，内层 `while` 循环里 `j` **总共**也最多走 n 步（因为 `j` 只增不减）。所以总操作 ≤ 2n 次。
    

🟢 **记忆口诀**：  
“**右扩左缩查重复，计数数组来维护；重复必是右新入，左移直到无重复。**”

---

## 1.4 双指针的另一面：对撞指针（两数之和）

**场景**：有序数组，找两个数和为 target。  
**做法**：左指针 `i=0`，右指针 `j=n-1`，根据 `a[i]+a[j]` 与 target 的比较决定移动哪一边。

```cpp

int i = 0, j = n - 1;
while (i < j) {
    int sum = a[i] + a[j];
    if (sum > target) j--;
    else if (sum < target) i++;
    else { cout << i << ' ' << j; break; }
}
```
🔵 **单调性体现**：`i` 只右移，`j` 只左移，总移动 ≤ n 次。

---

# 二、位运算 —— 二进制的魔法

## 2.1 为什么位运算重要？—— 计算机的母语

C++ 的 `int` 在内存中是 **32 位二进制**，位运算直接对这些位进行操作，**比加减乘除快一个数量级**。  
更重要的是，很多算法（状态压缩、树状数组、N皇后）依赖位运算。

**初学者最大的障碍**：负数的补码表示。  
**一句话记住**：**`-x` 的二进制 = `~x + 1`**（取反加一）。

---

## 2.2 两个必备操作（肌肉记忆）

### 📌 操作1：取 n 的第 k 位（从低位0开始）

公式：`(n >> k) & 1`  
**过程**：

- `n >> k`：把第 k 位移到第 0 位（最低位）
    
- `& 1`：只保留最低位，其余清零
    

例：`n = 10` (二进制 1010)

- 第3位：`(10 >> 3) & 1 = (1) & 1 = 1` ✅
    
- 第2位：`(10 >> 2) & 1 = (2) & 1 = 0` ✅
    

### 📌 操作2：lowbit —— 返回 x 的最后一位 1 及其后面的 0

公式：`lowbit(x) = x & -x`

**为什么？**

- 负数在计算机中用补码表示：`-x = ~x + 1`
    
- 假设 `x = 1010...1000`（末尾连续 k 个 0，第 k+1 位是 1）
    
- `~x` 会把这位 1 变成 0，后面 0 变成 1
    
- `~x + 1` 会导致进位，**恰好把原数最后一位 1 保留，其余高位取反**
    
- `x & -x` 的结果就是 `000...1000`（只有那一位 1 和后面的 0）
    

**例**：`x = 12` (1100)

- `-x = ~12 + 1 = 0011 + 1 = 0100`（8位表示）
    
- `x & -x = 1100 & 0100 = 0100 = 4` ✅
    

**lowbit 有什么用？**

- **统计二进制中 1 的个数**：每次 `x -= lowbit(x)`，直到 0，减法次数就是 1 的个数。
    
- **树状数组**的基石。
    

---

## 2.3 经典例题：二进制中 1 的个数（AcWing 801）

**题目**：输入 n 个数，输出每个数的二进制表示中 1 的个数。

**方法一**（逐位判断）：

```cpp

int count_ones(int x) {
    int res = 0;
    while (x) {
        res += x & 1;
        x >>= 1;
    }
    return res;
}
```
⚠️ **负数右移是算术右移，高位补 1，会导致死循环**。  
✅ 所以通常只处理非负整数，或者用 `unsigned int`。

**方法二**（lowbit 法）：

```cpp

int lowbit(int x) {
    return x & -x;
}
int count_ones(int x) {
    int res = 0;
    while (x) {
        x -= lowbit(x);
        res++;
    }
    return res;
}
```
**优势**：循环次数 = 1 的个数，效率更高，且负数也可用（因为 lowbit 对负数同样有效）。

🟢 **记忆口诀**：  
“**消1就用lowbit，x&-x是真谛；循环减到零为止，个数就是减几次。**”

---

## 2.4 补码原理——为什么取反加一？

很多教材只说“负数的补码是取反加一”，但没解释**为什么**。

**数学本质**：我们希望 `x + (-x) = 0`。  
如果用 4 位二进制表示，`x = 3` (0011)，那么 `-3` 应该满足：  
`0011 + ? = 0000`（进位溢出丢弃）  
`? = 1101`，而 `1101` 正是 `~0011 + 1 = 1100 + 1 = 1101`。

✅ **结论**：补码是**为了使加法器能统一处理正负数**而设计的。**取反加一是为了满足加法结果为 0（溢出丢弃）**。

---

# 三、离散化 —— 大世界的压缩术

## 3.1 什么时候需要离散化？

**场景**：值域很大（比如 `-10⁹ ~ 10⁹`），但实际用到的坐标很少（比如 `10⁵` 个）。  
**直接开数组**：内存爆炸。  
**离散化**：把这些稀疏的坐标**映射成 0,1,2,...** 的连续自然数，然后用普通数组存储。

**典型问题**：**区间和**（AcWing 802）

- 数轴无限长，某些位置加值，多次查询区间和。
    
- 坐标范围极大，但操作次数 ≤ 10⁵。
    

---

## 3.2 离散化三步走（必背）

### 📌 第1步：收集所有可能用到的坐标

包括：

- 所有**修改操作**的位置
    
- 所有**查询操作**的左右端点
    

```cpp

vector<int> alls;   // 存放所有需要离散化的原始坐标
```
### 📌 第2步：排序 + 去重

```cpp

sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());
```
🔴 **注意**：必须先排序，`unique` 只能去除**相邻**重复元素。

### 📌 第3步：映射函数（二分查找）

```cpp

int find(int x) {
    // 返回 x 在 alls 中的下标（从1开始，方便前缀和）
    int l = 0, r = alls.size() - 1;
    while (l < r) {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return l + 1;   // 下标从1开始
}
```
🔵 **为什么从1开始**？为了前缀和公式 `s[r] - s[l-1]`，避免处理 `s[-1]`。

---

## 3.3 完整例题：区间和（带详细注释）

```cpp

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
typedef pair<int, int> PII;
const int N = 300010;   // n + 2m 最大 3e5
int a[N], s[N];         // 离散化后的数组和前缀和
vector<int> alls;
vector<PII> add, query;
int find(int x) {       // 映射函数
    int l = 0, r = alls.size() - 1;
    while (l < r) {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return l + 1;
}
int main() {
    int n, m;
    cin >> n >> m;
    
    // 读入加法操作
    for (int i = 0; i < n; i++) {
        int x, c;
        cin >> x >> c;
        add.push_back({x, c});
        alls.push_back(x);
    }
    
    // 读入查询操作
    for (int i = 0; i < m; i++) {
        int l, r;
        cin >> l >> r;
        query.push_back({l, r});
        alls.push_back(l);
        alls.push_back(r);
    }
    
    // 离散化核心
    sort(alls.begin(), alls.end());
    alls.erase(unique(alls.begin(), alls.end()), alls.end());
    
    // 处理加法
    for (auto &item : add) {
        int idx = find(item.first);
        a[idx] += item.second;
    }
    
    // 前缀和
    for (int i = 1; i <= alls.size(); i++) s[i] = s[i-1] + a[i];
    
    // 处理查询
    for (auto &item : query) {
        int l = find(item.first);
        int r = find(item.second);
        cout << s[r] - s[l-1] << endl;
    }
    
    return 0;
}
```
🔴 **易错点**：

- **忘记把查询的 l, r 加入 alls** → 二分查找时会找不到。
    
- **数组 a 和 s 的大小**：应该开 `alls.size() + 5`，而不是固定的 N。但这里 N 开 3e5+10 是安全的。
    
- **find 返回下标从1开始**，a[0] 和 s[0] 保持为 0。
    

---

## 3.4 手撕 unique 函数 —— 双指针去重

很多语言（如 Java/Python）没有现成的 unique，需要自己实现。  
**unique 的 C++ 实现原理**（双指针）：

```cpp

vector<int>::iterator unique(vector<int> &v) {
    int j = 0;
    for (int i = 0; i < v.size(); i++) {
        if (!i || v[i] != v[i-1])   // 第一个元素或与前一个不同
            v[j++] = v[i];
    }
    return v.begin() + j;   // j 是新长度
}
```
**用法**：

```cpp

sort(v.begin(), v.end());
v.erase(unique(v), v.end());
```
🔵 **核心思想**：

- `i` 指针遍历原数组
    
- `j` 指针指向**下一个不重复元素应该存放的位置**
    
- 当 `v[i]` 是第一个元素或与前一个不同时，就把它复制到 `v[j]`，然后 `j++`。
    

---

# 四、区间合并 —— 贪心法合并重叠区间

## 4.1 问题描述

给定 n 个区间 `[lᵢ, rᵢ]`，要求合并所有有交集的区间（端点相交也算），输出合并后的区间个数。

**例**：  
`[1,3] [2,6] [8,10] [15,18]` → 合并后 `[1,6] [8,10] [15,18]`，共 3 个。

---

## 4.2 贪心策略

**核心**：**按左端点排序，然后扫描。**

**为什么按左端点排序？**  
因为这样能保证**我们处理的区间左端点是递增的**，从而**当前区间是否与下一个区间重叠只取决于右端点**。

**三种情况**（画图理解）：

1. **完全包含**：新区间 `[l,r]` 在当前维护区间 `[st,ed]` 内部 → 不更新 `ed`。
    
2. **部分重叠**：新区间 `l ≤ ed` 且 `r > ed` → 更新 `ed = r`。
    
3. **无交集**：新区间 `l > ed` → 保存当前区间，开始新区间。
    

---

## 4.3 代码模板（带边界处理）

```cpp

vector<pair<int, int>> merge(vector<pair<int, int>> &segs) {
    vector<pair<int, int>> res;
    
    sort(segs.begin(), segs.end());   // 按左端点排序
    
    int st = -2e9, ed = -2e9;         // 初始化为负无穷
    for (auto &seg : segs) {
        if (ed < seg.first) {         // 无交集
            if (st != -2e9) res.push_back({st, ed}); // 保存上一个区间
            st = seg.first, ed = seg.second;         // 开始新区间
        } else {                     // 有交集
            ed = max(ed, seg.second); // 合并右端点
        }
    }
    
    if (st != -2e9) res.push_back({st, ed}); // 保存最后一个区间
    
    return res;
}
```
🔴 **易错点**：

- **忘记排序**：合并逻辑完全依赖左端点有序。
    
- **合并时 `ed = max(ed, seg.second)` 写成 `ed = seg.second`**：会丢失右端点扩展。
    
- **初始值设置**：必须用极小值，不能用 0（因为区间左端点可能是负数）。
    
- **最后一段区间没加进去**：循环结束后要补上。
    

🟢 **记忆口诀**：  
“**区间合并贪心法，左端排序是灵魂；无交集则存旧启新，有交集则右端取大。**”

---

# 📊 本章知识小结 —— 考试前夜必看

|知识点|核心思想|零基础理解锚点|易错点|难度|
|---|---|---|---|---|
|**双指针（快慢）**|利用单调性，指针不回退|右手探路，左手守门|while 条件、最后一段处理|★★★☆|
|**双指针（对撞）**|有序数组两头逼近|左小右大，大了右退，小了左进|边界越界|★★★|
|**位运算取第k位**|`(n >> k) & 1`|右移后按位与1|优先级 `>>` 低于 `&`，要加括号|★★|
|**lowbit**|`x & -x`|取反加一后按位与|误以为负数不能用|★★★|
|**离散化**|坐标压缩|收集、排序去重、二分映射|漏掉查询坐标、下标从0/1|★★★★|
|**unique实现**|双指针去重|第一个保留，不同就存|忘记排序、迭代器使用|★★★|
|**区间合并**|按左端点排序 + 贪心|合并重叠线段|忘排序、ed更新错误、漏最后一段|★★★|

---

# 🎓 写在最后：从“背模板”到“用模板”

本章的四个算法，代码都不长，但**每一个背后都有一个需要你“悟”的点**：

- **双指针**需要你**发现单调性**——为什么 `j` 不回退？
    
- **位运算**需要你**接受补码**——为什么 `-x = ~x+1`？
    
- **离散化**需要你**分步拆解**——为什么查询的坐标也要离散化？
    
- **区间合并**需要你**设计状态**——当前合并区间的 `st` 和 `ed` 怎么维护？
    

**这些“悟”的点，靠看是看不来的，必须亲手写、亲手错、亲手改。**

**给你的硬核建议**：

1. **双指针**：把「最长不重复子序列」的 `while` 条件改成 `cnt[a[j]] > 1`，看看会发生什么。
    
2. **位运算**：打印出 `-1` 的二进制（`unsigned` 视角），理解为什么全是 1。
    
3. **离散化**：故意把查询的 `l, r` 不加入 `alls`，看看二分查找会返回什么。
    
4. **区间合并**：自己造几个边界样例（如 `[1,2] [2,3]`、`[1,4] [2,3]`），手推合并过程。
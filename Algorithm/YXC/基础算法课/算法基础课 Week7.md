# 算法基础课 Week7 习题课 —— 异或消元、阶梯博弈、拆分Nim

**献给所有被异或方程组、台阶Nim、SG函数绕晕过的初学者**

> 🔴 **阅读提示**：本章是**第七周习题课**，讲解**高斯消元解异或线性方程组**、**台阶Nim游戏**、**拆分Nim游戏（SG函数）** 三个进阶知识点。  
> 每个部分都会从**暴力/朴素思路**出发，推导出**简洁高效的结论**，并给出**完整代码模板**，最后总结**易错点 + 记忆口诀**。  
> 🎯 **目标**：学完本章，你能**独立解决异或方程组、台阶Nim、拆分Nim类题目**，并初步理解**SG函数**的核心思想。

---

## 📌 开篇：本周的三个“异或”故事

- **异或线性方程组** —— 把普通加减法换成异或运算，高斯消元依然有效。
    
- **台阶Nim** —— 看似复杂的阶梯取石子，最终结论仅与**奇数台阶石子异或**有关。
    
- **拆分Nim** —— 经典Nim的变形，需引入**SG函数**，通过**mex**和**递归**求解。
    

**它们的共同点**：都使用**异或**作为核心运算，都是**从复杂规则中提炼出简单结论**的典范。

---

# 第一部分 · 高斯消元解异或线性方程组

## 一、问题引入

![[Pasted image 20260213143740.png]]

---

## 二、与普通高斯消元的对比

|对比项|普通高斯消元（实数）|异或高斯消元|
|---|---|---|
|运算|加减乘除|**异或**（不进位加法）|
|主元归一|行除以主元|**不需要**（主元已是1）|
|消元|行倍加|**行异或**（当前行异或到下方行）|
|精度|需浮点 `eps`|**无精度问题**|
|复杂度|O(n³)|**O(n³)** 但常数极小|

**核心相同点**：

- 枚举列，找非零行，交换到当前行
    
- 用当前行消去下方所有行的当前列
    
- 最后判断解的情况（唯一解/无解/无穷多解）
    

---

## 三、算法步骤（异或版）

1. **初始化**：增广矩阵 `a[1..n][1..n+1]`，系数为 0/1。
    
2. **消元**（枚举列 c）：
    
    - 在未处理的行中找第 c 列为 1 的行 `t`。
        
    - 若找不到，`continue`（该列自由变量）。
        
    - 将第 `t` 行与当前行 `r` 交换。
        
    - 用当前行 `r` 异或掉下方所有行第 c 列的 1（`a[i][c] == 1` 时，`a[i][j] ^= a[r][j]`）。
        
3. **判断解**：
    
    - 若出现 `0 == 1` 的行 → **无解**。
        
    - 若有效方程数 < 未知数个数 → **无穷多解**。
        
    - 否则 → **唯一解**（从下往上回代）。
        

---

## 四、代码模板


```cpp

#include <iostream>
#include <cmath>
using namespace std;
const int N = 110;
int a[N][N];
int n;
int gauss() {
    int r, c;
    for (r = 0, c = 0; c < n; c++) {
        int t = r;
        for (int i = r; i < n; i++)
            if (a[i][c]) { t = i; break; }
        if (!a[t][c]) continue;
        // 交换到当前行
        for (int j = c; j <= n; j++) swap(a[t][j], a[r][j]);
        // 消去下方所有行的当前列
        for (int i = r + 1; i < n; i++)
            if (a[i][c])
                for (int j = c; j <= n; j++)
                    a[i][j] ^= a[r][j];
        r++;
    }
    if (r < n) {
        for (int i = r; i < n; i++)
            if (a[i][n]) return -1;   // 无解
        return 0;                     // 无穷多解
    }
    // 回代
    for (int i = n - 1; i >= 0; i--)
        for (int j = i + 1; j < n; j++)
            a[i][n] ^= a[i][j] * a[j][n];   // 注意是异或
    return 1;   // 唯一解
}
```
🔴 **易错点**：

- 消元时**必须用异或**，不能用加减。
    
- 回代时系数乘法 `a[i][j] * a[j][n]` 在 0/1 下就是逻辑与，然后异或。
    
- 判断自由变量时，当前列全为 0 则 `continue`。
    

🟢 **记忆口诀**：

> **异或消元像极了普通版，加变异或，除不再有；  
> 唯一无穷看秩数，0=1 即无解。**

---

# 第二部分 · 台阶 Nim 游戏

## 一、游戏规则

有 n 级台阶（1 ~ n），每级台阶上有若干石子。  
**操作**：选择一个台阶 i，**至少取走 1 个石子**，并**放到第 i-1 级台阶**上。  
地面视为第 0 级台阶，石子放到地面后**不可再移动**。  
**无法操作者判负**。

**示例**：台阶石子数 [2,1,3]（三级）。  
先手可以从第 3 级取 1 个放到第 2 级，变为 [2,2,2]；之后可用对称策略获胜。

---

## 二、关键结论 —— **只考虑奇数台阶**

**定理**：台阶 Nim 游戏的胜负仅取决于**所有奇数级台阶石子数的异或值**。

- 若异或值 ≠ 0 → **先手必胜**
    
- 若异或值 = 0 → **先手必败**
    

**为什么忽略偶数台阶？**

- 当对手操作偶数台阶时，你可以通过**将相等数量的石子从该台阶上一级挪下来**，保持奇数台阶石子数不变。
    
- 当对手操作奇数台阶时，你总能在之后的操作中**维持奇数台阶异或为 0**。
    
- 最终石子全部归零时，必然轮到对手操作。
    

---

## 三、代码实现

```cpp

#include <iostream>
using namespace std;
int main() {
    int n;
    cin >> n;
    int res = 0;
    for (int i = 1; i <= n; i++) {
        int x;
        cin >> x;
        if (i & 1) res ^= x;   // 只异或奇数台阶
    }
    if (res) puts("Yes");
    else puts("No");
    return 0;
}
```
🔴 **易错点**：

- 台阶编号通常从 1 开始，地面是 0 级，**0 级不计入**。
    
- 石子数范围很大（≤ 1e9），异或直接 `int` 即可。
    

🟢 **记忆口诀**：

> **台阶 Nim 并不难，奇台异或定输赢；  
> 偶台只是传送带，对手动我跟着还。**

---

# 第三部分 · 拆分 Nim 游戏 —— SG 函数入门

## 一、游戏规则

有 n 堆石子，每堆石子数量任意。  
**操作**：选择**一堆**石子，**取走整堆**，然后**放入两堆规模更小的石子**（新堆规模可以为零，且两堆总数可以大于原堆数）。  
**无法操作者判负**（即所有堆均为 0）。

**关键**：操作后石子总数**可能增加**，但**每堆石子的最大规模严格递减**（因为新堆 < 原堆），因此游戏必然终止。

---

## 二、SG 函数基础

- 将**每一堆石子**看作一个**独立子游戏**。
    
- 整个游戏的 SG 值 = **所有堆 SG 值的异或**。
    
- 若异或 ≠ 0 → 先手必胜；否则先手必败。
    

**对于一堆石子数量 x**：

- 操作：将 x 拆成两堆 `(i, j)`，满足 **0 ≤ j ≤ i < x**（注意：可拆成 `(0,0)`，即直接拿走）。
    
- 新局面的 SG 值 = `sg(i) ^ sg(j)`。
    
- 当前局面 `sg(x)` = **mex{ 所有可能的 sg(i) ^ sg(j) }**。
    

**mex**（Minimum Excluded Value）：集合中未出现的最小非负整数。

---

## 三、递归计算 SG（记忆化搜索）

```cpp

#include <iostream>
#include <cstring>
#include <unordered_set>
using namespace std;
const int N = 110;   // 根据题目规模调整
int f[N];            // 存储 sg[x]，-1 表示未计算
int sg(int x) {
    if (f[x] != -1) return f[x];
    unordered_set<int> S;
    for (int i = 0; i < x; i++)          // 第一堆
        for (int j = 0; j <= i; j++)    // 第二堆 <= 第一堆
            S.insert(sg(i) ^ sg(j));
    // mex 操作
    for (int i = 0; ; i++)
        if (!S.count(i)) return f[x] = i;
}
int main() {
    int n;
    cin >> n;
    memset(f, -1, sizeof f);
    int res = 0;
    for (int i = 0; i < n; i++) {
        int x;
        cin >> x;
        res ^= sg(x);
    }
    if (res) puts("Yes");
    else puts("No");
    return 0;
}
```
🔴 **易错点**：

- 拆分时 **`i` 从 0 到 x-1**，`j` 从 0 到 `i`（避免重复枚举 `(i,j)` 和 `(j,i)`）。
    
- 新堆规模可以为零，对应 `i=0` 或 `j=0`。
    
- 必须**记忆化**，否则递归爆炸。
    
- 本题 x 范围通常较小（如 ≤ 100），可预处理；若 x 很大需找规律。
    

🟢 **记忆口诀**：

> **拆分 Nim 用 SG，mex 操作记心间；  
> 两堆异或得后继，递归缓存快如电。**

---

# 第四部分 · 课程总结与预告

## 一、本周习题课核心内容回顾

|知识点|核心思想|关键代码/公式|难度|
|---|---|---|---|
|**异或高斯消元**|异或代替加减，消成上三角|`a[i][j] ^= a[r][j]`|★★★★|
|**台阶 Nim**|只关心奇数台阶异或|`if (i&1) res ^= a[i]`|★★★★|
|**拆分 Nim**|SG 函数 + mex + 记忆化|`sg(x)=mex{ sg(i)^sg(j) }`|★★★★★|

## 二、后续课程安排

- **动态规划专题**（预计 2~3 节课）：
    
    - 背包问题（01背包、完全背包、多重背包）
        
    - 线性 DP（LIS、LCS）
        
    - 区间 DP（石子合并）
        
    - 状态压缩 DP（铺砖问题）
        
    - 树形 DP、记忆化搜索（滑雪）
        
- **贪心算法 + 时空复杂度分析**（最后 2 节课）
    

## 三、学习建议

- 数学章节（数论、组合、博弈）题目较多，**务必手推每个结论**，不能只背模板。
    
- 动态规划是重中之重，**提前预习基础模型**（01背包、LIS、LCS），课上跟紧思路。
    
- 遇到难题善用 **“暴力 → 优化 → 结论”** 的思考链。
    

---

# 📊 知识小结表

|模块|核心考点|易错点|掌握程度|
|---|---|---|---|
|异或高斯消元|消元过程、解的判定|异或运算、自由列处理|★★★★|
|台阶 Nim|奇数台阶异或结论|台阶编号从 1 开始|★★★★|
|拆分 Nim|SG 函数定义、mex 计算|双重枚举不重不漏|★★★★★|

---

> 🎓 **最后寄语**：  
> 博弈论题目往往**结论简洁，推导烧脑**，但一旦理解本质，代码通常极短。  
> 本周的三道题，正是**从复杂规则到简单结论**的绝佳训练。  
> 请务必**亲手画出 SG 函数的前几项**，**手动模拟台阶 Nim 的对称策略**，**推导异或消元与普通消元的异同**。  
> 这些功夫花下去，**下次遇到同类题，你就是最快 AC 的那个人**。
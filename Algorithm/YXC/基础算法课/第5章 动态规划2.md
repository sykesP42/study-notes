# 第五章 动态规划（二）—— 线性DP与区间DP，从“路径”到“区间”的思维跃迁

**
> 🎯 **目标**：学完本章，你将彻底掌握**数字三角形、最长上升子序列、最长公共子序列、编辑距离、石子合并**这五大经典DP问题的思路与代码，并深刻理解**线性DP**和**区间DP**的通用解题框架。从此DP不再是玄学，而是有迹可循的思维体操。

---

# 📌 开篇：从背包到序列 —— DP的两种新面孔

上一章我们学习了**背包问题**，核心是**在一组物品中做选择**，状态维度通常为“前 i 个物品”和“剩余容量”。  
这一章我们将进入**线性DP**和**区间DP**的世界：

- **线性DP**：研究对象是**序列**（数组、字符串），状态沿着**线性方向**转移（如数字三角形的向下走、最长上升子序列的结尾位置、最长公共子序列的双串匹配）。
    
- **区间DP**：研究对象是**区间**，状态表示**连续的一段区间**，通过枚举**分界点**合并左右子区间（如石子合并）。
    

**背包是“选或不选”的决策，线性DP是“走到哪里”的决策，区间DP是“从哪分开”的决策**。

---

# 第一部分 · 线性DP —— 沿着序列递推

## 一、数字三角形 —— DP的“Hello World”

### 1.1 故事引入：金字塔寻宝

你站在金字塔顶端，只能向左下或右下移动，每个格子里有金币（可能有负数）。  
你要找一条从顶到底的路径，使获得的金币总和最大。

**这就是数字三角形问题**，它如此经典，以至于被称为**动态规划的“Hello World”**。

---

### 1.2 状态表示 —— 从起点到(i,j)的最大和

我们用 `f[i][j]` 表示**从顶部走到第 i 行第 j 列的所有路径中，路径和的最大值**。

- **集合**：所有从 (1,1) 走到 (i,j) 的路径。
    
- **属性**：路径和的最大值（Max）。
    

**为什么这样定义？**  
因为我们要求的是**从顶到底**的最大路径和，而底部的每个位置都可能作为终点，所以最后需要遍历最后一行的 `f[n][j]` 取最大值。

---

### 1.3 状态转移 —— 从哪来？

到达 (i,j) 只有两种可能：

1. **从左上方来**：上一步在 (i-1, j-1)，路径和为 `f[i-1][j-1] + a[i][j]`。
    
2. **从右上方来**：上一步在 (i-1, j)，路径和为 `f[i-1][j] + a[i][j]`。
    


```text

f[i][j] = max(f[i-1][j-1], f[i-1][j]) + a[i][j]
```
**边界处理**：

- 当 `j=1` 时，没有左上方，此时 `f[i-1][j-1]` 是无效的（我们将其初始化为负无穷）。
    
- 当 `j=i` 时，没有右上方（因为每行只有 i 列），同样初始化为负无穷。
    

**技巧**：将数组下标从 1 开始，并将 `f[0][*]` 和 `f[*][0]` 以及多余列初始化为 `-INF`，这样转移方程无需特殊判断。

---

### 1.4 代码实现（自上而下）

```cpp

#include <iostream>
#include <algorithm>
using namespace std;
const int N = 510, INF = 1e9;
int a[N][N], f[N][N];
int main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= i; j++)
            cin >> a[i][j];
    // 初始化所有f为负无穷
    for (int i = 0; i <= n; i++)
        for (int j = 0; j <= i+1; j++)   // 注意列要多初始化一个，因为 j+1 可能用到
            f[i][j] = -INF;
    f[1][1] = a[1][1];   // 起点
    for (int i = 2; i <= n; i++)
        for (int j = 1; j <= i; j++)
            f[i][j] = max(f[i-1][j-1], f[i-1][j]) + a[i][j];
    int res = -INF;
    for (int j = 1; j <= n; j++) res = max(res, f[n][j]);
    cout << res << endl;
    return 0;
}
```
🔴 **易错点**：

- **初始化范围**：必须把 `f[0][0]`、`f[0][1]` 等都用负无穷填满，因为 `i=2` 时 `f[1][0]` 会被访问（当 `j=1` 时 `f[i-1][j-1] = f[1][0]`），如果不初始化，默认0可能导致错误（特别是当数字可能为负时）。
    
- **列多初始化一列**：因为 `j` 最大为 `i`，但 `f[i-1][j]` 当 `j=i` 时，需要 `f[i-1][i]`，虽然这一列不存在，但为了统一代码，多初始化一列并设为负无穷，避免越界。
    

🟢 **记忆口诀**：“**数字三角形，从上往下走；左上来右上来，取大加自己；边界负无穷，最后找最大。**”

---

### 1.5 优化：自底向上 —— 更简洁的写法

我们也可以**从下往上**推：  
`f[i][j]` 表示从 (i,j) 出发**向下走到最后一层**的最大路径和。  
那么转移是：

```text

f[i][j] = max(f[i+1][j], f[i+1][j+1]) + a[i][j]
```
**边界**：最后一层的 `f[n][j] = a[n][j]`。  
**答案**：`f[1][1]`，无需遍历最后一行。

```cpp

for (int j = 1; j <= n; j++) f[n][j] = a[n][j];
for (int i = n-1; i >= 1; i--)
    for (int j = 1; j <= i; j++)
        f[i][j] = max(f[i+1][j], f[i+1][j+1]) + a[i][j];
cout << f[1][1] << endl;
```
✅ **优点**：无需处理复杂的边界初始化，也不需最后遍历，代码更简洁。

---

## 二、最长上升子序列（LIS）—— 以我结尾的长度

### 2.1 故事引入：身高排队

体育课排队，要求**后一个同学的身高必须严格大于前一个**，你可以**不选**某些同学（保持相对顺序）。  
问最多能选多少个同学？

**这就是最长上升子序列问题**。

---

### 2.2 状态表示 —— 以 a[i] 结尾的最长上升子序列长度

定义 `f[i]`：**所有以第 i 个数结尾的上升子序列的长度最大值**。

- **集合**：所有以 a[i] 结尾的上升子序列。
    
- **属性**：长度的最大值（Max）。
    

**答案**：`max(f[1], f[2], ..., f[n])`。

---

### 2.3 状态转移 —— 从前面某个小于 a[i] 的数转移过来

对于每个 i，我们考虑子序列的**倒数第二个数**是哪个：

- 如果没有倒数第二个数（序列只有 a[i] 自己），长度 = 1。
    
- 如果倒数第二个数是 a[j]（j < i 且 a[j] < a[i]），那么以 a[i] 结尾的最长长度 = `f[j] + 1`。
    

因此：

```text

f[i] = max(1, max_{j < i, a[j] < a[i]} (f[j] + 1))
```
**时间复杂度**：O(n²)，n ≤ 1000 时完美，n ≤ 10⁵ 需优化（后面讲）。

---

### 2.4 代码实现

```cpp

#include <iostream>
#include <algorithm>
using namespace std;
const int N = 1010;
int a[N], f[N];
int main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    int res = 0;
    for (int i = 1; i <= n; i++) {
        f[i] = 1;                      // 只有 a[i] 自己
        for (int j = 1; j < i; j++)
            if (a[j] < a[i])
                f[i] = max(f[i], f[j] + 1);
        res = max(res, f[i]);
    }
    cout << res << endl;
    return 0;
}
```
🔴 **易错点**：

- **严格递增**：条件必须是 `a[j] < a[i]`，不是 `<=`。
    
- **初始化**：每个 `f[i]` 至少为 1（自身）。
    
- **答案**：不是 `f[n]`，而是所有 `f[i]` 的最大值。
    

🟢 **记忆口诀**：“**最长上升子序列，以 i 结尾来定义；前面比他小的，转移加一取大值。**”

---

### 2.5 优化：O(n log n) 的贪心+二分（简要介绍）

当 n 很大时（如 10⁵），O(n²) 会超时。  
**优化思想**：维护一个数组 `q`，`q[len]` 表示**长度为 len 的上升子序列的末尾元素的最小值**。  
遍历每个 a[i]，用二分找到第一个 ≥ a[i] 的位置，替换掉，否则追加。  
最终 `q` 的长度即为 LIS 长度。

**这个优化是竞赛常考内容，但基础课通常只讲 O(n²)，作为拓展了解。**

---

## 三、最长公共子序列（LCS）—— 双串匹配

### 3.1 故事引入：DNA序列比对

你有两条 DNA 序列（由 ATCG 组成），想找出它们最长的公共子序列（可以不连续）。  
比如 `"acbd"` 和 `"abedc"` 的最长公共子序列是 `"abd"`，长度为 3。

**这就是最长公共子序列问题**。

---

### 3.2 状态表示 —— f[i][j] 表示 A 前 i 个字符和 B 前 j 个字符的 LCS 长度

定义 `f[i][j]`：**所有在 A[1..i] 和 B[1..j] 中都出现的公共子序列的长度最大值**。

- **集合**：A[1..i] 与 B[1..j] 的公共子序列的集合。
    
- **属性**：长度的最大值（Max）。
    

**答案**：`f[n][m]`。

---

### 3.3 状态转移 —— 四种情况讨论

根据 A[i] 和 B[j] **是否被选入当前公共子序列**，可分为四类：

1. **00**：A[i] 和 B[j] 都不在子序列中 → 等价于 `f[i-1][j-1]`。
    
2. **01**：A[i] 不在，B[j] 在 → 子序列末尾是 B[j]，但 A[i] 不参与，所以这个子序列一定在 `A[1..i-1]` 和 `B[1..j]` 中出现过 → `f[i-1][j]`（**注意**：`f[i-1][j]` 可能包含 B[j] 在子序列中，也可能不包含，但我们的目标是最大值，只要覆盖了这种情况即可，不要求精确对应）。
    
3. **10**：A[i] 在，B[j] 不在 → 类似 → `f[i][j-1]`。
    
4. **11**：A[i] 和 B[j] 都在 → 此时必须满足 A[i] == B[j]，且这个字符作为子序列的最后一个字符 → 那么前面的部分就是 `f[i-1][j-1] + 1`。
    

**由于求最大值，且 `f[i-1][j-1]` 已经被 `f[i-1][j]` 和 `f[i][j-1]` 包含**（因为 `f[i-1][j]` ≥ `f[i-1][j-1]`，同理另一侧），所以实际代码中**不需要单独写 00**，只需考虑后三种情况。

---

### 3.4 转移方程（简化版）

```text

f[i][j] = max(f[i-1][j], f[i][j-1]);
if (a[i] == b[j]) f[i][j] = max(f[i][j], f[i-1][j-1] + 1);
```
**为什么 01 和 10 分别用 f[i-1][j] 和 f[i][j-1] 能覆盖？**

- `f[i-1][j]` 是 A[1..i-1] 与 B[1..j] 的 LCS 长度，它可能包含 B[j] 也可能不包含，但无论如何，这个长度一定 ≥ 不含 A[i] 且含 B[j] 的子序列长度（因为它是所有公共子序列的最大值）。我们取最大值，所以用 `f[i-1][j]` 是安全的。
    
- 同理 `f[i][j-1]` 覆盖了含 A[i] 不含 B[j] 的情况。
    

---

### 3.5 代码实现

```cpp

#include <iostream>
using namespace std;
const int N = 1010;
int n, m;
char a[N], b[N];
int f[N][N];
int main() {
    cin >> n >> m >> a + 1 >> b + 1;   // 下标从 1 开始
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) {
            f[i][j] = max(f[i-1][j], f[i][j-1]);
            if (a[i] == b[j])
                f[i][j] = max(f[i][j], f[i-1][j-1] + 1);
        }
    cout << f[n][m] << endl;
    return 0;
}
```
🔴 **易错点**：

- **下标从 1 开始**：输入用 `a+1`, `b+1`，确保 `a[1]` 是第一个字符。
    
- **字符数组类型**：必须用 `char` 数组，不能用 `int`（一个 int 存 4 个字符，会混乱）。
    
- **转移顺序**：先取 `max(f[i-1][j], f[i][j-1])`，再判断相等条件，顺序不影响结果。
    

🟢 **记忆口诀**：“**最长公共子序列，二维 DP 双串跑；不等取左上大，相等再加一。**”

---

## 四、编辑距离 —— 字符串的“代价”（作业扩展）

**题目**：给定两个字符串 A 和 B，允许三种操作（插入一个字符、删除一个字符、替换一个字符），求将 A 变成 B 的最少操作次数。

**这是 LCS 的兄弟问题，也是双序列 DP 的经典**。

### 4.1 状态表示

`f[i][j]`：**将 A[1..i] 变成 B[1..j] 所需的最少操作次数**。

### 4.2 状态转移

考虑 A[i] 和 B[j] 的关系：

1. **删除**：删掉 A[i]，然后 A[1..i-1] 变成 B[1..j] → `f[i-1][j] + 1`。
    
2. **插入**：在 A[i] 后面插入 B[j]，然后 A[1..i] 变成 B[1..j-1] → `f[i][j-1] + 1`。
    
3. **替换**：
    
    - 如果 A[i] == B[j]，无需操作 → `f[i-1][j-1]`。
        
    - 否则，替换 A[i] 为 B[j] → `f[i-1][j-1] + 1`。
        

**初始化**：

- `f[0][j] = j`：A 为空，需要插入 j 次。
    
- `f[i][0] = i`：B 为空，需要删除 i 次。
    

**代码略**（作为作业，留给大家自己实现）。

---

# 第二部分 · 区间DP —— 合并的艺术

## 一、石子合并 —— 经典的区间DP

### 1.1 故事引入：合并石子

有 N 堆石子排成一排，每次只能合并**相邻**的两堆，合并代价为两堆石子重量之和。  
问将所有石子合并成一堆的最小总代价。

**关键**：合并顺序不同，总代价不同。我们需要找到最优合并顺序。

---

### 1.2 状态表示 —— f[i][j] 表示合并区间 [i,j] 的最小代价

定义 `f[i][j]`：**将第 i 堆到第 j 堆石子合并成一堆的所有合并方式中，总代价的最小值**。

- **集合**：所有将区间 [i,j] 合并成一堆的方式。
    
- **属性**：总代价的最小值（Min）。
    

**边界**：当 `i == j` 时，不需要合并，`f[i][i] = 0`。

**答案**：`f[1][n]`。

---

### 1.3 状态转移 —— 枚举最后一次合并的分界线

最后一次合并一定是将**左半部分** `[i,k]` 和**右半部分** `[k+1,j]` 合并。  
合并这两堆的代价 = **左半部分已经合并成一堆的总代价 + 右半部分已经合并成一堆的总代价 + 本次合并的代价（即 [i,j] 的总石子数）**。

```text

f[i][j] = min_{k = i}^{j-1} ( f[i][k] + f[k+1][j] + s[j] - s[i-1] )
```
其中 `s` 是前缀和数组，`s[j] - s[i-1]` 表示区间 [i,j] 的石子总数。

---

### 1.4 计算顺序 —— 按区间长度从小到大

要计算 `f[i][j]`，需要先知道 `f[i][k]` 和 `f[k+1][j]`，这些子区间的长度都**小于** `len = j-i+1`。  
因此我们必须**按区间长度递增的顺序**计算。

**枚举方式**：

```cpp

for (int len = 2; len <= n; len++)                // 区间长度
    for (int i = 1; i + len - 1 <= n; i++) {      // 左端点
        int j = i + len - 1;                     // 右端点
        f[i][j] = INF;
        for (int k = i; k < j; k++)              // 分界点
            f[i][j] = min(f[i][j], f[i][k] + f[k+1][j] + s[j] - s[i-1]);
    }
```
**初始化**：`f[i][i] = 0`。

---

### 1.5 代码实现

```cpp

#include <iostream>
#include <cstring>
using namespace std;
const int N = 310, INF = 1e9;
int n;
int s[N];
int f[N][N];
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> s[i], s[i] += s[i-1];   // 前缀和
    for (int len = 2; len <= n; len++) {
        for (int i = 1; i + len - 1 <= n; i++) {
            int j = i + len - 1;
            f[i][j] = INF;
            for (int k = i; k < j; k++) {
                f[i][j] = min(f[i][j], f[i][k] + f[k+1][j] + s[j] - s[i-1]);
            }
        }
    }
    cout << f[1][n] << endl;
    return 0;
}
```
🔴 **易错点**：

- **区间长度从 2 开始**：长度为 1 已初始化为 0，不需要处理。
    
- **前缀和数组**：`s[j] - s[i-1]` 表示 [i,j] 的和，`s[0]` 必须为 0。
    
- **INF 设置**：要足够大（如 `0x3f3f3f3f` 或 `1e9`），因为 n=300 时最大代价约 `300*300*1000 ≈ 9e7`，1e9 足够。
    

🟢 **记忆口诀**：“**石子合并区间 DP，枚举长度再左端；分界 k 从 i 到 j-1，左右代价加区间和。**”

---

# 📊 本章知识小结 —— 考试前夜必看

| 问题类型            | 状态表示                                | 转移方程                                                               | 边界/初始化                     | 复杂度   | 易错点           |
| --------------- | ----------------------------------- | ------------------------------------------------------------------ | -------------------------- | ----- | ------------- |
| **数字三角形**（自上而下） | `f[i][j]`: 从顶到 (i,j) 最大和            | `max(f[i-1][j-1], f[i-1][j]) + a[i][j]`                            | `f[1][1]=a[1][1]`, 其余 -INF | O(n²) | 初始化负无穷，列多一    |
| **数字三角形**（自底向上） | `f[i][j]`: 从 (i,j) 到底最大和            | `max(f[i+1][j], f[i+1][j+1]) + a[i][j]`                            | `f[n][j]=a[n][j]`          | O(n²) | 无需负无穷，代码更简洁   |
| **最长上升子序列**     | `f[i]`: 以 a[i] 结尾的 LIS 长度           | `f[i]=max(1, max_{j<i,a[j]<a[i]}(f[j]+1))`                         | `f[i]=1`                   | O(n²) | 严格递增，答案取 max  |
| **最长公共子序列**     | `f[i][j]`: A[1..i],B[1..j] 的 LCS 长度 | `max(f[i-1][j], f[i][j-1])`; 若 a[i]==b[j] 再与 `f[i-1][j-1]+1` 取 max | `f[0][*]=f[*][0]=0`        | O(nm) | 下标从 1，char 数组 |
| **石子合并**        | `f[i][j]`: 合并 [i,j] 的最小代价           | `min_{k=i}^{j-1}(f[i][k]+f[k+1][j] + sum[i,j])`                    | `f[i][i]=0`                | O(n³) | 枚举长度，前缀和      |

---

# 🎓 写在最后：DP 的“三板斧”

回顾本章的五个问题，你会发现它们都遵循同样的思考框架：

1. **状态表示**：明确状态的含义（一维/二维/区间），以及它代表的集合和属性（Max/Min/数量）。
    
2. **状态转移**：思考当前状态可以从哪些**前驱状态**转移过来，通常对应**最后一步决策**。
    
3. **初始化与边界**：处理好最小子问题（如长度为 1 的区间、空串等）。
    
4. **计算顺序**：确保计算当前状态时，它所依赖的子状态已经计算完毕（自顶向下记忆化搜索也可以，但递推更常用）。
    

**线性DP**：状态沿序列方向延伸，转移通常来自“前一个位置”或“前面所有小于条件的位置”。  
**区间DP**：状态是连续区间，转移通过枚举分界点，将大区间拆成两个子区间。

**给你的硬核建议**：

1. **数字三角形**：分别用自上而下和自底向上两种方法写一遍，对比边界处理的差异。
    
2. **最长上升子序列**：自己造一组数据，手动模拟 DP 过程，理解为什么 `f[i]` 不是最终答案。
    
3. **最长公共子序列**：画一个表格，手动填一遍，理解 `f[i-1][j]` 和 `f[i][j-1]` 是如何覆盖“不含”情况的。
    
4. **石子合并**：用 n=4 的小数据手动模拟循环过程，理解“枚举长度”的必要性。
# 基础算法课 Week2 习题课 —— 双指针、离散化、链表与单调结构

> 🔴 **阅读提示**：本章是**第二周习题课**，针对**基础算法**与**数据结构**部分进行题目精讲。  
> 涵盖 **双指针求两数之和、离散化 + 前缀和、单链表/双链表模拟、单调栈、单调队列** 以及 **字符串下标选择**。  
> 每一题都会从**暴力思路**开始，引出**优化算法**，**逐行拆解代码**，并总结**易错点 + 记忆口诀**。  
> 🎯 **目标**：通过习题课，让你真正掌握**双指针的单调性**、**离散化的三步走**、**静态链表的指针魔法**以及**单调结构的均摊分析**。

---

# 📌 开篇：习题课的意义 —— 从“知道”到“会写”

上周我们学习了快速选择、逆序对、前缀和差分等基础算法，很多同学反馈：“听课能听懂，但自己写就是一堆 bug。”  
**本周习题课，我们专治“听懂写不出”**。  
每一道题都会**手把手带你走一遍从暴力到优化的完整思考链**，并把所有坑都标出来。

---

# 第一部分 · 双指针 —— 数组元素目标和

## 一、故事引入：两个递增序列，找一对和为 x 的数

你面前有两摞分别**从小到大**排好的卡片，每张卡片上有一个数字。  
老师要求你找出**唯一一对**卡片（分别从两摞中各取一张），使得它们的数字之和等于 x。  
你不能跳着看，只能一张一张翻。  
怎么找最快？

**这就是著名的“两数之和 II”问题**，只不过这里两个数组是**独立的**，不是同一个数组。

---

## 二、题目描述

> 给定两个**升序排列**的整数数组 A 和 B，长度分别为 n 和 m（≤10⁵），以及一个目标值 x。  
> 保证存在**唯一**的一组解 (i, j) 使得 `A[i] + B[j] = x`。  
> 输出 i 和 j（下标从 0 开始）。

---

## 三、暴力枚举 —— 你能想到的第一种方法

```cpp

for (int i = 0; i < n; i++)
    for (int j = 0; j < m; j++)
        if (A[i] + B[j] == x)
            cout << i << ' ' << j << endl;

```
**时间复杂度**：O(n×m) → 当 n,m = 10⁵ 时，1e10 次运算，必超时。

---

## 四、优化思路 —— 利用单调性，让 j 往回走

**关键观察**：

- 数组 A 递增：`A[i]` 随着 i 增大而增大。
    
- 数组 B 递增：`B[j]` 随着 j 增大而增大。
    

对于固定的 i，我们要找一个 j 使得 `A[i] + B[j] = x`。  
当 i 增加时，`A[i]` 变大，为了维持和不变，`B[j]` 必须**变小**。  
因此，**j 只能向左移动**，不可能向右移动。

于是我们可以这样设计：

- 初始 `i = 0`，`j = m-1`（B 的最大值）。
    
- 如果 `A[i] + B[j] > x`，说明和太大，需要减小 B[j] → `j--`。
    
- 如果 `A[i] + B[j] < x`，说明和太小，需要增大 A[i] → `i++`。
    
- 如果相等，输出答案。
    

**复杂度**：i 从 0 → n-1 最多走 n 步，j 从 m-1 → 0 最多走 m 步，总共 **O(n + m)**。

---

## 五、代码模板（带防呆注释）

```cpp

#include <iostream>
using namespace std;
const int N = 100010;
int a[N], b[N];
int main() {
    int n, m, x;
    scanf("%d%d%d", &n, &m, &x);
    for (int i = 0; i < n; i++) scanf("%d", &a[i]);
    for (int i = 0; i < m; i++) scanf("%d", &b[i]);
    int i = 0, j = m - 1;
    while (i < n && j >= 0) {
        if (a[i] + b[j] > x) j--;        // 和太大，j左移
        else if (a[i] + b[j] < x) i++;   // 和太小，i右移
        else {
            printf("%d %d\n", i, j);
            break;
        }
    }
    return 0;
}
```
🔴 **易错点**：

- **j 的初始值**：一定是 `m-1`，不能是 `0`，否则无法利用单调性。
    
- **while 条件**：必须同时保证 `i < n` 和 `j >= 0`，防止越界。
    
- **唯一解保证**：题目说“有且只有一组解”，所以我们找到后可以立即 `break`。如果没有这个保证，可能需要继续查找（但此时复杂度可能退化）。
    

🟢 **记忆口诀**：“**双指针两头走，大了左移小了右，相等输出便回头。**”

---

## 六、扩展思考

1. **如果数组无序怎么办？**
    
    - 方法一：排序 + 双指针（但下标会乱，需要额外记录原下标）。
        
    - 方法二：哈希表（unordered_map）存一个数组的值到下标的映射，遍历另一个数组查表，O(n+m)。
        
2. **如果有多组解，需要输出所有解？**
    
    - 此时双指针依然可行，找到一组后继续移动指针（跳过当前相等的值），直到 i 或 j 越界。
        
    - 时间复杂度 O(n+m) 不变，但输出可能很多，不影响算法。
        

---

# 第二部分 · 离散化 —— 区间和（大坐标 + 前缀和）

## 一、故事引入：无限长的数轴，只关心某些点

有一条无限长的数轴，一开始所有点都是 0。  
现在进行 n 次操作，每次在坐标 x 上加 c（c 可正可负）。  
然后进行 m 次询问，每次问区间 [l, r] 的和。  
坐标 x, l, r 的范围是 **-10⁹ 到 10⁹**，但操作次数 n+m ≤ 2×10⁵。

**问题**：无法直接开 2×10⁹ 大小的数组做前缀和，怎么办？

**答案**：**离散化** —— 把用到的坐标（操作中的 x，询问中的 l, r）**压缩**成连续的整数 1,2,3,…，然后用普通数组做前缀和。

---

## 二、离散化的三步走（必背）

1. **收集**：把所有涉及到的原始坐标（x, l, r）全部放进一个 vector。
    
2. **排序 + 去重**：`sort` 后 `unique` + `erase`。
    
3. **映射**：用二分查找（`lower_bound`）找到原始坐标在去重后数组中的位置（下标从 1 开始，方便前缀和）。
    

**为什么下标从 1 开始？**  
前缀和公式 `s[r] - s[l-1]` 需要 `s[0] = 0`，所以离散化后的下标也从 1 开始，0 号位置留空。

---

## 三、完整解题流程（配图理解）

### 1. 数据结构准备

```cpp

typedef pair<int, int> PII;
vector<int> alls;        // 存储所有需要离散化的坐标
vector<PII> add, query;  // add: (x, c) ; query: (l, r)
int a[N], s[N];          // a[] 离散化后的值数组，s[] 前缀和
```
### 2. 读入并收集坐标

```cpp

int n, m;
cin >> n >> m;
for (int i = 0; i < n; i++) {
    int x, c;
    cin >> x >> c;
    add.push_back({x, c});
    alls.push_back(x);
}
for (int i = 0; i < m; i++) {
    int l, r;
    cin >> l >> r;
    query.push_back({l, r});
    alls.push_back(l);
    alls.push_back(r);
}
```
### 3. 排序 + 去重

cpp

sort(alls.begin(), alls.end());
alls.erase(unique(alls.begin(), alls.end()), alls.end());

### 4. 映射函数（二分查找，返回下标从 1 开始）

```cpp

int find(int x) {
    int l = 0, r = alls.size() - 1;
    while (l < r) {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return l + 1;   // 下标从 1 开始
}
```
### 5. 处理加法

```cpp

for (auto &item : add) {
    int idx = find(item.first);
    a[idx] += item.second;
}
```
### 6. 预处理前缀和

```cpp

for (int i = 1; i <= alls.size(); i++) s[i] = s[i-1] + a[i];
```
### 7. 处理询问

```cpp

for (auto &item : query) {
    int l = find(item.first), r = find(item.second);
    cout << s[r] - s[l-1] << endl;
}
```
---

## 四、易错点与细节（🔴必看）

1. **坐标收集必须完整**：**询问的 l 和 r 也要加入 alls**！否则二分查找时会找不到（返回错误位置）。
    
2. **去重操作**：`unique` 只去除**相邻**重复元素，所以必须先 `sort`。
    
3. **二分查找边界**：手写二分时注意最终返回 `l+1`，确保下标从 1 开始。用 `lower_bound` 则返回迭代器，需要 `lower_bound(alls.begin(), alls.end(), x) - alls.begin() + 1`。
    
4. **数组大小**：`a` 和 `s` 的大小应设置为 `alls.size() + 5`，因为 `find` 返回的最大下标是 `alls.size()`。
    
5. **c 可能为负**：`a[idx] += c` 直接加，前缀和会自动处理负数。
    

🟢 **记忆口诀**：“**离散化三步走，收集排序去重后，二分映射下+1，前缀和来解区间愁。**”

---

## 五、离散化的本质

**离散化不是排序，而是一种压缩映射**。  
它将**稀疏的大范围整数**映射到**紧凑的小范围整数**，使得原本无法用数组存储的数据变得可用数组维护。  
常与**前缀和、树状数组、线段树**配合使用。

---

# 第三部分 · 单链表 —— 静态链表模拟（数组版）

## 一、故事引入：内存受限，不能用 new

在算法竞赛中，动态分配内存（`new`）非常慢，且容易产生内存碎片。  
因此我们常用**数组模拟链表**，也叫**静态链表**。  
每个节点不是用指针链接，而是用**数组下标**作为“地址”。

---

## 二、数据结构定义

```cpp

const int N = 100010;
int head, e[N], ne[N], idx;
// head: 头结点的下标（不是值）
// e[i]: 节点 i 的值
// ne[i]: 节点 i 的 next 指针（指向下一个节点的下标）
// idx: 当前可用的节点下标（从 0 开始）
```
**初始化**：

```cpp

void init() {
    head = -1;   // -1 表示空指针
    idx = 0;
}
```
---

## 三、核心操作 —— 头插法

**步骤**（画图理解）：

1. 新节点的值存入 `e[idx]`。
    
2. 新节点的 `next` 指向原来的头结点：`ne[idx] = head`。
    
3. 头指针指向新节点：`head = idx`。
    
4. `idx++` 准备下一个新节点。
    

```cpp

void add_to_head(int x) {
    e[idx] = x;
    ne[idx] = head;
    head = idx++;
}
```
🔴 **易错点**：**顺序不能反**！如果先 `head = idx`，就会丢失原链表，后面 `ne[idx] = head` 相当于自己指向自己。

---

## 四、在第 k 个插入的数后面插入

**注意**：“第 k 个插入的数” 是指**按插入顺序的第 k 个**，不是链表中的第 k 个。  
由于我们每次插入都使用 `idx` 且 `idx` 单调递增，**第 1 个插入的节点下标是 0，第 2 个是 1，…，第 k 个是 k-1**。

```cpp

void add(int k, int x) {
    e[idx] = x;
    ne[idx] = ne[k];   // 新节点指向 k 的后继
    ne[k] = idx;       // k 指向新节点
    idx++;
}
```
🔴 **易错点**：

- 传入的 `k` 如果是从 1 开始计数的，要记得**减 1**。
    
- 必须先 `ne[idx] = ne[k]`，再 `ne[k] = idx`，否则会丢失原后继。
    

---

## 五、删除第 k 个插入的数后面的数

```cpp

void remove(int k) {
    ne[k] = ne[ne[k]];   // 跳过下一个节点
}
```
**特殊情况**：删除头结点（k = 0）：

```cpp

if (k == 0) head = ne[head];
else remove(k-1);
```
🔴 **注意**：删除后**不回收空间**，`idx` 不会减小，但没关系，竞赛不要求内存回收。

---

## 六、遍历链表

```cpp

for (int i = head; i != -1; i = ne[i])
    cout << e[i] << ' ';
```
---

## 七、易错点总结（🔴必背）

1. **`head` 初始化必须为 -1**，表示空链表。
    
2. **插入顺序**：先改新节点的 `next`，再改前驱的 `next`。
    
3. **下标对应**：第 k 个插入的节点下标 = `k-1`。
    
4. **删除头结点**：特判 `k == 0`，直接 `head = ne[head]`。
    
5. **输入处理**：操作符用 `char` 数组读入，避免空格干扰。
    

🟢 **记忆口诀**：“**单链表插头两步走，新人先指旧队首，队长再换新人当；任意位置插入同理，新人先指老人后。**”

---

# 第四部分 · 双链表 —— 循环双链表（哨兵节点）

## 一、为什么需要哨兵节点？

单链表用 `head = -1` 表示空表，插入删除都要特判头结点。  
双链表常用**两个固定节点作为哨兵**（左哨兵和右哨兵），**永远存在**，链表永不为空，操作时无需特判边界。

---

## 二、数据结构定义

```cpp

const int N = 100010;
int e[N], l[N], r[N], idx;
// l[i]: 节点 i 的左指针（前驱）
// r[i]: 节点 i 的右指针（后继）
// idx: 当前可用节点下标（从 2 开始，0 和 1 固定为哨兵）
```
**初始化**：

```cpp

void init() {
    r[0] = 1;    // 左哨兵(0)的右边是右哨兵(1)
    l[1] = 0;    // 右哨兵(1)的左边是左哨兵(0)
    idx = 2;     // 真实节点从 2 开始分配
}
```
---

## 三、核心操作 —— 在节点 k 的右侧插入新节点

**步骤**（四步，顺序必须固定）：

1. 赋值：`e[idx] = x`。
    
2. 新节点右指针指向 `r[k]`：`r[idx] = r[k]`。
    
3. 新节点左指针指向 `k`：`l[idx] = k`。
    
4. 修改原 `k` 的右节点的左指针指向新节点：`l[r[k]] = idx`。
    
5. 修改 `k` 的右指针指向新节点：`r[k] = idx`。
    
6. `idx++`。
    

```cpp

void insert(int k, int x) {
    e[idx] = x;
    r[idx] = r[k];
    l[idx] = k;
    l[r[k]] = idx;
    r[k] = idx++;
}
```
🔴 **易错点**：**第 4、5 步的顺序**不能与第 2、3 步颠倒，且必须**先改 `l[r[k]]`**，因为 `r[k]` 还没有改变，如果先改 `r[k]`，就找不到原来的右节点了。

**左侧插入**：`insert(l[k], x)`（在 k 的左节点的右侧插入，相当于 k 的左侧）。

---

## 四、删除节点 k

```cpp

void remove(int k) {
    r[l[k]] = r[k];   // 左节点的右指针指向右节点
    l[r[k]] = l[k];   // 右节点的左指针指向左节点
}
```
**无需特判**，因为哨兵节点 0 和 1 永远不会被删除。

---

## 五、遍历

```cpp

for (int i = r[0]; i != 1; i = r[i])  // 从第一个真实节点开始，到右哨兵结束
    cout << e[i] << ' ';
```
---

## 六、与单链表的对比

|特征|单链表（静态）|双链表（哨兵）|
|---|---|---|
|空表表示|`head = -1`|始终有哨兵，`r[0] == 1`|
|头结点|动态变化|固定为 0 号哨兵|
|尾结点|需遍历|固定为 1 号哨兵|
|删除头结点|特判|无需特判（删除的是真实节点）|
|插入位置|头插 / 指定位置后|任意节点左右均可|

🟢 **记忆口诀**：“**双链表四步插，先连新客左右手，再改邻居前后门；删除两步桥接法，左邻右舍直接连。**”

---

# 第五部分 · 单调栈 —— 左边第一个比它小的数

## 一、故事引入：股票价格中的支撑位

给你一串股票每日收盘价，对于每一天，你想知道**这一天之前最近的一天，价格比今天低**是哪一天（不存在则 -1）。  
暴力：每天往前看 O(n²)。  
**单调栈**：O(n)。

---

## 二、问题定义

给定长度为 n 的数组 `a`，对于每个位置 i，求 `j < i` 且 `a[j] < a[i]` 的**最大 j**（最右边的一个），若不存在则输出 -1。

---

## 三、暴力与优化思路

**暴力**：对每个 i，从 i-1 向左扫描，找到第一个比 `a[i]` 小的值。  
**优化关键**：如果 `a[x] >= a[y]` 且 `x < y`，那么 `a[x]` 对于后面所有元素来说，**永远不可能成为答案**（因为 `a[y]` 更小且更近）。  
因此，我们可以维护一个**栈**，栈内元素是**等待被使用的候选答案**，并且保持**栈底到栈顶递增**。

**算法步骤**：

1. 初始化空栈。
    
2. 遍历每个 i：
    
    - 当栈非空且栈顶元素的值 ≥ `a[i]` 时，弹出栈顶（因为它永远不会被用了）。
        
    - 此时若栈非空，栈顶就是左边第一个比 `a[i]` 小的数；否则为 -1。
        
    - 将 `a[i]` 入栈。
        

**为什么栈是递增的？**  
因为每次入栈前都会把比当前元素大的栈顶弹出，所以栈中元素始终保持**从底到顶递增**。

---

## 四、代码模板

```cpp

#include <iostream>
using namespace std;
const int N = 100010;
int stk[N], tt = 0;   // tt 为栈顶指针，0 表示空栈
int main() {
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i++) {
        int x;
        scanf("%d", &x);
        while (tt > 0 && stk[tt] >= x) tt--;   // 弹出 >= x 的元素
        if (tt > 0) printf("%d ", stk[tt]);
        else printf("-1 ");
        stk[++tt] = x;
    }
    return 0;
}
```
**如果需要输出下标**：栈存下标，比较时用 `a[stk[tt]] >= a[i]`。

---

## 五、时间复杂度分析 —— 均摊 O(n)

每个元素**最多入栈一次**，**最多出栈一次**。  
总的栈操作次数 ≤ 2n，所以是 **O(n)**。  
这就是**均摊分析**的经典例子。

---

## 六、四种变体（一法通，万法通）

|问题|栈的单调性|比较条件|遍历方向|
|---|---|---|---|
|左边第一个比它小|递增|`>=` 弹出|从左到右|
|左边第一个比它大|递减|`<=` 弹出|从左到右|
|右边第一个比它小|递增|`>=` 弹出|**从右到左**|
|右边第一个比它大|递减|`<=` 弹出|**从右到左**|

🟢 **记忆口诀**：“**单调栈，分两边，大小左右记心间；左小右小都递增，左大右大递减变。**”

---

# 第六部分 · 单调队列 —— 滑动窗口最值

## 一、故事引入：滑动窗口里的最大值

有一个长度为 n 的数组，有一个长度为 k 的滑动窗口，从数组左边滑到右边。  
你需要输出**每个窗口的最大值**。  
暴力：每个窗口遍历 O(k) → 总 O(nk)。  
**单调队列**：O(n)。

---

## 二、问题定义

给定数组 `a[1..n]` 和窗口大小 k，求所有长度为 k 的连续子数组的最大值（或最小值）。

---

## 三、优化思路 —— 及时删除无用元素

**关键观察**：  
假设窗口向右滑动，我们用一个队列维护**窗口中所有可能成为最大值的元素的下标**。  
队首永远是当前窗口的最大值。

**如何维护**？

1. **队头出队**：如果队首下标已经滑出窗口（`队首下标 < i - k + 1`），则弹出队头。
    
2. **队尾淘汰**：新元素 `a[i]` 入队前，将队列中**所有 ≤ a[i] 的元素**从队尾弹出（因为它们在 i 还在窗口中时，永远不可能是最大值了）。
    
3. 将 `i` 入队。
    
4. 当窗口长度达到 k 时，队首就是当前窗口的最大值。
    

**为什么是“≤”**？  
求最大值时，若队尾元素 ≤ 新元素，则队尾元素**不可能再成为最大值**，直接丢弃。  
求最小值时对称，条件是 `>=`。

---

## 四、代码模板（求最大值）

```cpp

#include <iostream>
using namespace std;
const int N = 1000010;
int a[N], q[N];   // q 存下标
int hh = 0, tt = -1;
int main() {
    int n, k;
    scanf("%d%d", &n, &k);
    for (int i = 0; i < n; i++) scanf("%d", &a[i]);
    for (int i = 0; i < n; i++) {
        // 1. 队头出窗
        if (hh <= tt && q[hh] < i - k + 1) hh++;
        // 2. 队尾淘汰
        while (hh <= tt && a[q[tt]] <= a[i]) tt--;
        // 3. 新元素入队
        q[++tt] = i;
        // 4. 输出（窗口长度达到 k 时）
        if (i >= k - 1) printf("%d ", a[q[hh]]);
    }
    return 0;
}
```
**求最小值**：只需将 `<=` 改为 `>=`。

---

## 五、时间复杂度分析 —— 均摊 O(n)

每个下标**最多入队一次，最多出队一次**。  
总操作次数 O(n)，**均摊每个元素 O(1)**。

---

## 六、易错点（🔴必看）

1. **队头出窗条件**：`q[hh] < i - k + 1`（不是 ≤，因为窗口左边界是 i-k+1，下标等于左边界时还在窗口内）。
    
2. **队尾淘汰顺序**：**先淘汰，后入队**。如果先入队再淘汰，刚入队的元素可能把自己淘汰掉（因为自己等于自己），但这样逻辑上没问题，只是效率稍低。推荐**先淘汰再入队**。
    
3. **存储下标而非值**：必须存下标，才能判断是否出窗口。
    
4. **窗口不满时不输出**：前 k-1 个元素不输出。
    

🟢 **记忆口诀**：“**滑动窗口单调队，队头出窗先判断，队尾无用全清退，队首就是最值位。**”

---

# 第七部分 · 字符串下标 —— 从 0 还是从 1？

## 一、为什么会有这个问题？

在 KMP、Trie、字符串哈希等算法中，我们经常需要处理字符串的每个字符。  
C++ 中，字符数组（`char[]`）的下标默认从 0 开始，但很多教材为了方便边界处理，会**人为地将下标调整为从 1 开始**（例如 `cin >> p + 1`）。

## 二、两种方案的对比

|方案|实现方式|优点|缺点|
|---|---|---|---|
|**下标从 0**|正常读入，`p[0]` 是第一个字符|符合 C++ 习惯，无需额外操作|边界条件需要小心（如 next 数组长度）|
|**下标从 1**|`cin >> p + 1`，或 `p = " " + s`|代码直观，`next[i]` 直接对应前 i 个字符|需要多开一个位置，读入稍麻烦|

**强烈建议**：**从 1 开始**。  
因为很多 DP 和字符串匹配的状态转移都依赖 `i-1`，下标从 1 可以避免频繁的 `-1` 操作，减少 bug。

---

## 三、下标从 1 开始的具体做法

```cpp

char p[N], s[N];
cin >> n >> p + 1 >> m >> s + 1;   // p 从下标 1 开始存储
```
这样，`p[1]` 就是第一个字符，`p[0]` 是未使用的（默认为 '\0'）。  
在 KMP 中，`next[1] = 0`，循环从 `i = 2` 开始，非常自然。

---

## 四、如果题目输入是从 0 开始的怎么办？

你仍然可以在读入后**平移下标**：

```cpp

char s[N];
cin >> s;   // 下标从 0
int len = strlen(s);
for (int i = len; i >= 0; i--) s[i+1] = s[i];   // 后移一位
```
但这种方法效率低，**不建议**。最好的方法是直接在读入时指定偏移：

```cpp

scanf("%s", s + 1);   // 前提是 s 长度足够
```
🟢 **结论**：**无论题目给什么格式，一律转为从 1 开始处理**。这是减少边界错误的最佳实践。

---

# 📊 习题课知识小结

|题目|核心算法|关键代码/公式|易错点|难度|
|---|---|---|---|---|
|**数组元素目标和**|双指针（对撞）|`i=0,j=m-1`；比较和移动|j 初始值、越界|★★★☆|
|**区间和（离散化）**|离散化 + 前缀和|三步走 + `find` + 前缀和公式|收集所有坐标、下标+1|★★★★|
|**单链表**|静态链表（数组）|`add_to_head`, `add`, `remove`|插入顺序、第 k 个的下标|★★★☆|
|**双链表**|循环双链表（哨兵）|`insert`, `remove` 四步/两步|指针顺序、哨兵固定|★★★★|
|**单调栈（左小）**|单调递增栈|`while(tt && stk[tt]>=x) tt--`|比较条件（≥ 弹出）|★★★☆|
|**单调队列（滑窗最大）**|单调递减队列|队头出窗、队尾淘汰（≤）|存下标、出窗条件|★★★★|
|**字符串下标**|下标偏移|`cin >> p + 1`|数组大小 +1|★★☆|

---

# 🎓 写在最后：习题课的本质是“刻意练习”

本周习题课，我们**没有学新算法**，而是把以前学过的算法**用在具体题目上**。  
你会发现，**双指针**、**离散化**、**链表**、**单调栈/队列**都不是独立的算法，而是一种**思维工具**。  
它们共同的特点是：**利用单调性，把看似 O(n²) 的暴力优化成 O(n)**，或者**把无法存储的大数据压缩成可存储的小数据**。

**给你的硬核建议**：

1. **双指针**：自己写一遍「数组元素目标和」，故意把 `j` 初始值改成 `0`，看看会发生什么。
    
2. **离散化**：手写 `unique` 函数（双指针去重），理解它的原理。
    
3. **链表**：画图模拟单链表头插法和删除过程，直到能闭着眼写出代码。
    
4. **单调栈/队列**：用笔模拟一个长度为 6 的数组，走一遍单调栈的压栈弹栈过程，理解“每个元素只会入栈一次”。
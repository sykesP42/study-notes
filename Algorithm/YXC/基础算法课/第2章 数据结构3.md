# 第二章 数据结构（三）—— 哈希表与 STL，从冲突处理到容器使用
  
> 🎯 **目标**：学完本章，你将彻底掌握**哈希表的两大实现（拉链法 & 开放寻址法）**、**字符串哈希的 O(1) 子串查询**，以及 **C++ STL 常用容器的使用场景与坑点**。从此哈希不再是玄学，STL 不再是黑盒。

---

# 📌 开篇：为什么需要哈希表？

想象你是一个班级的班长，要快速回答两个问题：

1. **学号 2024001 的同学在不在班里？**
    
2. **把新转来的同学加入花名册。**
    

如果花名册是按学号顺序写的，你可以用二分查找，O(log n)——但前提是**学号必须有序**。  
如果花名册是乱序的，你只能从头翻到尾，O(n)——太慢。

**哈希表**就是给你一个“魔法抽屉”：  
你报出一个学号，我瞬间就能算出这个学号应该去**哪个抽屉**找，然后直接拉开抽屉——不管有多少人，速度几乎不变（O(1)）。

**这就是哈希表的核心：将庞大的值域（如 −10⁹ ∼ 10⁹）映射到可控的范围（如 0 ∼ 10⁵），实现快速插入与查询。**

---

# 一、哈希表（散列表）—— 魔法抽屉的实现

## 1.1 故事引入：找座位 vs 蹲坑

**拉链法**：想象电影院每个座位（槽位）后面挂着一条链子，所有喜欢坐这个位置的人都在链子上排队。你要找人，先找座位号，然后沿着链子一个个看。

**开放寻址法**：想象公共厕所，你要蹲坑，先看目标坑位有没有人，有的话就去下一个坑位，直到找到空位。找人也是，先去他应该蹲的坑，如果坑里不是他，就往后一个个坑找。

---

## 1.2 第一步：哈希函数怎么设计？

最常用的哈希函数：**取模法**  
`h(x) = x mod N`  
其中 `N` 是数组长度。

### 🔴 致命陷阱：负数取模

C++ 中 `-10 % 3 = -1`，但我们想要的是 `2`（数学意义）。  
**解决方案**：


```cpp

int hash(int x) {
    return (x % N + N) % N;
}
```
✅ 这样无论 `x` 正负，结果都在 `[0, N-1]`。

### 🟢 记忆口诀：“**负数取模，先模再加，再模一遍**。”

### 📌 N 怎么选？—— 质数！

**为什么是质数？**  
数学上可以证明：当 `N` 是质数且远离 2 的整数幂时，冲突概率最小。  
**经验值**：

- 拉链法：`N` 取 **大于数据量的最小质数**（如 100003, 200003）
    
- 开放寻址法：`N` 取 **数据量的 2~3 倍**，且为质数
    

**找质数代码**（手撸）：

```cpp

int get_prime(int n) {
    for (int i = n; ; i++) {
        bool flag = true;
        for (int j = 2; j * j <= i; j++)
            if (i % j == 0) { flag = false; break; }
        if (flag) return i;
    }
}
```
---

## 1.3 拉链法 —— 数组 + 单链表

### 数据结构定义

```cpp

const int N = 100003;        // 取大于 10^5 的最小质数
int h[N], e[N], ne[N], idx;  // h[] 是槽位，每个槽位存链表的头结点下标
// e[], ne[], idx 与单链表完全一致
```
**初始化**：

```cpp

memset(h, -1, sizeof h);    // 每个槽位初始为空链表（-1 表示 nullptr）
idx = 0;
```
### 插入操作（头插法）

```cpp

void insert(int x) {
    int k = (x % N + N) % N;   // 哈希函数
    e[idx] = x;
    ne[idx] = h[k];
    h[k] = idx++;
}
```
### 查询操作

```cpp

bool find(int x) {
    int k = (x % N + N) % N;
    for (int i = h[k]; i != -1; i = ne[i])
        if (e[i] == x) return true;
    return false;
}
```
### 删除操作（标记法）

算法题中很少需要物理删除，通常只需**逻辑删除**：

```cpp

bool st[N];   // 标记数组，true 表示已删除
// 插入时顺便标记 st[idx] = false;
// 查询时遇到 st[i] 则跳过
```
✅ **99% 的场景**：插入时不做物理删除，只增加标记。  
若必须物理删除，则需要维护前驱指针，较复杂，竞赛极少出现。

---

## 1.4 开放寻址法 —— 蹲坑法

### 数据结构定义

```cpp

const int N = 200003;        // 通常取数据量的 2~3 倍，质数
const int null = 0x3f3f3f3f; // 比 10^9 大的数，表示坑位为空
int h[N];
```
**初始化**：

```cpp

memset(h, 0x3f, sizeof h);   // 每个 int 变成 0x3f3f3f3f
```
🔵 **为什么用 0x3f3f3f3f？**

- 0x3f3f3f3f ≈ 1.06×10⁹，大于题目给出的数值范围（−10⁹ ∼ 10⁹），可以作为“空标记”。
    
- `memset` 按字节赋值，0x3f 一个字节，int 四个字节就是 0x3f3f3f3f。
    

### 核心函数：find(x) —— 返回 x 的位置（如果存在）或应该插入的位置

```cpp

int find(int x) {
    int k = (x % N + N) % N;
    while (h[k] != null && h[k] != x) {
        k++;
        if (k == N) k = 0;    // 循环探测
    }
    return k;
}
```
🔴 **易错点**：

- 必须**循环探测**，不能只 `k++` 不回头。
    
- `while` 条件：坑位**不为空**且**不是 x** 才继续探测。
    

### 插入操作

```cpp

void insert(int x) {
    int k = find(x);
    h[k] = x;
}
```
### 查询操作

```cpp

bool query(int x) {
    int k = find(x);
    return h[k] != null;      // 如果坑位是空，说明不存在
}
```
### 🟢 记忆口诀（开放寻址法）：

“**坑位定址找空位，循环探测不放弃；插入直接占坑位，查询就看是不是空。**”

---

## 1.5 拉链法 vs 开放寻址法 —— 怎么选？

|对比维度|拉链法|开放寻址法|
|---|---|---|
|空间占用|需要额外链表空间（e[], ne[]）|只需一个数组，但需要 2~3 倍长度|
|代码长度|稍长（需维护链表）|极短（仅 find 函数）|
|删除操作|可物理删除（但麻烦），常用标记|物理删除困难（会导致探测链断裂），常用标记|
|缓存友好|链表节点不连续，缓存命中率低|数组连续，缓存命中率高|
|个人偏好|讲师偏好开放寻址法|-|

**结论**：竞赛中**开放寻址法**更简洁、更快，推荐使用。  
但两种方法都要掌握，因为面试官可能随机抽查。

---

# 二、字符串哈希 —— 把字符串变成整数

## 2.1 思想：把字符串看成 P 进制数

例如字符串 `"ABCD"`：

- 设 `A=1, B=2, C=3, D=4`（**不能从 0 开始**，否则 `"A"` 和 `"AA"` 都会变成 0，冲突）
    
- 将其视为 P 进制数：`hash = 1×P³ + 2×P² + 3×P¹ + 4×P⁰`
    
- 再对 Q 取模，映射到 `[0, Q-1]`。
    

**经验参数**（99.99% 不冲突）：

- **P = 131 或 13331**
    
- **Q = 2⁶⁴**（直接用 `unsigned long long` 溢出自动取模）
    

---

## 2.2 前缀哈希预处理

定义 `h[i]` 表示字符串前 `i` 个字符的哈希值。  
**递推公式**：

```cpp

h[0] = 0;
for (int i = 1; i <= n; i++)
    h[i] = h[i-1] * P + (str[i] - 'a' + 1);   // 字母映射为 1~26
```
同时预处理 **P 的幂次**：

```cpp

p[0] = 1;
for (int i = 1; i <= n; i++)
    p[i] = p[i-1] * P;
```
---

## 2.3 核心公式：子串哈希 O(1) 计算

给定区间 `[l, r]`（下标从 1 开始），子串哈希值为：



$$hash(l, r) = h[r] - h[l-1] * p[r-l+1]
$$
**推导**（理解后可以不用背）：

- `h[r]` 相当于 `P^(r-1)*s1 + ... + P^0*sr`
    
- `h[l-1]` 相当于 `P^(l-2)*s1 + ... + P^0*s(l-1)`
    
- 将 `h[l-1]` 左移 `r-l+1` 位（乘以 `p[r-l+1]`），再相减，正好得到 `s[l..r]` 的 P 进制表示。
    

🔴 **易错点**：

- **下标必须从 1 开始**，`h[0]=0`。
    
- **乘法可能溢出**：用 `unsigned long long` 自然溢出，相当于自动 `mod 2^64`。
    
- **字符映射不能有 0**，否则 `"A"` 和 `"AA"` 冲突。
    

---

## 2.4 完整代码模板

```cpp

typedef unsigned long long ULL;
const int N = 100010, P = 131;
ULL h[N], p[N];
char str[N];
// 预处理
p[0] = 1;
for (int i = 1; i <= n; i++) {
    h[i] = h[i-1] * P + (str[i] - 'a' + 1);
    p[i] = p[i-1] * P;
}
// 子串哈希查询
ULL get(int l, int r) {
    return h[r] - h[l-1] * p[r-l+1];
}
```
---

## 2.5 经典应用：快速判断两个子串是否相等

**例题**：给定字符串 S 和 Q 次询问，每次问 `[l1,r1]` 与 `[l2,r2]` 是否相等。

**解法**：预处理前缀哈希，每次 O(1) 计算两个子串哈希值，比较即可。

**优势**：比 KMP 更简单，尤其适合**大量随机查询**。  
**局限**：不能解决循环节等需要匹配过程的问题。

---

# 三、C++ STL 常用容器 —— 竞赛必备武器

## 3.1 vector —— 动态数组

### 倍增思想

`vector` 底层是动态数组，容量不够时**申请 2 倍新空间**，将原元素拷贝过去。  
**均摊时间复杂度 O(1)**，因为总拷贝次数约为 `2n`。

### 常用操作

```cpp

vector<int> a;          // 空 vector
vector<int> a(10);      // 长度 10，默认 0
vector<int> a(10, 3);   // 长度 10，所有元素为 3
vector<int> a[10];      // 10 个 vector 的数组（二维）
a.size(); a.empty(); a.clear();
a.front(); a.back();    // 首尾元素
a.push_back(x); a.pop_back();
a.begin(); a.end();     // 迭代器
```
### 遍历方式

```cpp

// 下标遍历
for (int i = 0; i < a.size(); i++) cout << a[i];
// 迭代器遍历
for (auto it = a.begin(); it != a.end(); it++) cout << *it;
// 范围遍历（C++11）
for (auto x : a) cout << x;
```
### 比较运算

`vector` 支持 `==`, `!=`, `<`, `<=`, `>`, `>=`，按**字典序**比较。

---

## 3.2 pair —— 二元组

### 定义与访问

```cpp

pair<int, string> p;
p.first = 1; p.second = "abc";
p = {2, "def"};                 // C++11 花括号初始化
p = make_pair(3, "ghi");       // 旧式构造
```
### 比较运算

默认**先比 first，再比 second**，字典序。

### 嵌套扩展

```cpp

pair<int, pair<int, int>> p;   // 存储三个属性
p = {1, {2, 3}};
cout << p.first << p.second.first << p.second.second;
```
🟢 **记忆口诀**：“**pair 是个小包裹，两个东西塞一处；自带比较字典序，嵌套还能装更多。**”

---

## 3.3 string —— 字符串

### 常用操作

```cpp

string s = "hello";
s.size(); s.empty(); s.clear();
s += " world";          // 拼接
s += '!';
```
### substr —— 子串提取

```cpp

string sub = s.substr(pos, len);   // len 可省略，默认到结尾
// 注意：第二个参数是长度，不是结束位置！和 Java/Python 不同
```
### 输出到 printf

```cpp

printf("%s", s.c_str());   // 必须加 .c_str()
```
---

## 3.4 queue —— 队列

### 基本操作

```cpp

queue<int> q;
q.push(x);      // 队尾插入
q.pop();        // 队首弹出（无返回值）
q.front();      // 访问队首
q.back();       // 访问队尾
q.size(); q.empty();
```
### 清空技巧

队列**没有 clear() 函数**，清空方法：

```cpp

q = queue<int>();   // 重新赋一个空队列
```
---

## 3.5 priority_queue —— 优先队列（堆）

### 默认大根堆

```cpp

priority_queue<int> pq;
pq.push(x);
pq.top();       // 返回最大值
pq.pop();       // 弹出最大值
```
### 小根堆的两种实现

```cpp

// 方法1：插入负数
pq.push(-x);    // 取 top 时再取反
// 方法2：显式声明
priority_queue<int, vector<int>, greater<int>> pq;
```
### 清空

同样无 clear，重新赋值：

```cpp

pq = priority_queue<int>();
```
---

## 3.6 stack —— 栈

### 基本操作

```cpp

stack<int> st;
st.push(x);
st.top();       // 返回栈顶
st.pop();       // 弹出栈顶（无返回值）
st.size(); st.empty();
```
无 clear，清空同 queue。

---

## 3.7 deque —— 双端队列

### 操作

```cpp

deque<int> dq;
dq.push_back(x); dq.pop_back();
dq.push_front(x); dq.pop_front();
dq.front(); dq.back();
dq[0]; dq[1];               // 支持随机访问
dq.size(); dq.empty(); dq.clear();  // 有 clear！
```
**性能**：比 vector 慢，竞赛中除非需要频繁头尾操作，否则少用。

---

## 3.8 set / multiset —— 集合

### 插入、查找、删除

```cpp

set<int> s;
s.insert(x);        // O(logn)，重复插入会被忽略
s.find(x);          // 返回迭代器，若不存在返回 s.end()
s.count(x);         // 返回个数（set 中 0/1，multiset 可能 >1）
s.erase(x);         // 删除所有等于 x 的元素（O(logn + k)）
s.erase(it);        // 删除迭代器指向的元素（O(1)）
s.size(); s.empty(); s.clear();
```
### 二分查找（仅 set/map 有）

```cpp

auto it = s.lower_bound(x);   // 第一个 >= x 的元素
auto it = s.upper_bound(x);   // 第一个 >  x 的元素
```
若不存在，返回 `s.end()`。

🔴 **注意**：`unordered_set` **没有** `lower_bound/upper_bound`。

---

## 3.9 map / multimap —— 映射

### 插入与访问

```cpp

map<string, int> m;
m["abc"] = 1;           // 下标访问，若键不存在会自动创建，O(logn)
m.insert({"def", 2});   // 插入 pair
m.erase("abc");         // 删除键
m.find("abc");          // 返回迭代器
m.count("abc");         // 0 或 1
```
### 迭代器

```cpp

for (auto it = m.begin(); it != m.end(); it++)
    cout << it->first << ' ' << it->second << endl;
for (auto &[k, v] : m)   // C++17 结构化绑定
    cout << k << ' ' << v << endl;
```
---

## 3.10 unordered_map / unordered_set —— 哈希表版

### 与 map/set 的区别

| 对比    | map/set        | unordered_map/unordered_set |
| ----- | -------------- | --------------------------- |
| 底层    | 红黑树（平衡树）       | 哈希表                         |
| 有序性   | **有序**（按 key）  | **无序**                      |
| 时间复杂度 | O(logn)        | **平均 O(1)**，最坏 O(n)         |
| 二分查找  | 支持 lower_bound | 不支持                         |
| 迭代器   | 支持 ++/-- 操作    | 不支持加减                       |
| 适用场景  | 需要有序或二分        | 仅需快速增删查                     |

### 使用建议

- 一般情况用 `unordered_map` 更快，除非需要有序性。
    
- 自定义类型需要自己提供哈希函数（竞赛极少用）。
    

---

## 3.11 bitset —— 位集

### 为什么需要 bitset？

一个 `bool` 数组占用 **1 字节**（8 位），而 `bitset` **1 位**存储一个布尔值，**节省 8 倍内存**。

**定义**：

```cpp

bitset<10000> bs;   // 编译期确定大小，尖括号内是常量
```
### 常用操作

```cpp

bs[pos] = 1;        // 访问/赋值
bs.count();         // 返回 1 的个数
bs.any();           // 是否有 1
bs.none();          // 是否全 0
bs.set();           // 全部置 1
bs.set(pos, val);   // 指定位置赋值
bs.reset();         // 全部置 0
bs.flip();          // 全部取反
bs.flip(pos);       // 指定位取反
```
### 位运算支持

```cpp

bitset<4> a("0110"), b("1010");
auto c = a & b;     // 0010
auto d = a | b;     // 1110
auto e = a ^ b;     // 1100
auto f = ~a;        // 1001
```
**例题**：10000×10000 的布尔矩阵，用 `bitset<10000> mat[10000]` 存储，内存仅约 10000×10000/8 ≈ 12.5MB，而 `bool` 数组需要 100MB+。

---

# 📊 本章知识小结 —— 考试前夜必看

|知识点|核心思想|零基础理解锚点|易错点|难度|
|---|---|---|---|---|
|**哈希表（拉链法）**|数组+链表，冲突链挂|电影院座位后排队|负数取模、质数选取|★★★★|
|**哈希表（开放寻址）**|数组连续，线性探测|公共厕所蹲坑|find 循环、空标记|★★★★|
|**字符串哈希**|P 进制数，前缀哈希|把字符串当数字|映射从 1 开始、ULL 溢出|★★★★★|
|**vector**|动态数组，倍增|可变长数组|clear() 复杂度 O(1)|★★|
|**pair**|二元组|两个数据打包|嵌套访问|★★|
|**string**|字符串|substr 长度参数|c_str()|★★|
|**queue**|先进先出|排队|无 clear|★★|
|**priority_queue**|堆|大根堆|小根堆声明|★★★|
|**stack**|先进后出|叠盘子|无 clear|★★|
|**deque**|双端队列|两头可进出|性能慢|★★★|
|**set/map**|红黑树|有序集合|lower_bound 用法|★★★★|
|**unordered_map**|哈希表|无序快查|无 lower_bound|★★★★|
|**bitset**|位压缩|节省内存|大小是常量|★★★|

---

# 🎓 写在最后：哈希与 STL，竞赛的双刃剑

哈希表让你**无视数据范围，快速插入查询**，但**冲突处理**是灵魂；  
字符串哈希让你**任意子串比较 O(1)**，但**模数选择**是运气；  
STL 让你**十分钟写完别人一小时的数据结构**，但**选错容器复杂度翻车**。

**给你的硬核建议**：

1. **手写哈希表**：拉链法和开放寻址法各写 3 遍，直到不用查模板。
    
2. **字符串哈希**：拿 `"abcabc"` 手动计算 `h[i]` 和子串哈希，验证公式。
    
3. **STL 容器**：每种容器写一个 demo，故意写错（比如 `queue` 用 `pop()` 但忘记 `front()`），看看编译器报什么错。
    
4. **优先队列**：练习「第 k 大的数」等题目，掌握大小根堆切换。
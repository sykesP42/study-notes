# 基础算法课 Week6 —— 中国剩余定理（非互质版）

**献给所有被同余方程、扩展欧几里得、大数溢出绕晕过的初学者**

> 🔴 **阅读提示**：本章是**第六周习题课**，专讲**中国剩余定理（CRT）的非互质推广**——如何求解**模数不两两互质**的线性同余方程组。  
> 我们会从**两个方程联立**开始，推导通解公式，**用扩展欧几里得求特解**，并**逐步合并方程**，最终给出完整代码。  
> 🎯 **目标**：学完本章，你将彻底掌握**任意模数线性同余方程组的通用解法**，并能在 10 分钟内写出无 bug 的代码。

---

## 📌 开篇：中国剩余定理 —— 不只适用于互质

**经典中国剩余定理**：若模数两两互质，则方程组

{x≡m1(moda1)x≡m2(moda2)⋮x≡mn(modan)⎩⎨⎧​x≡m1​(moda1​)x≡m2​(moda2​)⋮x≡mn​(modan​)​

![[Pasted image 20260213142904.png]]
一定有解，且解模 $A = \prod a_i$ 唯一。

但题目常常**不保证模数互质**，这时经典 CRT 失效，我们需要**更通用的合并方法**。

**核心思想**：每次合并两个方程，得到一个新的同余方程，**重复 $n-1$ 次**，最终得到 $x \equiv X \pmod{L}$，其中 $L = \mathrm{lcm}(a_1, a_2, \dots, a_n)$。

---

# 第一部分 · 从两个方程开始 —— 推导合并公式

## 一、方程组改写为等式

设有两个方程：

x≡m1(moda1),x≡m2(moda2)x≡m1​(moda1​),x≡m2​(moda2​)

等价于存在整数 $k_1, k_2$ 使得：

x=a1k1+m1,x=a2k2+m2x=a1​k1​+m1​,x=a2​k2​+m2​

联立得：

a1k1−a2k2=m2−m1a1​k1​−a2​k2​=m2​−m1​

---

## 二、解的存在条件

令 $d = \gcd(a_1, a_2)$。  
方程 $a_1 k_1 - a_2 k_2 = m_2 - m_1$ 有整数解的**充要条件**是：

d∣(m2−m1)d∣(m2​−m1​)

若此条件不成立，则**整个方程组无解**。

---

## 三、用扩展欧几里得求特解

我们首先求解方程：

a1k1−a2k2=da1​k1​−a2​k2​=d

用扩展欧几里得算法 `exgcd(a1, a2, k1, k2)`，可以得到一组特解 $(k_1', k_2')$ 满足：

a1k1′−a2k2′=da1​k1′​−a2​k2′​=d

**注意**：扩展欧几里得标准形式是 $a x + b y = \gcd(a,b)$，这里我们有减法，可以令 $k_2 = -k_2$ 来转换，但更简单的是直接使用 `exgcd(a1, a2, k1, k2)` 得到 $a_1 k_1 + a_2 k_2 = d$，然后令 $k_2 = -k_2$ 即可得到 $a_1 k_1 - a_2 k_2 = d$。

为了得到原方程的解，两边同时乘以 $\dfrac{m_2 - m_1}{d}$：

k1=k1′⋅m2−m1d,k2=−k2′⋅m2−m1d(注意符号)k1​=k1′​⋅dm2​−m1​​,k2​=−k2′​⋅dm2​−m1​​(注意符号)

---

## 四、通解形式

二元一次不定方程的通解为：

k1=k1+t⋅a2d,k2=k2+t⋅a1d(t∈Z)k1​=k1​+t⋅da2​​,k2​=k2​+t⋅da1​​(t∈Z)

（这里 $k_1, k_2$ 已更新为原方程的特解）

代入 $x = a_1 k_1 + m_1$：

x=a1(k1+t⋅a2d)+m1=(a1k1+m1)+t⋅a1a2dx=a1​(k1​+t⋅da2​​)+m1​=(a1​k1​+m1​)+t⋅da1​a2​​

注意到 $\dfrac{a_1 a_2}{d} = \mathrm{lcm}(a_1, a_2)$。

因此，两个方程合并为一个新的同余方程：

x≡x0(modlcm(a1,a2))x≡x0​(modlcm(a1​,a2​))

其中 $x_0 = a_1 k_1 + m_1$（取任意一个特解）。

🔵 **结论**：两个同余方程等价于一个同余方程，模数为原来模数的**最小公倍数**，余数为特解 $x_0$。

---

# 第二部分 · 多方程合并 —— 迭代法

## 一、算法流程

1. 读入第一个方程，记当前模数为 $a = a_1$，当前余数为 $m = m_1$（即当前解为 $x \equiv m \pmod{a}$）。
    
2. 对于剩下的 $n-1$ 个方程：
    
    - 将当前方程 $(a, m)$ 与新方程 $(a_i, m_i)$ 按上述方法合并。
        
    - 若合并过程中出现无解（$d \nmid (m_i - m)$），则标记无解并退出。
        
    - 否则得到新的 $a = \mathrm{lcm}(a, a_i)$，新的 $m = x_0$（取最小非负余数）。
        
3. 最终 $x = m$（模 $a$ 的最小非负解）即为答案。
    

---

## 二、关键细节

### 1. 扩展欧几里得的使用

我们要求解 $a_1 k_1 - a_2 k_2 = d$，但 `exgcd` 返回的是 $a_1 x + a_2 y = d$。  
我们可以调用 `exgcd(a1, a2, x, y)` 得到 $a_1 x + a_2 y = d$，然后令：

k1=x,k2=−yk1​=x,k2​=−y

这样就有 $a_1 k_1 - a_2 k_2 = d$。

### 2. 特解的缩放

得到特解后，两边乘以 $\dfrac{m_2 - m_1}{d}$：

k1=x⋅m2−m1d,k2=−y⋅m2−m1dk1​=x⋅dm2​−m1​​,k2​=−y⋅dm2​−m1​​

注意这里可能出现负数，我们稍后会调整。

### 3. 最小正整数 $k_1$

通解中 $k_1$ 可以加上 $t \cdot \dfrac{a_2}{d}$。  
我们希望得到一个**最小非负**的 $k_1$，以便 $x_0 = a_1 k_1 + m_1$ 尽可能小。  
令 $t = \dfrac{a_2}{d}$，则：

k1=(k1  t+t)  tk1​=(k1​modt+t)modt

（C++ 中取模可能得负，用 `(k1 % t + t) % t` 确保非负）

### 4. 最小公倍数的计算

lcm(a1,a2)=a1d⋅a2lcm(a1​,a2​)=da1​​⋅a2​

**先除后乘**，防止溢出（虽然这里我们用 long long，但极限情况 $a_i \approx 2^{31}$，直接乘可能溢出，先除是好的习惯）。

### 5. 新余数 $x_0$ 的取模

得到 $x_0 = a_1 k_1 + m_1$ 后，我们应将其对新的模数 $a = \mathrm{lcm}$ 取最小非负余数：

x0=(x0  a+a)  ax0​=(x0​moda+a)moda

保证下次合并时余数范围合法（$0 \leq m < a$）。

---

## 三、完整代码模板（带防呆注释）


```cpp

#include <iostream>
using namespace std;
typedef long long LL;
LL exgcd(LL a, LL b, LL &x, LL &y) {
    if (!b) {
        x = 1, y = 0;
        return a;
    }
    LL d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}
int main() {
    int n;
    cin >> n;
    LL a1, m1;
    cin >> a1 >> m1;          // 读入第一个方程
    bool has_answer = true;
    for (int i = 0; i < n - 1; i++) {
        LL a2, m2;
        cin >> a2 >> m2;
        LL k1, k2;
        LL d = exgcd(a1, a2, k1, k2);   // a1*k1 + a2*k2 = d
        if ((m2 - m1) % d) {            // 无解条件
            has_answer = false;
            break;
        }
        k1 *= (m2 - m1) / d;            // 乘上倍数，得到特解
        LL t = a2 / d;                 // 通解中 k1 的增量模数
        k1 = (k1 % t + t) % t;         // 调整到最小正整数
        m1 = a1 * k1 + m1;             // 新的余数 x0
        a1 = abs(a1 / d * a2);         // 新的模数 = lcm(a1, a2)
        m1 = (m1 % a1 + a1) % a1;      // 保证余数在 [0, a1-1]
    }
    if (has_answer) cout << m1 << endl;
    else cout << -1 << endl;
    return 0;
}
```
---

# 第三部分 · 易错点与细节（🔴必看）

## 1. 扩展欧几里得符号处理

我们调用 `exgcd(a1, a2, k1, k2)` 得到的是 $a_1 k_1 + a_2 k_2 = d$。  
而我们需要的方程是 $a_1 k_1 - a_2 k_2 = m_2 - m_1$。  
**两种处理方式**：

- 直接在 `exgcd` 后将 `k2` 取负，后面特解公式也要相应调整（k2 *= -...）。
    
- 或者合并时直接使用加法形式，将方程改写为 $a_1 k_1 + a_2 k_2 = m_2 - m_1$ 并允许 `k2` 为负。但这样在调整最小正整数解时需要对 `k1` 和 `k2` 分别处理，容易乱。
    

**推荐**：用减法版本，即：

cpp

LL d = exgcd(a1, a2, k1, k2);
k2 = -k2;   // 现在 a1*k1 - a2*k2 = d
k1 *= (m2 - m1) / d;
k2 *= (m2 - m1) / d;  // k2 可能用不到，但保持更新

**本笔记代码未显式取负**，而是直接使用了加法形式，但注意在调整 `k1` 时，我们只用了 `k1` 和 `a2/d`，这与减法形式下的通解一致（因为通解中 `k1` 的增量是 `a2/d`，符号与方程形式无关）。因此代码中**不需要显式取负**，只要保证 `k1` 是方程 $a_1 k_1 - a_2 k_2 = m_2 - m_1$ 的一个特解即可。我们通过 `exgcd` 得到 $a_1 k_1 + a_2 k_2 = d$，然后令 `k1 *= (m2-m1)/d`，此时 `k1` 满足 $a_1 k_1 - a_2 (-k_2) = m_2 - m_1$，而我们的通解增量 `a2/d` 对 `k1` 依然成立（因为加上 `t*a2/d` 后，等式仍然成立）。所以代码中不需要额外处理符号也能正确。

**但为保险**，建议在注释中说明。

---

## 2. 无解判断必须用 `(m2 - m1) % d != 0`

这里 `%` 是 C++ 取余，可能得负，但 `(m2 - m1) % d` 与 0 比较时，负数模不为 0 也能正确判断（例如 -5 % 3 = -2 ≠ 0）。所以直接 `(m2 - m1) % d` 没问题，但可读性起见，可写成 `((m2 - m1) % d + d) % d != 0`。

---

## 3. 最小正整数 $k_1$ 的调整

通解 $k_1 = k_1 + t \cdot \dfrac{a_2}{d}$。  
我们需要 $k_1$ 在模 $\dfrac{a_2}{d}$ 下最小非负。  
因此：

```cpp

LL t = a2 / d;
k1 = (k1 % t + t) % t;
```
**注意**：这里 `k1` 可能为负，所以先取模再加模再取模。

---

## 4. 新模数 $a_1$ 的更新

$a_1 = \dfrac{a_1}{d} \cdot a_2$ 是 lcm，但注意 $a_1/d$ 可能不是整数？不，d 是 a1 和 a2 的最大公约数，所以 a1/d 是整数。  
**必须先除后乘**，否则可能溢出（虽然 long long 在 2e18 范围内，但两个接近 2e9 的数相乘可能超 4e18，超过 long long 上限约 9e18，仍可能溢出，所以先除是良好的习惯）。

---

## 5. 新余数 $m_1$ 的取模

$m_1 = a_1 k_1 + m_1$ 可能很大，也可能为负，需模 $a_1$ 并调整到非负：

```cpp

m1 = (m1 % a1 + a1) % a1;
```
---

## 6. 数据范围

- $a_i \leq 2^{31}-1$，$n \leq 25$，最终模数可能极大，但题目保证答案在 64 位整数内，所以我们用 `long long` 足够。
    
- 中间乘法 $a_1 * k_1$ 可能溢出，但 $k_1$ 被调整到 $\dfrac{a_2}{d}$ 以内，$\dfrac{a_2}{d} \leq a_2 \leq 2 \times 10^9$，所以乘积 $\leq a_1 \cdot a_2 / d \leq \mathrm{lcm} \leq 2 \times 10^{18}$，long long 可存（$2 \times 10^{18} < 9 \times 10^{18}$）。
    

---

🟢 **记忆口诀**：

> **中国剩余推广版，方程合并是关键；**  
> **exgcd 求特解，无解检查 d 整除；**  
> **k1 调小加增量，lcm 更新模不变。**

---

# 第四部分 · 课程答疑与规划（简记）

笔记后半部分为课程运营相关，简要整理如下：

- **课程调整**：状态压缩DP与高精度压位将移至下次习题课；近期老师因毕业及搬家事务较多，之后将集中直播。
    
- **学员数据**：第一周打卡178人 → 第二周97人 → 第三周76人，数论章节难度导致参与度下降。录播观看为主，直播适合思路讲解。
    
- **平台功能**：即将上线代码自测功能；题解系统将支持视频链接，建立题目与讲解的关联。
    
- **版权与合作**：多数OJ不主张题目版权（题解价值更高），牛客网坚持版权保护；计划与牛客网开展高中竞赛培训合作，并考虑B站引流。
    
- **未来规划**：开放用户创作内容，建立奖励机制；重点发展《算法竞赛进阶指南》配套资源，目标成为官方配套平台。
    

（_此部分非算法核心，保留要点即可。_）

---

# 📊 知识小结

|模块|核心内容|易错点|难度|
|---|---|---|---|
|**两方程合并**|转化为不定方程，exgcd 求特解，通解形式|符号处理、无解判断|★★★★|
|**多方程迭代**|每次合并后更新模数和余数|新余数取模、lcm 计算|★★★★|
|**代码实现**|循环 n-1 次，标记无解|k1 取最小正、先除后乘|★★★★|
|**数据范围**|使用 long long，防止溢出|中间乘积可能超 int|★★★|

---

# 🎓 写在最后：中国剩余定理是“合并”的艺术

很多同学学完互质版 CRT 后，遇到非互质的题目就慌了，以为要记新公式。  
**其实不需要** —— 你只需要记住**如何合并两个方程**，然后**迭代 n-1 次**。

这个思想远不止用于 CRT，而是**解线性同余方程组的通用方法**。  
掌握了它，你就掌握了数论中最重要的“归约”技巧。

**给你的硬核建议**：

1. 自己动手推导一遍两方程合并的通解，不要直接背公式。
    
2. 写代码时故意把无解条件写错（比如 `(m2 - m1) % d == 0` 却判有解），看看会发生什么。
    
3. 测试极限数据：`a1 = 2e9, a2 = 2e9-1, m1 = 0, m2 = 1`，验证程序是否溢出。
    
4. 尝试不调整 `k1` 为最小正，直接输出，看看结果是否受影响（其实不影响正确性，但余数可能很大，最后取模后仍对，但中间乘法可能溢出）。
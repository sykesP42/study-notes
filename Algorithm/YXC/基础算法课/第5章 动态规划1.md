# 第五章 动态规划（一）—— 背包问题，从“装还是不装”到“装多少个”


> 🎯 **目标**：学完本章，你将彻底掌握**01背包、完全背包、多重背包、分组背包**的核心思想与代码实现，并深刻理解**状态表示、状态计算、集合划分**这一动态规划的通用思考框架。从此背包问题不再靠死记硬背。

---

# 📌 开篇：动态规划 —— 一种“聪明的枚举”

想象你要从一堆物品中选出一些装进背包，使总价值最大。  
最笨的方法是枚举所有子集 —— 2ⁿ 种，n=1000 时直接爆炸。  
**动态规划**则利用**重叠子问题**和**最优子结构**，将指数级枚举降为多项式时间。

**背包问题**是动态规划的入门经典，也是理解 DP 状态设计的绝佳模型。  
**本章，我们从最简单的 01 背包出发，一步步征服所有背包变种。**

---

# 第一部分 · 动态规划方法论 —— 两句话搞定所有 DP

## 一、DP 分析的两步法

任何动态规划问题，都可以拆解为两个核心步骤：

1. **状态表示** —— 我要用什么样的数组维度来描述一个子问题？这个数组里存的是什么？
    
2. **状态计算** —— 当前状态的值怎么从之前的状态推导出来？
    

**用公式表达**：


$$DP = 状态表示 + 状态转移$$

---

## 二、状态表示 —— 集合 + 属性

- **集合**：状态 `f(i, j, ...)` 代表**满足某些条件的所有方案的集合**。
    
- **属性**：这个集合里我们关心的是什么？通常是三种之一：  
    ✅ **最大值**（如背包最大价值）  
    ✅ **最小值**（如最短路径）  
    ✅ **数量**（如方案总数）
    

**示例**（01背包）：  
`f[i][j]` 表示**只从前 i 个物品中选，总体积不超过 j 的所有选法的集合**。  
我们关心的是这些选法的**最大总价值**。

🔴 **初学者误区**：把状态直接理解为“前 i 个物品体积不超过 j 的最大价值” —— 这是正确的，但为了理解透彻，一定要知道这个值背后对应一个**集合**，DP 的过程就是对这个集合进行**划分**和**计算属性**。

---

## 三、状态计算 —— 集合划分

状态计算的核心是**集合划分**：把当前状态的集合划分成若干个**互不相交**的子集，每个子集可以由之前的状态直接表示。

**划分原则**：

- **不重复**（求方案数时必须满足，求最值时通常也建议满足，但非强制）
    
- **不遗漏**（必须满足，所有方案都要被分到某个子集中）
    

**示例**（01背包）：  
`f[i][j]` 对应的集合可以划分为两个子集：

1. **不选第 i 个物品**：等价于 `f[i-1][j]` 对应的集合。
    
2. **选第 i 个物品**：先去掉第 i 个物品，转化为 `f[i-1][j - v[i]]` 的集合，再加上价值 `w[i]`。
    

因此：


$$f[i][j] = max( f[i-1][j], f[i-1][j - v[i]] + w[i] )$$

**这就是动态规划的全部秘密**。

🟢 **记忆口诀**：“**DP 两步走，状态表示定维度，集合属性记清楚；状态计算划分子集，转移方程写出来。**”

---

# 第二部分 · 01背包问题 —— 选或不选

## 一、故事引入：海鲜自助餐的抉择

你去吃自助餐，面前有 N 种菜品，每种只有一盘（拿了就没了）。  
你的胃容量是 V 毫升。  
每种菜品 i 有体积 v[i]（占胃容量）和美味值 w[i]。  
你**最多拿一盘**，问怎么选才能让总美味值最大？

**这就是 01 背包**。

---

## 二、状态表示

我们用二维数组 `f[i][j]`：

- **集合**：只考虑前 i 个物品，总体积**不超过** j 的所有选法。
    
- **属性**：最大总价值（max）。
    

**最终答案**：`f[N][V]`。

---

## 三、状态转移方程

对于第 i 个物品，有两种决策：

1. **不选**：最大价值 = `f[i-1][j]`（问题退化为前 i-1 个物品）。
    
2. **选**：必须先给第 i 个物品腾出 v[i] 的空间，然后加上它的价值。  
    **关键**：选完之后，问题变成**前 i-1 个物品，容量为 j - v[i] 的子问题**，再加上 w[i]。  
    因此：`f[i-1][j - v[i]] + w[i]`。
    

两者取最大值：


$$f[i][j] = max( f[i-1][j], f[i-1][j - v[i]] + w[i] )$$

**条件**：只有当 `j ≥ v[i]` 时，第二个选项才有意义。

---

## 四、二维代码模板（朴素版）


```cpp

#include <iostream>
using namespace std;
const int N = 1010;
int n, m;           // n 物品数，m 背包容量
int v[N], w[N];     // 体积、价值
int f[N][N];        // DP 数组
int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j <= m; j++) {
            f[i][j] = f[i-1][j];                // 不选
            if (j >= v[i])                      // 能选才考虑
                f[i][j] = max(f[i][j], f[i-1][j - v[i]] + w[i]);
        }
    }
    cout << f[n][m] << endl;
    return 0;
}
```
**时间复杂度**：O(n × m)  
**空间复杂度**：O(n × m)

---

## 五、空间优化 —— 一维数组（滚动数组）

**观察**：`f[i][j]` 只依赖 `f[i-1][j]` 和 `f[i-1][j - v[i]]`，**只用到上一层的状态**。  
我们可以只用一维数组 `f[j]`，**滚动更新**。

**关键**：如果正序更新，`f[j - v[i]]` 已经被当前 i 层覆盖，不再是上一层的数据。  
**必须逆序**：从 `m` 到 `v[i]` 递减，保证 `f[j - v[i]]` 还是 i-1 层的值。

```cpp

int f[N];   // 一维数组
for (int i = 1; i <= n; i++)
    for (int j = m; j >= v[i]; j--)      // 🔴 逆序！
        f[j] = max(f[j], f[j - v[i]] + w[i]);
```
🔴 **为什么逆序？**

- 正序时，`f[j - v[i]]` 已经被当前 i 层更新过，可能已经包含了第 i 个物品，这样再选一次第 i 个物品就相当于**选多次**，违反了 01 背包“每件物品最多一次”的规则。
    
- 逆序时，`j - v[i] < j`，且我们从大到小更新，`f[j - v[i]]` 还保留着上一层的值，不会出现“已选过”的情况。
    

✅ **验证**：  
假设当前 i 固定，逆序遍历 `j`，`f[较大容量]` 会用到 `f[较小容量]`，但较小容量尚未被当前 i 更新（因为我们在从大到小走），所以它仍是上一层的值。

🟢 **记忆口诀**：“**01背包逆序行，保证每个只用零；正序会变完全包，这是两者分水岭。**”

---

## 六、完整一维代码

```cpp

#include <iostream>
using namespace std;
const int N = 1010;
int n, m;
int v[N], w[N];
int f[N];
int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    for (int i = 1; i <= n; i++)
        for (int j = m; j >= v[i]; j--)
            f[j] = max(f[j], f[j - v[i]] + w[i]);
    cout << f[m] << endl;
    return 0;
}
```
**空间复杂度**：O(m)，n=1000,m=1000 时仅 4KB 内存。

---

# 第三部分 · 完全背包问题 —— 无限取用

## 一、故事引入：饮料自助机

自助饮料机里有 N 种饮料，每种无限供应。  
你的杯子容量 V 毫升。  
每种饮料 i 每瓶 v[i] 毫升，美味值 w[i]。  
你可以**取任意多瓶**（同一品种可以一直拿），问最大总美味值。

---

## 二、状态表示

**与 01 背包完全一样**：`f[i][j]` 表示**只从前 i 种物品中选，总体积不超过 j** 的最大价值。  
**区别**：每种物品可以选无限次。

---

## 三、朴素状态转移（暴力枚举个数）

按照 DP 的集合划分思路：按第 i 种物品**选几个**来划分。

```text

f[i][j] = max{
    f[i-1][j],                 // 选 0 个
    f[i-1][j - v[i]] + w[i],  // 选 1 个
    f[i-1][j - 2*v[i]] + 2*w[i], // 选 2 个
    ...
    f[i-1][j - k*v[i]] + k*w[i] // 直到容量不够
}
```
**三重循环**：

- 物品 i
    
- 容量 j
    
- 个数 k（k*v[i] ≤ j）
    

**时间复杂度**：O(n × m²)（当 v[i] = 1 时，k 最大到 m，直接爆炸）。

---

## 四、惊天优化 —— 展开找规律

把 `f[i][j]` 和 `f[i][j - v[i]]` 展开：

```text

f[i][j]   = max( f[i-1][j], f[i-1][j-v] + w, f[i-1][j-2v] + 2w, f[i-1][j-3v] + 3w, ... )
f[i][j-v] = max( f[i-1][j-v], f[i-1][j-2v] + w, f[i-1][j-3v] + 2w, ... )
```
观察：`f[i][j]` 的后半部分（从第二项开始）**正好是 `f[i][j-v]` 的每一项加上 w**！

因此：


$$f[i][j] = max( f[i-1][j], f[i][j-v] + w )$$

**完美！** 把枚举 k 的循环优化掉了。

---

## 五、优化后的二维代码

```cpp

for (int i = 1; i <= n; i++)
    for (int j = 0; j <= m; j++) {
        f[i][j] = f[i-1][j];
        if (j >= v[i])
            f[i][j] = max(f[i][j], f[i][j - v[i]] + w[i]);   // 注意这里是 f[i][...] 不是 f[i-1]
    }
```
🔴 **与 01 背包的区别**：

- 01 背包：`f[i][j] = max(f[i-1][j], f[i-1][j-v] + w)`
    
- 完全背包：`f[i][j] = max(f[i-1][j], f[i][j-v] + w)`
    

**转移来源不同**：  
01 背包不能重复选，所以必须从 i-1 层转移；  
完全背包可以重复选，所以可以从**本层更小容量**转移，这正是**同层递推**。

---

## 六、一维空间优化（正序！）

既然转移时用的是 `f[i][j-v]`，一维情况下，如果我们要复用同一数组，必须保证 `f[j-v]` 已经是**当前 i 层**的值。  
**这就要求 j 从小到大（正序）枚举**。

```cpp

for (int i = 1; i <= n; i++)
    for (int j = v[i]; j <= m; j++)   // ✅ 正序！
        f[j] = max(f[j], f[j - v[i]] + w[i]);
```
**为什么正序正确？**

- 当我们更新 `f[j]` 时，`f[j - v[i]]` 可能已经被本轮 i 更新过了（因为 j 递增，j - v[i] < j）。
    
- 这个被更新过的 `f[j - v[i]]` 已经包含了**可能已经选了若干个第 i 个物品**的状态，这正是完全背包所需的“可以重复选”的性质。
    

**对比**：

- 01背包：逆序，避免重复。
    
- 完全背包：正序，允许重复。
    

---

## 七、完整一维代码

```cpp

#include <iostream>
using namespace std;
const int N = 1010;
int n, m;
int v[N], w[N];
int f[N];
int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    for (int i = 1; i <= n; i++)
        for (int j = v[i]; j <= m; j++)   // 🔴 正序！
            f[j] = max(f[j], f[j - v[i]] + w[i]);
    cout << f[m] << endl;
    return 0;
}
```
**时间复杂度**：O(n × m)  
**空间复杂度**：O(m)

🟢 **记忆口诀**：“**完全背包正序跑，本层容量重复找；01逆序怕重选，正序无限随便挑。**”

---

# 第四部分 · 多重背包问题 —— 有限数量

## 一、故事引入：超市限购

超市促销，每种商品 i 有库存限制，最多只能买 s[i] 件。  
其他条件同 01 背包（体积 v[i]，价值 w[i]）。  
如何选择使总价值最大？

---

## 二、朴素解法（三重循环）

**状态表示**：`f[i][j]` —— 只从前 i 种物品中选，体积 ≤ j 的最大价值。  
**集合划分**：按第 i 种物品选 k 个（k = 0,1,…,s[i]），且 k*v[i] ≤ j。

**转移方程**：


```text

f[i][j] = max_{k=0..s[i], k*v[i]≤j} ( f[i-1][j - k*v[i]] + k*w[i] )
```
**代码**：

```cpp

for (int i = 1; i <= n; i++)
    for (int j = 0; j <= m; j++)
        for (int k = 0; k <= s[i] && k * v[i] <= j; k++)
            f[i][j] = max(f[i][j], f[i-1][j - k*v[i]] + k*w[i]);
```
**复杂度**：O(n × m × s)，当 s[i] 很大（如 2000）时直接超时（n=1000,m=1000,s=2000 → 2×10⁹ 次运算）。

---

## 三、二进制优化 —— 将多重背包转化为 01 背包

**核心思想**：将第 i 种物品的 s[i] 件，拆分成**若干组**，每组视为一个“新物品”，且这些新物品**只能选 0 或 1 次**。  
只要拆分的组能**组合出 0 ~ s[i] 之间的任意数量**，那么原问题等价于在这些新物品上做 01 背包。

**如何拆分？** —— **二进制拆分**。

将 s[i] 拆分为：

```text

1, 2, 4, 8, ..., 2^k, 剩余 c

其中 `2^k ≤ s[i]` 且 `2^{k+1} > s[i]`，`c = s[i] - (2^{k+1} - 1)`。
```
**为什么这样拆分能表示任意数量？**

- 1,2,4,…,2^k 可以表示 0 ~ (2^{k+1}-1) 之间的任意整数（二进制原理）。
    
- 加上剩余部分 c，可以表示 0 ~ s[i] 之间的任意整数（因为 c ≤ 2^{k+1} - 1，且组合时可以通过选或不选 c 来调整）。
    

**举例**：s[i] = 13  
拆成：1, 2, 4, 6（因为 1+2+4=7，13-7=6）。  
检验：0~13 都能表示吗？

- 0~7：由前三个二进制组任意组合。
    
- 8~13：由 6 加上 0~7 得到 6~13，但我们需要 8~13：6+2=8，6+4=10，6+2+4=12，6+1=7（重复），等等，等等，我们仔细验证一下：  
    1,2,4,6 能组合出 0~13 吗？  
    1,2,4 组合出 0~7；  
    6+0=6，6+1=7，6+2=8，6+4=10，6+1+2=9，6+1+4=11，6+2+4=12，6+1+2+4=13。  
    确实覆盖 0~13。✅
    

**拆分组数**：约 log(s[i]) 个，大大降低数量级。

---

## 四、二进制优化代码模板

```cpp

int cnt = 0;          // 拆分后新物品的总个数
for (int i = 1; i <= n; i++) {
    int a, b, s;     // 体积、价值、数量
    cin >> a >> b >> s;
    int k = 1;
    while (k <= s) {
        cnt++;
        v[cnt] = a * k;
        w[cnt] = b * k;
        s -= k;
        k *= 2;
    }
    if (s > 0) {     // 剩余部分
        cnt++;
        v[cnt] = a * s;
        w[cnt] = b * s;
    }
}
// 现在对 cnt 个新物品做 01 背包（一维逆序）
for (int i = 1; i <= cnt; i++)
    for (int j = m; j >= v[i]; j--)
        f[j] = max(f[j], f[j - v[i]] + w[i]);
```
**时间复杂度**：O(m × Σlog s[i])，n=1000,m=1000,s[i]=2000 时，Σlog ≈ 1000×11=11000，乘法后约 1.1×10⁷，完全可接受。

🔴 **易错点**：

- **拆分时不要漏掉剩余部分**。
    
- **新物品的体积和价值要乘上系数 k**（不是原体积/价值）。
    
- **拆分后做 01 背包，必须逆序枚举容量**。
    

🟢 **记忆口诀**：“**多重背包数量大，二进制拆成组；1,2,4,…加剩余，转化01轻松过。**”

---

# 第五部分 · 分组背包问题 —— 每组最多选一个

## 一、故事引入：套餐选择

你去快餐店，每组套餐（如汉堡套餐）包含几个单品，但你**每组最多只能选一个单品**（选了汉堡就不能选同组的鸡腿）。  
每组内物品互斥。  
问在容量限制下如何使总价值最大。

---

## 二、状态表示

`f[i][j]` —— 只从前 i 组物品中选，总体积 ≤ j 的最大价值。

---

## 三、状态转移

对于第 i 组，有两种可能：

1. **不选这一组任何物品**：`f[i-1][j]`。
    
2. **选这一组中的某一个物品 k**：`f[i-1][j - v[i][k]] + w[i][k]`（需满足体积条件）。
    

因此：

```text

f[i][j] = max( f[i-1][j], max_{k∈组i} ( f[i-1][j - v[i][k]] + w[i][k] ) )
```
---

## 四、一维优化（组-容量-物品三重循环）

由于每组物品互斥，**在同一组内，我们最多选一个**。  
在一维数组中，我们必须保证对于**同一个组**，每个容量的更新不会互相干扰。

**正确循环顺序**：

1. 外层循环：组别 i
    
2. 中层循环：**容量 j 从大到小**（保证本组内后续物品不会使用本组已更新的状态）
    
3. 内层循环：枚举组内物品 k
    

**为什么容量循环必须在最内层之前？**  
如果容量循环在内层，那么对于同一组的不同物品，更新 `f[j]` 时可能会用到 `f[j - v[k]]`，而这个 `f[j - v[k]]` 可能已经被本组的另一个物品更新过了，这样就可能**在同一组内选了两个物品**，违反限制。

所以正确的顺序是**先容量，后物品**（物品循环在内层）。

---

## 五、代码模板

```cpp

int n, m;               // n组，容量m
int v[N][S], w[N][S];   // v[i][k] 第i组第k个物品的体积，w[i][k] 价值
int s[N];               // s[i] 第i组的物品个数
int f[M];               // 一维DP数组
for (int i = 1; i <= n; i++)           // 枚举组
    for (int j = m; j >= 0; j--)       // 枚举容量（逆序！）
        for (int k = 0; k < s[i]; k++) // 枚举组内物品
            if (j >= v[i][k])
                f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);
```
🔴 **易错点**：

- **容量循环必须在外层，且逆序**（01 背包特性）。
    
- **组内物品的枚举在最内层**。
    
- **每组物品中，只能选一个**，这个循环结构天然保证了这一点。
    

🟢 **记忆口诀**：“**分组背包三层套，组别在外容量中，容量逆序防冲突，物品最内逐一试。**”

---

# 📊 背包问题全家福 —— 对比记忆表

| 问题类型            | 物品限制     | 状态转移方程（二维）                           | 一维循环方向    | 时间复杂度      |
| --------------- | -------- | ------------------------------------ | --------- | ---------- |
| **01背包**        | 每件最多1个   | `max(f[i-1][j], f[i-1][j-v]+w)`      | **逆序**    | O(nm)      |
| **完全背包**        | 每件无限个    | `max(f[i-1][j], f[i][j-v]+w)`        | **正序**    | O(nm)      |
| **多重背包（朴素）**    | 每件有限 s 个 | `max(f[i-1][j - k*v] + k*w)`         | 逆序（一维时）   | O(n m s)   |
| **多重背包（二进制优化）** | 拆成01背包   | 同上                                   | 逆序        | O(m Σlogs) |
| **分组背包**        | 每组最多选1个  | `max(f[i-1][j], f[i-1][j-v]+w)`（在组内） | 逆序 + 组内枚举 | O(n m s_i) |

---

# 🎓 写在最后：背包问题的思维模型

背包问题的共同点：

- **状态定义**：`f[i][j]` —— 前 i 个（组）物品，容量 ≤ j 的最优值。
    
- **状态转移**：**针对第 i 个（组）物品做决策**，决策的集合取决于物品的可用数量。
    

**掌握了 01 背包，其他背包都是它的变种**：

- **完全背包**：同层转移，正序循环。
    
- **多重背包**：二进制拆分，化多为 01。
    
- **分组背包**：组内互斥，容量在外。
    

**这四种背包，是后续所有 DP 问题的基石**。  
无论是线性 DP、区间 DP 还是树形 DP，其状态设计和转移思想都与背包同源。

**给你的硬核建议**：

1. **01背包**：手写一维版本，故意把循环改成 `j++`，看看结果为什么错了。
    
2. **完全背包**：在纸上推导 `f[i][j] = max(f[i-1][j], f[i][j-v]+w)` 的由来，理解“同层递推”。
    
3. **多重背包**：用 s=13 手动拆二进制，验证组合覆盖性。
    
4. **分组背包**：自己写一个错误的循环顺序（容量在内），观察错误结果。
# 第三章 搜索与图论（三）—— 最小生成树与二分图，从“修路”到“牵线”


> 🎯 **目标**：学完本章，你将彻底掌握**最小生成树的两种算法（Prim & Kruskal）**，并能**用染色法判定二分图**、**用匈牙利算法求解最大匹配**。从此图论完整版图收入囊中。

---

# 📌 开篇：从“修路”到“牵线”，图论的两大新任务

之前我们一直在解决**最短路径**问题——从 A 到 B 怎么走最近。  
现在我们要面对两个新问题：

1. **最小生成树**——如何用总长度最短的公路，把所有城市连通起来？（**修路**）
    
2. **二分图最大匹配**——如何给男生女生牵线，促成最多的情侣？（**牵线**）
    

**这两个问题看似无关，却分别对应图论的两大经典结构：树与匹配。**

---

# 第一部分 · 最小生成树 —— 连通所有点的最小代价

## 一、什么是最小生成树？

**定义**：给定一个**无向连通图**，选若干条边，使得所有顶点连通，且这些边的总权值最小。  
这棵树包含全部 n 个顶点，且恰好有 n-1 条边。

**生活类比**：

- 你要在 n 个村庄之间修路，每条路都有造价，目标是**让所有村庄都通路**，且**总造价最低**。
    
- 修好的路网一定是一棵树（无环），因为多一条边就会浪费钱。
    

**常见误解**：最小生成树 ≠ 最短路径树。

- 最短路径树是从一个点到所有点的最短路径构成的树，边权和不一定全局最小。
    
- 最小生成树是全局连通的最小代价，不关心某个点出发的距离。
    

---

## 二、朴素 Prim 算法 —— 加点法（像 Dijkstra 的孪生兄弟）

### 2.1 故事引入：城市联盟

你是一个城市规划师，要从零开始建一个城市联盟。  
一开始，只有一个城市（随便选）加入了联盟。  
每次，你找一个**离联盟最近**（即到联盟内某城市有直接公路且距离最短）的孤立城市，把它拉进联盟，并修那条路。  
重复 n-1 次，所有城市都进联盟，路也修好了。

**这就是 Prim 算法的贪心过程**。

---

### 2.2 核心数据结构与距离定义

```cpp

int g[N][N];   // 邻接矩阵，稠密图标配
int dist[N];   // 每个点到【当前生成树集合】的最短距离
bool st[N];    // 标记点是否已在树中

```
**关键区别（与 Dijkstra）**：

- Dijkstra 的 `dist[j]` 是**从起点到 j 的最短路径长度**，更新时用 `dist[t] + g[t][j]`。
    
- Prim 的 `dist[j]` 是**从 j 到当前集合内所有点的最小边权**，更新时直接用 `g[t][j]`。
    

---

### 2.3 算法模板（朴素版，稠密图专用）

```cpp

int prim() {
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;          // 可以从任意点开始，通常选1
    int res = 0;          // 最小生成树边权和
    
    for (int i = 0; i < n; i++) {      // 循环 n 次，每次加一个点
        int t = -1;
        // 找集合外距离最近的点
        for (int j = 1; j <= n; j++)
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        
        if (i && dist[t] == INF) return INF;   // 不连通，无生成树
        if (i) res += dist[t];                  // 第一条边（i=0）只是初始化起点，不加权
        
        st[t] = true;                         // 加入集合
        
        // 用 t 更新其他点到集合的距离
        for (int j = 1; j <= n; j++)
            if (!st[j] && dist[j] > g[t][j])
                dist[j] = g[t][j];            // 注意：不是加法！
    }
    return res;
}
```
🔴 **易错点**：

- **第一轮迭代**：`i=0` 时选的是起点，此时 `dist[t] = 0`，不能把 0 累加到答案！
    
- **距离更新**：千万不要写成 `dist[t] + g[t][j]`，那是 Dijkstra！
    
- **不连通判断**：当 `i>0` 且选出的 `t` 距离为 INF，说明剩余点与当前集合不连通 → 无法构成生成树。
    

🟢 **记忆口诀**：  
“**Prim 加点贪心选，点到集合最短边；更新直接` g[t][j]`，累加从第二遍。**”

---

### 2.4 时间复杂度与适用场景

- 朴素 Prim：**O(n²)**，适合**稠密图**（n ≤ 5000）。
    
- 堆优化 Prim：**O(m log n)**，适合稀疏图，但代码复杂，**竞赛中一般直接用 Kruskal 替代**。
    

---

## 三、Kruskal 算法 —— 加边法（并查集经典应用）

### 3.1 故事引入：边按价格排序，便宜的先修

把所有备选公路按造价从小到大排序。  
然后从最便宜的公路开始，一条一条看：  
如果这条公路连接的两个城市**目前还不连通**，就修它；  
如果已经连通，就跳过（否则会成环）。  
直到所有城市都连通（修了 n-1 条路）。

**这就是 Kruskal 算法**：**全局贪心选最小边，用并查集判连通**。

---

### 3.2 数据结构

```cpp

struct Edge {
    int a, b, w;
    bool operator< (const Edge &t) const {   // 按权重排序
        return w < t.w;
    }
} edges[M];
```
**并查集**：`p[N]`，`find(x)`。

---

### 3.3 算法模板

```cpp

int kruskal() {
    sort(edges, edges + m);        // 1. 所有边从小到大排序
    for (int i = 1; i <= n; i++) p[i] = i;   // 并查集初始化
    
    int res = 0, cnt = 0;          // res: 边权和, cnt: 已选边数
    for (int i = 0; i < m; i++) {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
        a = find(a), b = find(b);
        if (a != b) {             // 2. 若不连通，则加入生成树
            p[a] = b;
            res += w;
            cnt++;
        }
    }
    if (cnt < n - 1) return INF;  // 3. 选边数不足，不连通
    return res;
}
```
🔴 **易错点**：

- **并查集合并**：一定要先 `find` 找到根节点，再合并，不能直接用 `p[a] = b`。
    
- **重边不影响**：Kruskal 会自动选择最小的那条（排序后先遇到的就是最小的）。
    
- **自环**：自环边自己连自己，`find(a) == find(a)`，直接被跳过。
    

🟢 **记忆口诀**：  
“**Kruskal 选边贪，排序边权从小到大；并查集判连通，n-1 条边生成树。**”

---

### 3.4 时间复杂度与适用场景

- 排序 O(m log m)，并查集 O(m α(n)) ≈ O(m)
    
- **总 O(m log m)**，适合**稀疏图**（m 与 n 同阶）。
    
- 代码极其简洁，**工程竞赛通用**。
    

---

## 四、Prim vs Kruskal —— 怎么选？

|算法|核心思想|时间复杂度|适用场景|代码复杂度|
|---|---|---|---|---|
|朴素 Prim|加点，每次选集合外最近点|O(n²)|稠密图（n ≤ 5000）|中等|
|堆优化 Prim|加点，堆优化|O(m log n)|稀疏图（理论）|高|
|Kruskal|加边，排序+并查集|O(m log m)|**通用，尤其稀疏图**|**低**|

**结论**：

- **稠密图（m ≈ n²）** → 朴素 Prim
    
- **稀疏图（m ≈ n）** → Kruskal（简单高效）
    
- 一般情况下，**直接 Kruskal 最省心**，除非 n 很大且图很密（如 n=5000, m=10⁷，排序可能较慢，但 Kruskal 仍可接受）。
    

---

# 第二部分 · 二分图 —— 特殊的图，两种颜色

## 一、什么是二分图？

**定义**：顶点集可分割为两个互不相交的子集 U、V，图中每条边都连接 U 中的一个点和 V 中的一个点。  
**等价条件**：**图中不含奇数环**（环的边数为奇数）。

**生活类比**：

- 男生女生恋爱图——边只存在于男生和女生之间，不存在男-男或女-女边。
    
- 课程安排冲突图——每个学生选的课，课与课不能同时上，可建模为二分图。
    

---

## 二、染色法 —— 判定二分图

### 2.1 核心思想

用 DFS/BFS 遍历图，给每个顶点染上颜色（1 或 2）。  
如果遇到相邻顶点颜色相同，说明存在奇数环 → 不是二分图。

**证明**：

- 无奇数环 → 可以二染色。
    
- 有奇数环 → 必然出现染色矛盾。
    

### 2.2 算法模板（DFS 版本）

```cpp

const int N = 100010, M = 200010;  // 无向图，边数两倍
int h[N], e[M], ne[M], idx;
int color[N];   // 0: 未染色, 1: 颜色1, 2: 颜色2
bool dfs(int u, int c) {
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i]) {
        int j = e[i];
        if (!color[j]) {
            if (!dfs(j, 3 - c)) return false;  // 3-c: 1变2, 2变1
        } else if (color[j] == c) return false; // 冲突
    }
    return true;
}
bool check() {
    memset(color, 0, sizeof color);
    for (int i = 1; i <= n; i++)
        if (!color[i])
            if (!dfs(i, 1)) return false;
    return true;
}
```
🔴 **易错点**：

- **无向图存储**：一定要 `add(a,b); add(b,a);`，数组 M 开 2 倍！
    
- **颜色转换**：用 `3 - c` 简洁切换 1↔2。
    
- **遍历所有连通块**：图可能不连通，要对每个未染色点启动 DFS。
    

🟢 **记忆口诀**：  
“**二分图判定用染色，DFS 交替涂；遇到同色即矛盾，无奇数环是二分。**”

---

## 三、匈牙利算法 —— 求二分图最大匹配

### 3.1 故事引入：月老牵线

你是月老，左边有一群男生，右边有一群女生，连线代表彼此有好感。  
你要**撮合最多的情侣**，且一人只能匹配一人。

**策略**：

1. 按顺序给每个男生找对象。
    
2. 如果喜欢的女生单身，直接匹配。
    
3. 如果女生已有对象，尝试让她的现男友**换个女朋友**（递归给那个男生重新找）。
    
4. 如果换成功，则当前男生上位；否则放弃。
    

**这就是匈牙利算法的递归回溯过程**。

---

### 3.2 核心数据结构

```cpp

int n1, n2, m;       // 左边点数，右边点数，边数
int h[N], e[M], ne[M], idx;   // 邻接表，只需存左到右的边
int match[N];        // match[v] = u 表示右边点 v 当前匹配的左边点 u，0 表示未匹配
bool st[N];          // 每次尝试匹配时，标记右边点是否被访问过（防止死循环）
```
---

### 3.3 算法模板

```cpp

bool find(int u) {
    for (int i = h[u]; i != -1; i = ne[i]) {
        int v = e[i];
        if (!st[v]) {
            st[v] = true;
            if (match[v] == 0 || find(match[v])) {   // 女生单身 或 现男友能换人
                match[v] = u;
                return true;
            }
        }
    }
    return false;
}
int hungarian() {
    int res = 0;
    for (int i = 1; i <= n1; i++) {
        memset(st, 0, sizeof st);   // 每次重置访问标记
        if (find(i)) res++;
    }
    return res;
}
```
🔴 **易错点**：

- **每次尝试匹配前清空 st**：`st` 只用于一轮匹配中防止重复访问同一个女生。
    
- **递归终止**：`match[v] == 0` 是基础条件，然后尝试让 `match[v]` 换人。
    
- **单向边存储**：只需存左到右的边，不需要存反向边。
    
- **数组范围**：`match` 大小是 `n2+1`，`st` 也是 `n2+1`。
    

🟢 **记忆口诀**：  
“**匈牙利，找对象；女生单身直接上，名花有主劝退让；递归回溯试换人，访问标记每轮清。**”

---

### 3.4 时间复杂度

- 最坏 O(n1 × m)（每个男生可能遍历所有边并递归）。
    
- 实际运行**远小于理论最坏**，常接近 O(m)。
    

---

# 📊 本章知识小结

|知识点|核心思想|零基础理解锚点|易错点|难度|
|---|---|---|---|---|
|**最小生成树概念**|连通所有点，边权和最小|修路总长最短|不是最短路树|★★|
|**朴素 Prim**|加点，贪心选集合外最近点|城市联盟|更新用 `g[t][j]`，不是加法|★★★★|
|**Kruskal**|加边，排序+并查集|便宜的先修|并查集合并前 `find`|★★★|
|**染色法判二分图**|DFS 交替染色|相邻异色|无向图存双向边|★★★|
|**匈牙利算法**|递归匹配，尝试换人|月老牵线|每轮清空 st，match 存右边|★★★★★|

---

# 🎓 写在最后：图论三章，到此收关

从**深度优先搜索**到**最短路算法**，再到**最小生成树**与**二分图匹配**，你已经完整走过了图论的基础版图。  
此刻的你：

- 能用 DFS/BFS 解决一切遍历问题；
    
- 能根据数据范围秒选最短路算法；
    
- 能手撕最小生成树；
    
- 能判定二分图并求出最大匹配。
    

**这些能力，足以应付 90% 的算法竞赛图论题**。

**给你的硬核建议**：

1. **Prim** 与 **Dijkstra** 对着写三遍，直到闭眼不出错。
    
2. **Kruskal** 与 **并查集** 绑定，写 5 遍，边写边念“找根、合并、判连通”。
    
3. **染色法**：故意画一个奇数环的图，手动模拟 DFS 看看冲突怎么发生。
    
4. **匈牙利算法**：找几个简单的二分图，在纸上模拟递归回溯过程，理解“换人”逻辑。
    

**当你把这些坑都踩过一遍，你会发现——图论没有想象中那么可怕，它只是用点与边，描绘了这个世界的各种关系。**
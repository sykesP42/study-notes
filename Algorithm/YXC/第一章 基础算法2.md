# 第一章 基础算法（二）—— 从“背模板”到“造轮子”

**献给所有被大数溢出和区间操作折磨过的初学者**

> 🔴 **阅读提示**：本章继续**零基础友好型**写作风格——每一个“显然”都会被拆解成“为什么”；每一个“易错点”都会告诉你**错在哪里、长什么样、怎么治**。  
> 🎯 **目标**：学完本章，你不仅能默写高精度四则运算和前缀和差分模板，还能**像搭积木一样灵活组装它们**，遇到变形题也能从容应对。

---

# 📌 开篇：为什么我们需要自己造轮子？

很多同学第一次接触高精度时都会问：**“Python不是自带大整数吗？C++为什么不学Java？”**

**答**：因为你要学的不是“怎么用”，而是 **“计算机底层是怎么算的”**。  
高精度运算是**唯一让你亲手模拟CPU整数运算单元**的机会。当你亲手用数组实现过加法进位、减法借位，你对计算机的认知会从“黑盒”变成“半透明”。

**前缀和与差分**则是**空间换时间**思想的极致体现——预处理花一点时间，后续查询快如闪电。这是你从“暴力求解”走向“优雅算法”的第一课。

---

# 第一部分 · 高精度运算 —— 用数组装下整个宇宙

## 一、为什么需要高精度？

C++ 中内置的整数类型（`int`、`long long`）有范围限制：

- `int`：约 ±21亿（10位数）
    
- `long long`：约 ±9.22×10¹⁸（19位数）
    

**如果我要算 2¹⁰⁰⁰ 呢？**  
1000位数字，任何内置类型都装不下。  
**解决方案**：用**数组**的每一位存一个十进制数字，自己模拟加减乘除。

🟢 **适用场景**：

- 计算阶乘（如 1000!）
    
- 大数斐波那契
    
- 密码学中的大数运算
    
- **笔试常见，面试较少**（面试更爱考思想，不考造轮子）
    

---

## 二、统一的存储原则 —— “个位在前，高位在后”

这是高精度**最重要、最反直觉**的一条规则。  
**为什么不能像平常一样把高位存在数组[0]？**

### 📌 根本原因：**进位方向**

我们做加法时，进位是**从低位向高位传递**：


```text

  123
+  89
-----
  212   ← 先算个位3+9=12，写2进1；再算十位2+8+1=11，写1进1……
```
如果`数组[0]`存**最高位**，那么进位发生时，我们需要**在数组头部插入新数字**——这需要移动所有元素，O(n) 时间。  
但如果`数组[0]`存**最低位**，进位只需要**在数组末尾追加**，O(1) 时间。

🔴 **记忆锚点**：“**低位在左，进位向右**”——数组下标从小到大对应位数从低到高，进位时直接`push_back`。

**存储示例**：

```text

数字：1234
数组下标：0   1   2   3
内容：   4   3   2   1   ← 个位在[0]，十位在[1]，百位在[2]，千位在[3]
```
**所有高精度运算（加、减、乘、除）强制统一这种存储格式**，因为一道题可能同时涉及多种运算，中间结果需要无缝衔接。

---

## 三、高精度加法 —— 最温和的入门

### 3.1 核心思想：完全模拟竖式计算

你小学怎么列竖式，程序就怎么算。

```text

  3 2 1     ← 数字 123（低位在右，但存储时低位在左）
+   8 9     ← 数字 98
--------
  4 1 2     ← 结果 212
```
**逐位运算**：

- 个位：3 + 9 = 12 → 当前位=2，进位=1
    
- 十位：2 + 8 + 进位1 = 11 → 当前位=1，进位=1
    
- 百位：1 + 0 + 进位1 = 2 → 当前位=2，进位=0
    

### 3.2 代码实现（逐行注释版）

```cpp

#include <iostream>
#include <vector>
#include <string>
using namespace std;
// 高精度加法模板
vector<int> add(vector<int> &A, vector<int> &B) {
    // 【守则1】保证 A 是较长的那个（简化代码）
    if (A.size() < B.size()) return add(B, A);
    
    vector<int> C;
    int t = 0;  // 进位，初始为0
    
    for (int i = 0; i < A.size(); i++) {
        t += A[i];              // 加上A的当前位
        if (i < B.size()) t += B[i]; // 如果B还有位，也加上
        C.push_back(t % 10);    // 当前位结果
        t /= 10;                // 新的进位（向高位）
    }
    
    // 【守则2】最高位可能还有进位
    if (t) C.push_back(t);
    
    return C;
}
int main() {
    string a, b;
    cin >> a >> b;
    
    vector<int> A, B;
    // 逆序存储：个位在前
    for (int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0');
    for (int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0');
    
    auto C = add(A, B);
    
    // 逆序输出：高位在前
    for (int i = C.size() - 1; i >= 0; i--) cout << C[i];
    
    return 0;
}
```
### 3.3 易错点 & 优化技巧

🔴 **易错点1**：**忘记处理最高位的进位**  
症状：`99 + 1 = 00`（缺少百位的1）  
防治：循环结束后一定要检查`t`是否为1。

🔴 **易错点2**：**字符转数字忘记减'0'**  
症状：得到ASCII码值，结果变成几百  
防治：`a[i] - '0'` 是肌肉记忆。

🟢 **优化技巧1**：**压位存储**  
每个数组元素存0~9999（4位十进制），效率提升4倍。**进阶使用，初学不必纠结**。

🟢 **优化技巧2**：**引用传参**  
函数参数用 `vector<int> &A` 避免拷贝大数组。

---

## 四、高精度减法 —— 借位的艺术

### 4.1 核心思想：还是列竖式

```text

  1 2 3
-   8 9
-------
    3 4
```
**借位逻辑**：

- 个位：3 - 9 不够，向十位借1 → 13 - 9 = 4，标记借位
    
- 十位：2 - 8 - 借位1 = -7 → 不够，向百位借1 → 12 - 8 - 1 = 3，标记借位
    
- 百位：1 - 0 - 借位1 = 0
    

### 4.2 首要问题：谁减谁？

**模板规定**：被减数必须 ≥ 减数，否则先输出负号，再计算 `(B - A)`。

因此需要写一个**比较函数** `cmp`：

```cpp

// 判断是否 A ≥ B
bool cmp(vector<int> &A, vector<int> &B) {
    if (A.size() != B.size()) return A.size() > B.size();
    for (int i = A.size() - 1; i >= 0; i--)  // 从高位开始比
        if (A[i] != B[i]) return A[i] > B[i];
    return true;  // 相等
}
```
### 4.3 统一借位处理公式 —— (t + 10) % 10

这是减法模板中最**优雅**的一行代码。

设 `t = A[i] - B[i] - borrow`（借位初始0，之后为0或1）。

- 如果 `t ≥ 0`：当前位 = `t`，新借位 = 0
    
- 如果 `t < 0`：当前位 = `t + 10`，新借位 = 1
    

**合并**：

```cpp

int t = A[i] - borrow;
if (i < B.size()) t -= B[i];
C.push_back((t + 10) % 10);   // 🔥 神之一行
borrow = (t < 0) ? 1 : 0;
```
**为什么能合并**？

- 当 `t ≥ 0`：`(t+10)%10 = t%10`（因为 t<10），结果就是 t
    
- 当 `t < 0`：`(t+10)%10 = t+10`（因为 t ≥ -9），结果正确
    

🔴 **记忆口诀**：“**减法是加法的逆，借位补十再取余**”。

### 4.4 前导零处理 —— 不能让结果变成“00123”

减法很容易产生高位0：

```text

  100
-  99
-----
    1   ← 实际存储为 [1,0,0]？不对，应该是 [1]（只有个位）
```
**必须去掉高位多余的0，但要保留一个0**（当结果为0时）。

```cpp

while (C.size() > 1 && C.back() == 0) C.pop_back();
```
### 4.5 完整代码模板

```cpp

vector<int> sub(vector<int> &A, vector<int> &B) {
    // 调用前已确保 A ≥ B
    vector<int> C;
    int borrow = 0;
    for (int i = 0; i < A.size(); i++) {
        int t = A[i] - borrow;
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        borrow = (t < 0) ? 1 : 0;
    }
    // 去前导零
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
// 主函数中：
if (cmp(A, B)) {
    auto C = sub(A, B);
    // 输出C
} else {
    auto C = sub(B, A);
    cout << "-";
    // 输出C
}
```
---

## 五、高精度乘法（大数 × 整数）

### 5.1 核心思想：逐位乘，累加进位

这是高精度里**最像加法**的运算。  
我们只讨论 **大整数 × 普通整数**（int范围），不讨论 **大整数 × 大整数**（那是进阶内容）。

**竖式**：

```text

      1 2 3
×        1 2
-----------
      2 4 6   ← 123×2
    1 2 3     ← 123×1（左移一位）
-----------
    1 4 7 6
```
但我们的模板采用**更简单的逻辑**：  
把乘数 `b` 看成一个整体，直接乘每一位，然后处理进位。

**公式**：  
当前位 = `(A[i] * b + carry) % 10`  
新进位 = `(A[i] * b + carry) / 10`

### 5.2 进位不再只是0或1

加法进位最大是1，但乘法进位**可能很大**（例如 9×9+进位=81+?）。  
所以进位变量 `t` 需要全程参与，循环结束后可能还有多位进位。

**循环条件**：`i < A.size() || t`  
即使A遍历完，进位没处理完就要继续。

### 5.3 代码模板（逐行注释）

```cpp

vector<int> mul(vector<int> &A, int b) {
    vector<int> C;
    int t = 0;  // 进位，初始0
    for (int i = 0; i < A.size() || t; i++) {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }
    // 去前导零（乘0的情况）
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```
🔴 **易错点**：

- 忘记处理乘0的情况（结果为0，但存储是[0]）
    
- 循环条件写成 `i < A.size()` 导致进位漏掉
    

🟢 **记忆技巧**：  
乘法模板 = 加法模板 + 把 `t += A[i]` 改成 `t += A[i] * b`，**一模一样**。

---

## 六、高精度除法（大数 ÷ 整数）

### 6.1 核心思想：从高位开始，余数滚雪球

这是**唯一**与其他三种运算方向相反的操作。  
加减乘都是从低位（个位）开始，**除法必须从高位（最大位）开始**。

**模拟手算除法**：

```text

     1 0 2   ← 商
   _______
3 ) 3 0 6
    -3
    --
      0 0
        -0
        --
         0 6
          -6
          ---
           0
```
**过程**：

1. 取第一位3，除以3，商1，余0
    
2. 余数0×10 + 下一位0 = 0，除以3，商0，余0
    
3. 余数0×10 + 下一位6 = 6，除以3，商2，余0
    

**余数的累积公式**：`r = r * 10 + A[i]`（从最高位开始取数字）

### 6.2 存储矛盾与解决方案

**矛盾**：

- 除法计算需要**从高位到低位**遍历数组
    
- 但我们统一存储是**低位在前**（数组[0]是个位）
    

**解决方案**：

1. 先**正序计算**（从数组末尾开始遍历）
    
2. 得到的商数组是**高位在前**的
    
3. **反转**商数组，使其符合“低位在前”的统一格式
    
4. **去除前导零**
    

### 6.3 代码模板

```cpp

// 高精度除法：A / b，商存入C，余数存入r（引用返回）
vector<int> div(vector<int> &A, int b, int &r) {
    vector<int> C;
    r = 0;
    // 从最高位（数组末尾）开始处理
    for (int i = A.size() - 1; i >= 0; i--) {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    // 此时C是高位在前（例如 102 存储为 [1,0,2]）
    reverse(C.begin(), C.end());  // 统一为低位在前 [2,0,1]
    
    // 去前导零
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```
🔴 **易错点三连**：

1. **忘记 `reverse`** → 输出结果完全颠倒
    
2. **忘记去前导零** → 例如 100/3 = 33，可能输出 033
    
3. **混淆除数和模数** → `r / b` 是商，`r % b` 是新余数，别写成 `r % 10`
    

🟢 **记忆锚点**：  
“**除法高位起，余数叠叠乐；商要倒着存，前导零要切**。”

---

## 七、高精度小结 —— 统一存储是灵魂

|运算|遍历方向|核心操作|特殊处理|难度|
|---|---|---|---|---|
|加法|低位→高位|t = A[i]+B[i]+carry|最高位进位|★★|
|减法|低位→高位|t = A[i]-B[i]-borrow|借位统一公式、前导零|★★★|
|乘法|低位→高位|t += A[i]*b|进位可能>1|★★|
|除法|高位→低位|r = r*10 + A[i]|反转、前导零|★★★★|

**练习建议**：

- 每个模板**至少手写3遍**，第一遍看模板写，第二遍凭记忆写，第三遍闭眼写
    
- 重点不是背代码，是**理解为什么低位存[0]**、**为什么除法要反转**
    

---

# 第二部分 · 前缀与差分 —— 区间问题的“瑞士军刀”

## 一、前缀和 —— 快速求区间和

### 1.1 为什么下标必须从1开始？

这是一个**约定优于配置**的经典案例。

如果数组下标从0开始：

- 前i个数的和需要额外定义 `s[-1] = 0`，C++不允许负索引
    
- 区间 `[l, r]` 的和公式变成 `s[r] - s[l-1]`，当 `l=0` 时 `l-1=-1` 越界
    

✅ **解决方案**：  
输入时**数组从下标1开始存**，并定义 `s[0] = 0`。

**记忆口诀**：“**前缀和，下标1；s0零，不越界**。”

### 1.2 一维前缀和 —— 预处理 O(n)，查询 O(1)

**定义**：  
$$
s[i] = a[1] + a[2] + ... + a[i]  
$$
**递推**：
$$
s[i] = s[i-1] + a[i]
$$
**区间和**：  
$$
a[l] + ... + a[r] = s[r] - s[l-1]
$$
**代码模板**：

```cpp

const int N = 100010;
int a[N], s[N];
// 预处理
for (int i = 1; i <= n; i++) {
    cin >> a[i];
    s[i] = s[i-1] + a[i];
}
// 查询
while (m--) {
    int l, r;
    cin >> l >> r;
    cout << s[r] - s[l-1] << endl;
}
```
🔴 **易错点**：

- 混淆 `a[i]` 和 `s[i]`
    
- 查询时忘记减1（写成 `s[r] - s[l]`）
    

🟢 **几何理解**：  
`s[r]` 是面积1~r，`s[l-1]` 是面积1~l-1，相减得面积 l~r。

---

### 1.3 二维前缀和 —— 容斥原理

**定义**：  
`s[i][j]` 表示从 `(1,1)` 到 `(i,j)` 这个子矩阵的所有元素之和。

**递推公式**：

$$
s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j]
$$


**为什么减一次**？因为 `s[i-1][j]` 和 `s[i][j-1]` 都包含了 `s[i-1][j-1]`，加重复了。

**子矩阵和**（左上角 (x1,y1)，右下角 (x2,y2)）：


$$
sum = s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1]
$$
**画图理解**：  
用大矩形减去两个小矩形，再把多减的小小矩形加回来。

🔴 **记忆口诀**：“**二维前缀和，加左加上，减左上；子矩阵和，大减小，加回左上**。”

**代码模板**：


```cpp

// 预处理
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++) {
        cin >> a[i][j];
        s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j];
    }
// 查询
while (q--) {
    int x1, y1, x2, y2;
    cin >> x1 >> y1 >> x2 >> y2;
    cout << s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1] << endl;
}
```
---

## 二、差分 —— 前缀和的逆运算

### 2.1 差分的定义

如果 `a` 数组是 `b` 数组的**前缀和**，那么 `b` 就是 `a` 的**差分**。

即：

$$
a[i] = b[1] + b[2] + ... + b[i]
$$
那么显然：


$$b[1] = a[1]$$
$$b[i] = a[i] - a[i-1]   (i ≥ 2)$$

**差分有什么用**？  
**区间修改**：给 `a[l..r]` 每个数加上 `c`，如果暴力做需要 O(n)，但用差分可以 O(1) 完成。

**原理**：  
对差分数组 `b` 执行：

$$b[l] += c$$
$$b[r+1] -= c$$

然后再对 `b` 求前缀和，得到的 `a` 数组就在 `[l,r]` 区间加上了 `c`。

**为什么**？  
因为前缀和的性质：`b[l]` 加 `c` 会影响 `a[l]` 及之后所有元素，`b[r+1]` 减 `c` 会抵消 `r+1` 及之后的影响，最终只有 `[l,r]` 区间加 `c`。

### 2.2 一维差分的初始化技巧

**问题**：如何根据初始的 `a` 数组构造差分数组 `b`？

**方法1**：直接套公式


```cpp

b[1] = a[1];
for (int i = 2; i <= n; i++) b[i] = a[i] - a[i-1];
```
**方法2**（更统一）：**插入法**  
将初始数组视为全0，然后进行 n 次区间插入操作：  
第 i 次在区间 `[i, i]` 加上 `a[i]`。

```cpp

void insert(int l, int r, int c) {
    b[l] += c;
    b[r+1] -= c;
}
// 初始化
for (int i = 1; i <= n; i++) {
    cin >> a[i];
    insert(i, i, a[i]);
}
```
这种方法的好处是**无需单独写构造公式**，和后面的区间修改操作**完全统一**。

### 2.3 完整一维差分模板

```cpp

int a[N], b[N];
void insert(int l, int r, int c) {
    b[l] += c;
    b[r+1] -= c;
}
int main() {
    int n, m;
    cin >> n >> m;
    
    // 初始化差分数组
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        insert(i, i, a[i]);   // 等价于 b[i] += a[i]; b[i+1] -= a[i];
    }
    
    // 执行区间加操作
    while (m--) {
        int l, r, c;
        cin >> l >> r >> c;
        insert(l, r, c);
    }
    
    // 前缀和还原
    for (int i = 1; i <= n; i++) {
        b[i] += b[i-1];       // 此时b[i]就是最终的a[i]
        cout << b[i] << ' ';
    }
    return 0;
}
```
---

### 2.4 二维差分 —— 四角标记法

**核心操作**：给子矩阵 `(x1,y1) ~ (x2,y2)` 加 `c`。

**在差分矩阵 `b` 上的操作**：

```text

b[x1][y1]   += c
b[x1][y2+1] -= c
b[x2+1][y1] -= c
b[x2+1][y2+1] += c
```
**为什么**？  
这是一个二维的容斥。可以理解为：先给整个右下区域加c，再减去两个多余的区域，再加回多减的区域。

**初始化**：同样使用插入法，每个 `a[i][j]` 视为一个1×1的子矩阵插入。

**前缀和还原**：对 `b` 求二维前缀和，得到最终的 `a`。

```cpp

int b[N][N];
void insert(int x1, int y1, int x2, int y2, int c) {
    b[x1][y1] += c;
    b[x1][y2+1] -= c;
    b[x2+1][y1] -= c;
    b[x2+1][y2+1] += c;
}
// 初始化
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++) {
        cin >> a[i][j];
        insert(i, j, i, j, a[i][j]);
    }
// 区间修改
while (q--) {
    int x1, y1, x2, y2, c;
    cin >> x1 >> y1 >> x2 >> y2 >> c;
    insert(x1, y1, x2, y2, c);
}
// 前缀和还原
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++) {
        b[i][j] += b[i-1][j] + b[i][j-1] - b[i-1][j-1];  // 二维前缀和公式
        cout << b[i][j] << ' ';
    }
```
🔴 **易错点**：

- 二维差分标记时**下标+1可能越界**，数组要开大（`N+10`）
    
- 还原时**忘记二维前缀和公式**，直接用 `b[i][j]` 输出
    
- 插入函数的四个点**符号记反**（加、减、减、加）
    

🟢 **记忆口诀**：  
“**二维差分四角标，加左上加右减，左下减右下加，对称记忆不会差**。”

---

## 三、前缀和与差分的对称美

|操作|前缀和|差分|
|---|---|---|
|定义|`s[i] = s[i-1] + a[i]`|`b[i] = a[i] - a[i-1]`|
|作用|快速求区间和|快速区间加|
|时间复杂度|预处理 O(n)，查询 O(1)|修改 O(1)，还原 O(n)|
|关系|**互逆**：对差分求前缀和得原数组|对前缀和求差分也得原数组|

**它们是一对“神仙组合”**：

- 当题目**查询多、修改少** → 前缀和
    
- 当题目**修改多、查询少** → 差分
    
- 当题目**边修改边查询** → 线段树/树状数组（后续课程）
    

---

# 📊 本章知识小结 —— 考试前夜必看

|知识点|核心思想|零基础理解锚点|易错点|难度|
|---|---|---|---|---|
|**高精度存储**|个位存[0]|进位要在尾巴加|字符未转数字|★★|
|**高精度加法**|模拟竖式|t = A+B+carry|漏最高位进位|★★|
|**高精度减法**|模拟借位|(t+10)%10|前导零、大小比较|★★★|
|**高精度乘法**|逐位乘|t += A[i]*b|进位循环条件|★★|
|**高精度除法**|高位开始|r = r*10 + A[i]|忘记reverse|★★★★|
|**前缀和**|空间换时间|s[i]=s[i-1]+a[i]|下标从1开始|★★|
|**二维前缀和**|容斥原理|s[i][j] 四项|符号多易错|★★★|
|**差分**|逆运算|b[l]+c, b[r+1]-c|初始化方式|★★★|
|**二维差分**|四角标记|四个点±c|坐标+1越界|★★★★|

---

# 🎓 写在最后：从“造轮子”到“用轮子”

本章你亲手实现了四个高精度运算的“轮子”，也掌握了前缀和差分这对“瑞士军刀”。

**这些模板的价值不在于背下来，而在于**：

1. 你**理解了计算机底层是如何处理数字**的（进位、借位、溢出）
    
2. 你**学会了空间换时间、预处理加速查询**的思想
    
3. 你**能识别出题目中的“区间和”模型**，并快速套用模板
    

**接下来你要做的**：

- 打开OJ，把**高精度加法、减法、乘法、除法**各AC 2-3题
    
- 把**一维前缀和、二维前缀和、一维差分、二维差分**各AC 2-3题
    
- 每道题**故意写错一次**，看看报错现象，加深记忆
    
- 一周后**不看模板，重写一遍**，直到5分钟内无错写出
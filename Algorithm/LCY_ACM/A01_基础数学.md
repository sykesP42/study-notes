## 一、算法入门
### 1. 导引问题
#### 1）例题:整数求和
**例题分析**：
```
计算1到n的正整数和（n≤150,000）。
```
**常规解法**：
- **循环累加**：通过n次循环逐次累加，时间复杂度`O(n)`
- **适用性**：万次循环量级对现代CPU可忽略不计


**优化解法**：
- **高斯公式**：使用`n(n+1)/2`直接求解
- **关键风险点**：
    - **int类型溢出**：当n=50,000时， `n(n+1)` 中间结果可能超过32位int范围（21亿）
    - **解决方案**：
        - 使用`long long`类型扩大存储范围
        - 运算顺序优化：先除后乘（需处理奇偶性）
            - n为偶数：`n/2*(n+1)`
            - n为奇数：`(n+1)/2*n`

**核心考点**：
- **数据类型范围敏感性**是算法实现的基础能力
- **数学公式与编程实现的差异**需特别关注中间结果溢出问题

## 2. 应用案例

### 1）例题：最小公倍数

**问题定义**：计算两正整数的最小公倍数（LCM）。

| 方法   | 实现逻辑                    | 时间复杂度           | 适用场景        |
| ---- | ----------------------- | --------------- | ----------- |
| 暴力枚举 | 从较大数开始逐次验证              | O(n)            | 小数据量（n<1e4） |
| 优化枚举 | 仅验证较大数的倍数               | O(n/k)          | 中等数据量       |
| 公式法  | lcm(a,b) = a*b/gcd(a,b) | O(log min(a,b)) | 通用最优解       |
|      |                         |                 |             |

**关键实现细节**：

- <span style="color: red;">公式法风险</span>：a×ba×b 可能溢出，应优化为 a/gcd(a,b)×ba/gcd(a,b)×b
    **==（先除再乘）==***（最大公约数一定除得尽）*
- gcd证明：基于欧几里得算法，通过余数递推：
    
    - gcd(a,b) = gcd(b, a mod b)
        
    - 终止条件：b=0b=0 时返回a

- *辗转相除法*
![[Pasted image 20260207032043.png]]
**代码实现要点**：

- 循环版gcd：通过临时变量保存余数，避免递归开销
    
- 参数容错：输入参数顺序不影响结果，自动校正

```cpp
int gcd(int big,int small){
	int temp;
	while(small!=0){
		temp = big % small;
		big = small;
		small = temp ;
	}
	return (big);
}
```

---

### 2）例题：n个n相乘个位数

**题目要求**：给定正整数n，计算 nnnn 的个位数。

**暴力解法缺陷**：直接计算 nnnn 会导致数值溢出，因计算机无法存储极大整数。

**优化解法**：

- <span style="color: red;">逐次取模法</span>：每次乘法运算后仅保留个位数，因十位及以上数字不影响最终个位结果
    
- 适用范围：当 n≤1000n≤1000 时可行，时间复杂度 O(n)O(n)
    

**高效解法**：

- <span style="color: red;">循环节原理</span>：个位数字乘方结果存在周期性，循环节长度不超过4（抽屉原理证明）
    
- 数学依据：数字0-9的乘方个位数最多呈现4种不同状态
    

**实现步骤**：

1. 预计算循环节序列
    
2. 通过 nmod  循环节长度nmod循环节长度 确定最终个位数
    

---

### 3）例题：Fibonacci数列除3判断

**问题定义**：给定修改版Fibonacci数列（f0=7,f1=11f0​=7,f1​=11），判断第n项 fnfn​ 能否被3整除。

|关键点|技术细节|
|---|---|
|递归解法缺陷|n ≤ 1e6时会导致栈溢出且效率低下|
|<span style="color: red;">模运算性质应用</span>|(a+b) mod m = [(a mod m) + (b mod m)] mod m|
|<span style="color: red;">循环节发现</span>|余数组合仅有9种可能（0-2×0-2），根据抽屉原理最多8项后必出现重复|
|规律总结|当 n≡2 或 6 (mod 8)n≡2 或 6 (mod 8) 时输出"yes"，其余情况输出"no"|
|算法选择|预计算前8项余数序列后直接查表，时间复杂度 O(1)O(1)|

---

### 4）例题：快速幂运算

快速幂运算用于求解 abab 的最后三位数，即对1000取模的结果。

**暴力解法**：

- 适用于小数据范围，通过循环每次乘法后立即对1000取模，可避免数值溢出
    
- 局限性：当数据范围扩大至一亿时，暴力解法因运算量过大而失效
    

**快速幂运算的核心思想**：

- <span style="color: red;">数学变换</span>：将 abab 转化为 (a2)(b/2)(a2)(b/2)，运算量减少一半
    
- <span style="color: red;">奇偶处理</span>：若指数为奇数，则提取一个底数后转为偶数处理
    

**递归实现**：

- 基线条件：当指数为0时，结果为1
    
- 递归步骤：底数平方，指数减半，若指数为奇数则额外乘一次底数
    

**非递归实现**：

- 循环条件：指数不为零时持续处理
    
- 奇偶判断：若指数为奇数，结果乘当前底数并对1000取模
    
- 指数更新：底数平方后对1000取模，指数减半
    

**注意事项**：

- 实际应用需结合取模运算，防止数值溢出
    
- 代码灵活性：需根据题目要求调整模数，不可直接套用未优化的基础代码
    

**示例流程**（以 212212 为例）：

1. 初始：a=2,n=12a=2,n=12（偶数）→ 转换为 a=4(22),n=6a=4(22),n=6
    
2. 第二次：a=16(42),n=3a=16(42),n=3（奇数）→ 结果乘16，更新 a=256(162),n=1a=256(162),n=1
    
3. 第三次：n=1n=1（奇数）→ 结果乘256，更新 a=65536(2562),n=0a=65536(2562),n=0，循环终止
    
4. 最终结果需对1000取模
    

---

### 5）例题：二分查找

二分查找适用于有序整数序列的查找问题。

**核心步骤**：

1. 确定中间位置：通过首尾下标计算中间下标
    
2. 比较中间值：若目标值等于中间值则直接返回
    
3. 调整搜索范围：
    
    - 目标值大于中间值时，将搜索范围缩小至右半部分
        
    - 目标值小于中间值时，将搜索范围缩小至左半部分
        
4. <span style="color: red;">终止条件</span>：当左下标超过右下标时判定查找失败
    

**代码实现分为两种形式**：

- **非递归实现**：
    
    - 通过循环控制搜索范围
        
    - 关键条件：`left <= right` 保证有效搜索区间
        
    - 时间复杂度：O(log⁡2n)O(log2​n)
        
- **递归实现**：
    
    - 基线条件：左下标超过右下标
        
    - 递归逻辑：根据比较结果选择左/右子区间继续查找
        

**时间复杂度分析**：

- 二分查找的对数级复杂度使其在处理大规模数据时优势显著
    
- 对于100万量级数据，最多仅需20次比较即可完成查找
    

---

### 6）例题：二分查找应用

二分查找可扩展应用于连续区间单调函数的求解问题。  
例如求解方程：

8x4+7x3+2x2+3x+6=y8x4+7x3+2x2+3x+6=y

其中y为给定实数，要求x在[0,100]区间内的解，精度需达小数点后四位。

**解题要点**：

- <span style="color: red;">单调性判定</span>：方程左侧在定义域内严格单调递增
    
- <span style="color: red;">二分策略</span>：
    
    1. 取中点值代入计算
        
    2. 比较结果与y的大小关系，调整搜索区间
        
- <span style="color: red;">精度控制</span>：设置 10−610−6 级终止阈值确保四位小数精度，循环条件为区间宽度 > 精度要求
    

**代码实现关键**：

- 将方程计算封装为独立函数
    
- 循环终止条件采用区间收敛判定
    
- 最终输出需进行四舍五入处理
    

**扩展应用**：

- 二分法适用于任何满足单调性的连续问题
    
- 实际应用中需注意浮点数精度累积误差的处理
    

---

### 7）例题：函数最小值

给定函数 f(x)f(x) 在区间 [0,100] 内不满足单调性。当 x=0x=0 时，f(x)=0f(x)=0；当 xx 极大时，f(x)>0f(x)>0；当 xx 极小时，f(x)<0f(x)<0。函数图像呈现先下降后上升的趋势。

**求解方法**：

- <span style="color: red;">导数分析</span>：f(x)f(x) 的导数为 42x6+48x5+21x2+10x−y42x6+48x5+21x2+10x−y，导函数单调递增
    
- 极值点判定：由于导函数单调，最小值点对应导数为零的位置，可通过二分法求解导函数的零点
    
- 转换问题：将原问题转化为对导函数进行二分查找，与前一例题解法一致
    

---

### 8）三分查找

三分查找适用于求解凸函数的极值点。

**原理与步骤**：

- 将区间 [L,R] 三等分，计算左分点 M1=L+(R−L)/3M1=L+(R−L)/3 和右分点 M2=R−(R−L)/3M2=R−(R−L)/3
    
- 比较 f(M1)f(M1) 与 f(M2)f(M2)：
    
    - 上凸函数：若 f(M1)>f(M2)f(M1)>f(M2)，则极值点位于 [L,M2]；反之位于 [M1,R]
        
    - 下凸函数：逻辑相反
        
- 每次可排除1/3的搜索区间
    

**与二分查找的区别**：

| 比较维度 | 二分查找    | 三分查找  |
| ---- | ------- | ----- |
| 适用条件 | 单调序列/函数 | 凸函数   |
| 比较对象 | 目标值与中点  | 分点函数值 |
| 缩减比例 | 1/2     | 1/3   |

**实现方式**：

- 递归：基于区间缩减重复调用自身
    
- 非递归：通过循环更新左右边界，直至满足精度要求
    

**应用条件**：

- 核心条件：函数需满足凸性，无需可导或单调（例如分段线性函数仍适用）
    

**例题**：杭电LCY算法入门-例7（HDU2899）可通过三分法求解极值点。

---

## 二、课程内容回顾

**本节重点**：

1. 算法基础：OGG算法与规律证明
    
2. 快速运算与二分法的应用
    
3. 三分法的原理与实现，需掌握凸性判定及区间缩减逻辑
    
4. 递归终止条件：区间长度小于预设精度时终止
    

---

## 三、知识小结

| 知识点                                      | 核心内容                             | 考试重点/易混淆点             | 难度系数  |
| ---------------------------------------- | -------------------------------- | --------------------- | ----- |
| <span style="color: red;">高斯公式应用</span>  | 等差数列求和公式 n(n+1)/2n(n+1)/2 的实现    | int溢出风险（先乘后除导致越界）     | ★★    |
| <span style="color: red;">最小公倍数计算</span> | 通过最大公约数转换：lcm(a,b)=a*b/gcd(a,b)  | 乘法溢出处理（先除后乘技巧）        | ★★★   |
| <span style="color: red;">辗转相除法</span>   | 非递归实现：通过循环和余数运算求gcd              | 参数大小顺序不影响结果（自动校正）     | ★★    |
| <span style="color: red;">数字规律发现</span>  | nnnn 个位数循环规律（抽屉原理应用）             | 循环节长度证明（有限状态必然重复）     | ★★★★  |
| <span style="color: red;">模运算性质</span>   | (a+b)%m = (a%m + b%m)%m          | 递推过程中保持取模的一致性         | ★★★   |
| <span style="color: red;">快速幂算法</span>   | 分治思想：an=(a2)n/2an=(a2)n/2        | 奇数指数处理（提取底数技巧）        | ★★★★  |
| <span style="color: red;">二分查找</span>    | 有序区间的折半搜索（时间复杂度 O(log⁡n)O(logn)） | 终止条件（left>right）和边界更新 | ★★★   |
| <span style="color: red;">二分法扩展</span>   | 单调函数求根（精度控制 10−610−6）            | 区间划分逻辑（函数值比较方向）       | ★★★★  |
| <span style="color: red;">三分查找</span>    | 凸函数极值搜索（比较1/3点函数值）               | 凸性判断（非单调但保持凸性）        | ★★★★★ |
| <span style="color: red;">时间复杂度分析</span> | 二分/三分法的对数级效率                     | 运算量估算（1e6数据约20次迭代）    | ★★    |

---

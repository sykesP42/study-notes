## 一、算法入门
### 1. 导引问题
#### 1）例题:整数求和
**例题分析**：
```
计算1到n的正整数和（n≤150,000）。
```
**常规解法**：
- **循环累加**：通过n次循环逐次累加，时间复杂度`O(n)`
- **适用性**：万次循环量级对现代CPU可忽略不计


**优化解法**：
- **高斯公式**：使用`n(n+1)/2`直接求解
- **关键风险点**：
    - **int类型溢出**：当n=50,000时， `n(n+1)` 中间结果可能超过32位int范围（21亿）
    - **解决方案**：
        - 使用`long long`类型扩大存储范围
        - 运算顺序优化：先除后乘（需处理奇偶性）
            - n为偶数：`n/2*(n+1)`
            - n为奇数：`(n+1)/2*n`

**核心考点**：
- **数据类型范围敏感性**是算法实现的基础能力
- **数学公式与编程实现的差异**需特别关注中间结果溢出问题

## 2. 应用案例

### 1）例题：最小公倍数

**问题定义**：计算两正整数的最小公倍数（LCM）。

| 方法   | 实现逻辑                    | 时间复杂度           | 适用场景        |
| ---- | ----------------------- | --------------- | ----------- |
| 暴力枚举 | 从较大数开始逐次验证              | O(n)            | 小数据量（n<1e4） |
| 优化枚举 | 仅验证较大数的倍数               | O(n/k)          | 中等数据量       |
| 公式法  | lcm(a,b) = a*b/gcd(a,b) | O(log min(a,b)) | 通用最优解       |
|      |                         |                 |             |

**关键实现细节**：

- <span style="color: red;">公式法风险</span>：a×ba×b 可能溢出，应优化为 a/gcd(a,b)×ba/gcd(a,b)×b
    **==（先除再乘）==***（最大公约数一定除得尽）*
- gcd证明：基于欧几里得算法，通过余数递推：
    
    - gcd(a,b) = gcd(b, a mod b)
        
    - 终止条件：b=0b=0 时返回a

- *辗转相除法*
![[Pasted image 20260207032043.png]]
-  基本思想: 两个数的最大公约数等于其中较小的数和两数相除余数的最大公约数
     - 示例推导:
		- 求10和14的GCD → 等价于求10和4(14%10)的GCD
		- 求10和4的GCD → 等价于求4和2(10%4)的GCD
		- 求4和2的GCD → 等价于求2和0(4%2)的GCD
		- 当余数为0时，前一个数2即为GCD
	- 效率优势: 对于大数如(1亿,1亿+1)只需2-3步即可求出GCD为1

**代码实现要点**：

- 循环版gcd：通过临时变量保存余数，避免递归开销
    
- 参数容错：输入参数顺序不影响结果，自动校正

```cpp
int gcd(int big,int small){
	int temp;
	while(small!=0){
		temp = big % small;
		big = small;
		small = temp ;
	}
	return (big);
}
```

---

### 2）例题：n个n相乘个位数

**题目要求**：给定正整数n，计算 `n*n` 的个位数。`n∈[1,1e9]`

**暴力解法缺陷**：直接计算 `n*n`会导致数值溢出，因计算机无法存储极大整数。

**优化解法**：

- <span style="color: red;">逐次取模法</span>：每次乘法运算后**仅保留个位数**，因十位及以上数字不影响最终个位结果
    
- 适用范围：当` n≤1000` 时可行，时间复杂度 `O(n)`
    

**高效解法**：

- <span style="color: red;">循环节原理</span>：个位数字乘方结果存在周期性，循环节长度不超过4（抽屉原理证明）
    
- 数学依据：数字0-9的乘方个位数最多呈现4种不同状态
    
- 循环原理：个位数只能是0-9，根据抽屉原理必然出现循环
- 具体规律：不同数字的循环节长度不同（如2的循环节为4：2→4→8→6→2...）

**实现步骤**：

1. 预计算循环节序列

2. 通过 n mod  循环节长度n mod循环节长度 确定最终个位数
    

---

### 3）例题：Fibonacci数列除3判断

**问题定义**：给定修改版Fibonacci数列（f0=7,f1=11f0​=7,f1​=11），判断第n项 fnfn​ 能否被3整除。
```
定义特殊Fibonacci数列：
        
 F(0)=7 , F(1)=11

 F(n)=F(n−1)+F(n−2)

给定
 n<1,000,000

判断F(n)是否能被3整除
```

| 关键点                                      | 技术细节                                                 |
| ---------------------------------------- | ---------------------------------------------------- |
| 递归解法缺陷                                   | n ≤ 1e6时会导致栈溢出且效率低下                                  |
| <span style="color: red;">模运算性质应用</span> | (a+b) mod m = [(a mod m) + (b mod m)] mod m          |
| <span style="color: red;">循环节发现</span>   | 余数组合仅有9种可能（0-2×0-2），根据抽屉原理最多8项后必出现重复                 |
| 规律总结                                     | 当 n≡2 或 6 (mod 8)n≡2 或 6 (mod 8) 时输出"yes"，其余情况输出"no" |
| 算法选择                                     | 预计算前8项余数序列后直接查表，时间复杂度 O(1)                           |
- 解题思路
    - 直接计算问题：F(n)会指数级增长，无法直接存储
    - 模运算性质：
        ﻿(a+b)%3=(a%3+b%3)%3
    - 改进方法：计算每个    ﻿F(i)%3 的值
        - 初始值：
            ﻿F(0)%3=1
            ﻿F(1)%3=2
        - 递推公式：
            ﻿F(n)%3=(F(n−1)%3+F(n−2)%3)%3
    - 循环节发现：
        - 理论依据：余数组合有限（共9种可能）
        - 实际规律：每8项出现循环（1,2,0,2,2,1,0,1,...）
- 算法实现
    - 预处理：计算前8项的余数模式
    - 查询：根据﻿n%8直接得到结果
- 扩展思考
    - 数学证明：使用抽屉原理证明循环必然存在
    - 时间复杂度：预处理O(1)，查询O(1)

---

### 4）例题：快速幂运算

快速幂运算用于求解 A^B 的最后三位数，即对1000取模的结果。

(1≤A,B≤10000)


**暴力解法**：

- 适用于小数据范围，通过循环每次乘法后立即对1000取模，可避免数值溢出
    
- 局限性：当数据范围扩大至一亿时，暴力解法因运算量过大而失效
    

**快速幂运算的核心思想**：

- <span style="color: red;">数学变换</span>：将 a^b 转化为 (a2)(b/2)(a2)(b/2)，运算量减少一半
    
- <span style="color: red;">奇偶处理</span>：若指数为奇数，则提取一个底数后转为偶数处理

```cpp
int power(int a,int n){
	int ans;
	if(n==0) ans=1;
	else{
		ans=power(a*a,n/2);
		if(n%2==1) ans*=a; // n为奇数处理
	}
	return ans;
}
```

- 执行示例:
    - 计算2^{12}的过程：
        - 初始：a=2, n=12 → 偶数
        - 第一次：a=4, n=6 → 偶数
        - 第二次：a=16, n=3 → 奇数(ans=16)
        - 第三次：a=256, n=1 → 奇数(ans=4096)
        - 第四次：n=0结束

- 数据范围扩展
    - 扩展情况: 当
        ﻿(1≤A,B≤100000000)时
    - 暴力解法局限:
        - 运算量过大无法完成
        - 找规律方法不适用（最后三位数可能很长）
    - 解决方案: 需要引入快速幂运算算法

- 快速幂递归实现:

    - 算法思想:
        - 通过指数减半、底数平方减少运算量
        - 例如：123^{234} = (123^2)^{117}


**递归实现**：

- 基线条件：当指数为0时，结果为1
    
- 递归步骤：底数平方，指数减半，若指数为奇数则额外乘一次底数
    

**非递归实现**：

- 循环条件：指数不为零时持续处理
    
- 奇偶判断：若指数为奇数，结果乘当前底数并对1000取模
    
- 指数更新：底数平方后对1000取模，指数减半
    

**注意事项**：

- 实际应用需结合取模运算，防止数值溢出
    
- 代码灵活性：需根据题目要求调整模数，不可直接套用未优化的基础代码
    

- 改进方法:
	- 每次乘法后立即取模
	- 模数根据题目要求确定
- 代码修改:
	- 在ans = a和a = aa后添加% mod操作
	- 例如：ans = (ans * a) % 1000

---

### 5）例题：二分查找

二分查找适用于**有序**整数序列的查找问题。

**核心步骤**：

1. 确定中间位置：通过首尾下标计算中间下标
    
2. 比较中间值：若目标值等于中间值则直接返回
    
3. 调整搜索范围：
    
    - 目标值大于中间值时，将搜索范围缩小至右半部分
        
    - 目标值小于中间值时，将搜索范围缩小至左半部分
        
4. <span style="color: red;">终止条件</span>：当左下标超过右下标时判定查找失败
    

**代码实现分为两种形式**：

- **非递归实现**：
    
    - 通过循环控制搜索范围
        
    - 关键条件：`left <= right` 保证有效搜索区间
        
    - 时间复杂度：O(log⁡2n)O(log2​n)

![[Pasted image 20260207035306.png]]
- **递归实现**：
    
    - 基线条件：左下标超过右下标
        
    - 递归逻辑：根据比较结果选择左/右子区间继续查找
        
![[Pasted image 20260207035239.png]]
**时间复杂度分析**：

- 二分查找的对数级复杂度使其在处理大规模数据时优势显著
    
- 对于100万量级数据，最多仅需20次比较即可完成查找
    

---

### 6）例题：二分查找应用

二分查找可扩展应用于连续区间单调函数的求解问题。  
例如求解方程：

![[Pasted image 20260207035531.png]]

其中y为给定实数，要求x在[0,100]区间内的解，精度需达小数点后四位。

**解题要点**：

- <span style="color: red;">单调性判定</span>：方程左侧在定义域内严格单调递增
    
- <span style="color: red;">二分策略</span>：
    
    1. 取中点值代入计算
        
    2. 比较结果与y的大小关系，调整搜索区间
        
- <span style="color: red;">精度控制</span>：设置 10−610−6 级终止阈值确保四位小数精度，循环条件为区间宽度 > 精度要求
    
![[Pasted image 20260207035457.png]]
**代码实现关键**：

- 将方程计算封装为独立函数
    
- 循环终止条件采用区间收敛判定
    
- 最终输出需进行四舍五入处理
    

**扩展应用**：

- 二分法适用于任何满足单调性的连续问题
    
- 实际应用中需注意浮点数精度累积误差的处理
    

---

### 7）例题：函数最小值

给定函数 f(x)在区间 [0,100] 内不满足单调性。当 x=0 时，f(x)=0；当 x 极大时，f(x)>0；当 x 极小时，f(x)<0。函数图像呈现先下降后上升的趋势。

**求解方法**：

- <span style="color: red;">导数分析</span>：f(x) 的导数为 42x6+48x5+21x2+10x−y，导函数单调递增
    
- 极值点判定：由于导函数单调，最小值点对应导数为零的位置，可通过二分法求解导函数的零点
    
- 转换问题：将原问题转化为对导函数进行二分查找，与前一例题解法一致
    

---

### 8）三分查找
s
三分查找适用于求解凸函数的极值点。
![[Pasted image 20260207035817.png]]

**原理与步骤**：

-  区间划分：
	- 左三分点：
		 (Left×2+Right)/3
	- 右三分点：
		 (Left+Right×2)/3
- 比较规则：
	- 比较两个三分点处的函数值
	- 上凸函数：若左>右则极值点不在最右侧
	- 下凸函数：若左<右则极值点不在最左侧
- 区间缩减：每次可排除1/3的搜索区间

**与二分查找的区别**：

| 比较维度 | 二分查找    | 三分查找  |
| ---- | ------- | ----- |
| 适用条件 | 单调序列/函数 | 凸函数   |
| 比较对象 | 目标值与中点  | 分点函数值 |
| 缩减比例 | 1/2     | 1/3   |

**实现方式**：

- 递归：基于区间缩减重复调用自身
    
- 非递归：通过循环更新左右边界，直至满足精度要求
    

**应用条件**：

- 核心条件：函数需满足凸性，无需可导或单调（例如分段线性函数仍适用）
    

**例题**：杭电LCY算法入门-例7（HDU2899）可通过三分法求解极值点。

---


| 知识点                                      | 核心内容                             | 考试重点/易混淆点             | 难度系数  |
| ---------------------------------------- | -------------------------------- | --------------------- | ----- |
| <span style="color: red;">高斯公式应用</span>  | 等差数列求和公式 n(n+1)/2n(n+1)/2 的实现    | int溢出风险（先乘后除导致越界）     | ★★    |
| <span style="color: red;">最小公倍数计算</span> | 通过最大公约数转换：lcm(a,b)=a*b/gcd(a,b)  | 乘法溢出处理（先除后乘技巧）        | ★★★   |
| <span style="color: red;">辗转相除法</span>   | 非递归实现：通过循环和余数运算求gcd              | 参数大小顺序不影响结果（自动校正）     | ★★    |
| <span style="color: red;">数字规律发现</span>  | n^n 个位数循环规律（抽屉原理应用）              | 循环节长度证明（有限状态必然重复）     | ★★★★  |
| <span style="color: red;">模运算性质</span>   | (a+b)%m = (a%m + b%m)%m          | 递推过程中保持取模的一致性         | ★★★   |
| <span style="color: red;">快速幂算法</span>   | 分治思想：an=(a2)n/2an=(a2)n/2        | 奇数指数处理（提取底数技巧）        | ★★★★  |
| <span style="color: red;">二分查找</span>    | 有序区间的折半搜索（时间复杂度 O(log⁡n)O(logn)） | 终止条件（left>right）和边界更新 | ★★★   |
| <span style="color: red;">二分法扩展</span>   | 单调函数求根（精度控制 ）                    | 区间划分逻辑（函数值比较方向）       | ★★★★  |
| <span style="color: red;">三分查找</span>    | 凸函数极值搜索（比较1/3点函数值）               | 凸性判断（非单调但保持凸性）        | ★★★★★ |
| <span style="color: red;">时间复杂度分析</span> | 二分/三分法的对数级效率                     | 运算量估算（1e6数据约20次迭代）    | ★★    |

---

# 📘 Lecture 16：迭代器（Iterators）

> 迭代器是 Python 中一种非常重要的抽象，它提供了一种统一的方式来逐个访问容器中的元素，而不需要暴露底层结构。本节课将带你深入理解迭代器的工作原理、如何使用内置迭代器函数，以及迭代器在实际编程中的典型应用。

---

## 一、什么是迭代器？

### 1. 从可迭代对象到迭代器

在 Python 中，很多对象都是**可迭代的**（iterable），例如列表、元组、字符串、字典、range 等。这意味着我们可以用 `for` 循环遍历它们。

迭代器（iterator）是一种特殊的对象，它**记住遍历的位置**，并可以通过 `next()` 函数逐个返回元素。当没有更多元素时，抛出 `StopIteration` 异常。

### 2. 内置函数 `iter` 和 `next`

- `iter(iterable)`：从可迭代对象返回一个迭代器。
    
- `next(iterator)`：返回迭代器的下一个元素，如果耗尽则抛出 `StopIteration`。
    

#### 基本示例


```python

>>> s = [3, 4, 5]
>>> t = iter(s)          # 创建迭代器
>>> next(t)
3
>>> next(t)
4
>>> next(t)
5
>>> next(t)              # 元素耗尽
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```
**要点**：

- 迭代器内部维护一个位置标记，每次调用 `next` 都会移动标记。
    
- 迭代器是**一次性**的，遍历完后就不能再用了。
    
- 可以通过 `list(iterator)` 将剩余元素一次性取出（但取出后迭代器就空了）。
    

```python

>>> t = iter([1, 2, 3, 4])
>>> next(t)          # 1
>>> list(t)          # 剩余元素 [2, 3, 4]
>>> list(t)          # 现在已空，得到 []
```
---

## 二、字典的迭代

### 1. 字典的视图是可迭代的

字典本身是可迭代的（默认迭代键），此外还有三个视图方法：

- `keys()`：返回所有键的视图。
    
- `values()`：返回所有值的视图。
    
- `items()`：返回所有键值对（元组）的视图。
    

这些视图都是可迭代对象，并且它们的迭代顺序是**插入顺序**（Python 3.6+ 中字典保持插入顺序；3.5 及之前是任意的）。

#### 示例

```python

>>> d = {'one': 1, 'two': 2, 'three': 3}
>>> d['zero'] = 0                     # 添加新键值对
>>> list(d.keys())                    # ['one', 'two', 'three', 'zero']
>>> list(d.values())                   # [1, 2, 3, 0]
>>> list(d.items())                    # [('one',1), ('two',2), ('three',3), ('zero',0)]
```
我们也可以直接对字典迭代（即迭代键）：

```python

>>> for k in d:
...     print(k)
... 
one
two
three
zero
```
### 2. 使用迭代器遍历字典视图

可以对视图调用 `iter()` 获得迭代器，然后手动 `next()`。

```python

>>> k_iter = iter(d.keys())
>>> next(k_iter)
'one'
>>> next(k_iter)
'two'
>>> next(k_iter)
'three'
>>> next(k_iter)
'zero'
```
同样，`values()` 和 `items()` 的迭代器也是如此。

### 3. ⚠️ 迭代时修改字典的陷阱

如果在迭代字典的过程中修改字典的大小（增删键），会引发 `RuntimeError`：

```python

>>> d = {'a': 1, 'b': 2}
>>> for k in d:
...     d['c'] = 3      # 错误！
...
RuntimeError: dictionary changed size during iteration
```
但如果只修改已有键的值，是安全的。迭代视图也是如此。

---

## 三、可迭代对象 vs 迭代器

### 1. 概念区分

- **可迭代对象**（iterable）：可以传递给 `iter()` 并返回一个迭代器的对象。例如列表、字符串、range、字典等。
    
- **迭代器**（iterator）：从 `iter()` 返回的对象，可以传递给 `next()`。迭代器本身也是可迭代的（对迭代器调用 `iter()` 返回它自己）。
    

### 2. 重要区别

|特性|可迭代对象|迭代器|
|---|---|---|
|可以被 `for` 循环多次|✅ 每次独立|❌ 只能一次|
|内部状态|无位置状态|有位置状态（消耗型）|
|示例|`[1,2,3]`, `range(5)`|`iter([1,2,3])`, `map(...)`|

#### 示例对比

```python

>>> r = range(3)
>>> list(r)          # [0,1,2]
>>> list(r)          # 再次遍历，还是 [0,1,2]  （range 是可迭代对象，每次生成新迭代器）
>>> t = iter([1,2,3])
>>> list(t)          # [1,2,3]
>>> list(t)          # []   （迭代器已耗尽）
```
### 3. `for` 语句对迭代器的影响

`for` 循环会隐式地调用 `iter()` 获得迭代器，然后不断调用 `next()` 直到耗尽。如果直接对迭代器使用 `for`，那么迭代器会被耗尽。

```python

>>> t = iter([1,2,3])
>>> for x in t:
...     print(x)
... 
1
2
3
>>> next(t)          # StopIteration
```
**建议**：如果只需要遍历一次，使用迭代器更节省内存（尤其是对大型数据）。如果需要多次遍历，保留可迭代对象。

---

## 四、内置迭代器函数

许多 Python 内置函数返回迭代器，实现**惰性计算**（lazy evaluation）：只有在请求元素时才真正计算。这能节省内存和提高效率。

### 1. `map(func, iterable)`

将函数应用到可迭代对象的每个元素上，返回一个迭代器。

```python

>>> m = map(lambda x: x.upper(), ['b', 'c', 'd'])
>>> next(m)
'B'
>>> next(m)
'C'
>>> next(m)
'D'
>>> list(m)          # 已空
[]
```
### 2. `filter(func, iterable)`

返回一个迭代器，包含使 `func` 返回真值的元素。

```python

>>> f = filter(lambda y: y >= 10, [6, 8, 10, 12])
>>> list(f)          # [10, 12]
```
### 3. `zip(*iterables)`

将多个可迭代对象的对应元素打包成元组，返回迭代器。长度以最短的为准。

```python

>>> z = zip([1, 2], [3, 4, 5], [6, 7])
>>> list(z)          # [(1, 3, 6), (2, 4, 7)]
```
### 4. `reversed(sequence)`

返回一个迭代器，按逆序遍历序列（序列必须是有序的，如列表、字符串、元组）。

```python

>>> r = reversed([1, 2, 3, 2, 1])
>>> list(r)          # [1, 2, 3, 2, 1]
```
### 5. 惰性计算的验证

```python

def double(x):
    print(f"计算 double({x})")
    return x * 2
>>> m = map(double, [3, 5, 7])   # 没有立即调用 double
>>> next(m)                       # 此时才计算第一个元素
计算 double(3)
6
>>> next(m)                       # 计算第二个
计算 double(5)
10
```
甚至可以在 `filter` 和 `map` 链式调用时提前终止：

```python

>>> f = filter(lambda y: y >= 10, map(double, range(3, 7)))
>>> next(f)                        # 只计算到满足条件的第一个值（10）
计算 double(3)
计算 double(4)
计算 double(5)
10
>>> next(f)                        # 继续计算直到下一个满足条件
计算 double(6)
12
```
这种惰性特性可以避免不必要的计算，提高性能。

### 6. 查看迭代器内容

要查看迭代器的全部内容，可以用 `list()`、`tuple()` 或 `sorted()` 将其转换为容器。但注意迭代器只能遍历一次，转换后原迭代器就空了。

```python

>>> m = map(lambda x: x*2, [1,2,3])
>>> list(m)          # [2,4,6]
>>> list(m)          # []
```
---

## 五、回文判断的两种实现

回文（palindrome）指正序和逆序相同的序列，如 `[3,1,4,1,3]` 或 `"seveneyes"`（注意 `"seveneyes"` 正反一样吗？`"seveneyes"` 反转是 `"seyeneves"`，不一样，可能是举例错误？但原笔记说 `palindrome('seveneyes') → True`，可能是示例字符串本身是回文？`'seveneyes'` 不是回文，可能是拼写错误，比如 `'seyes'`？我们先不管，按照笔记实现）。

### 方法一：转换为列表比较

```python

def palindrome(lst):
    return lst == list(reversed(lst))
```
缺点：需要创建整个逆序列表，可能浪费内存。

### 方法二：使用 `zip` 逐对比较

```python

def palindrome(seq):
    return all(a == b for a, b in zip(seq, reversed(seq)))
```
- `zip(seq, reversed(seq))` 生成正序和逆序的元素对，直到短的耗尽（正好同时耗尽）。
    
- `all` 检查每一对是否相等。
    

这种方法更通用，不限于列表，任何可迭代对象都可以（只要支持 `reversed` 的序列）。而且它是惰性的，一旦发现不相等就提前终止。

**注意**：`reversed` 要求参数是序列（有确定长度且支持反向迭代），对于一般的可迭代对象不适用。但对于回文检测，通常输入是列表或字符串。

---

## 六、使用迭代器的原因：Blackjack 游戏示例

### 1. 为什么需要迭代器？

- **数据抽象**：使用迭代器可以让代码对数据表示方式做出极少假设。例如，牌组可以是列表、元组、生成器等，只要它是可迭代的，我们就可以用 `iter()` 获得迭代器并用 `next()` 发牌。
    
- **状态封装**：迭代器将序列和当前位置捆绑在一起，可以安全地传递给其他函数，而不用担心丢失位置。
    
- **控制访问**：通过迭代器，我们只能请求下一个元素，无法意外修改整个序列。
    

### 2. Blackjack 游戏模拟

**规则简述**：

- 牌值：数字牌按面值，J/Q/K 为 10 点，A 可计为 1 或 11 点。
    
- 发牌流程：
    
    1. 每个玩家发一张牌。
        
    2. 庄家发一张明牌（面朝上）。
        
    3. 每个玩家发第二张牌。
        
    4. 庄家发一张暗牌（面朝下，称为“whole card”）。
        
- 玩家可以根据策略决定是否继续要牌（hit）。
    
- 庄家固定策略：点数小于 17 时必须要牌。
    

#### 用迭代器模拟牌组

```python

import random
def make_deck():
    """创建一副牌（不考虑多副牌，简化）"""
    ranks = [str(i) for i in range(2, 11)] + ['J', 'Q', 'K', 'A']
    suits = ['♠', '♥', '♦', '♣']
    deck = [rank + suit for rank in ranks for suit in suits]
    random.shuffle(deck)
    return iter(deck)          # 返回牌组的迭代器
```
- 调用 `make_deck()` 获得一个迭代器，每次 `next(deck)` 发一张牌。
    
- 这样发牌过程就是简单的 `next(deck)`，无需手动管理索引。
    

#### 计算手牌点数

```python

def hand_value(hand):
    """计算手牌点数，A 可以灵活计为 1 或 11"""
    total = 0
    aces = 0
    for card in hand:
        rank = card[:-1]       # 去掉花色
        if rank in ['J', 'Q', 'K']:
            total += 10
        elif rank == 'A':
            aces += 1
            total += 11        # 先按 11 计
        else:
            total += int(rank)
    # 如果爆牌且有 A，将 A 从 11 降为 1
    while total > 21 and aces > 0:
        total -= 10
        aces -= 1
    return total
```
#### 玩家回合

```python

def play_player(deck, dealer_up_card, strategy):
    """玩家回合，根据策略决定是否要牌。返回最终手牌和点数"""
    hand = [next(deck), next(deck)]   # 初始两张
    while strategy(hand, dealer_up_card):
        hand.append(next(deck))
    return hand, hand_value(hand)
```
#### 庄家回合

```python

def play_dealer(deck, hand):
    """庄家固定策略：小于 17 继续要牌"""
    while hand_value(hand) < 17:
        hand.append(next(deck))
    return hand, hand_value(hand)
```
#### 策略示例

```python

def basic_strategy(player_hand, dealer_up_card):
    """非常简化的策略：点数 ≤ 11 时一定要牌；否则根据庄家明牌决定"""
    value = hand_value(player_hand)
    if value <= 11:
        return True
    # 庄家明牌点数
    dealer_val = hand_value([dealer_up_card])
    if dealer_val in [2, 3, 4, 5, 6]:
        return False       # 庄家弱，停牌
    else:
        return value < 17  # 否则 17 以下要牌
```
#### 模拟一局

```python

def simulate_blackjack(strategy):
    deck = make_deck()
    # 发牌
    player_card1 = next(deck)
    player_card2 = next(deck)
    dealer_up = next(deck)
    dealer_down = next(deck)
    player_hand = [player_card1, player_card2]
    dealer_hand = [dealer_up, dealer_down]
    # 玩家回合
    player_hand, player_val = play_player(deck, dealer_up, strategy)
    # 庄家回合（如果玩家没爆牌）
    if player_val <= 21:
        dealer_hand, dealer_val = play_dealer(deck, dealer_hand)
    else:
        dealer_val = hand_value(dealer_hand)  # 玩家爆牌，庄家不用继续
    # 判断结果
    if player_val > 21:
        return 'lose'   # 玩家爆牌
    elif dealer_val > 21:
        return 'win'    # 庄家爆牌
    elif player_val > dealer_val:
        return 'win'
    elif player_val < dealer_val:
        return 'lose'
    else:
        return 'push'   # 平局
```
#### 模拟多次计算胜率

```python

def win_rate(strategy, trials=10000):
    results = [simulate_blackjack(strategy) for _ in range(trials)]
    wins = results.count('win')
    pushes = results.count('push')
    return wins / trials, pushes / trials
```
通常玩家胜率略低于 50%，赌场靠庄家后手及特殊规则获利。

**迭代器在这里的作用**：

- 牌组是一个迭代器，每次发牌只需 `next(deck)`，不需要跟踪索引或修改列表。
    
- 将牌组传递给各个函数，它们只能按顺序取牌，不会乱序或重复。
    
- 代码清晰，符合现实发牌逻辑。
    

---

## 七、知识点总结表

|知识点|核心内容|考试重点 / 易混淆点|难度|
|---|---|---|---|
|**迭代器基础**|`iter(iterable)` 返回迭代器，`next(it)` 获取元素，耗尽时 `StopIteration`|迭代器是一次性的，记住位置|⭐⭐|
|**字典视图**|`keys()`、`values()`、`items()` 返回可迭代视图，顺序为插入顺序|迭代时不能修改字典大小|⭐⭐|
|**可迭代 vs 迭代器**|可迭代对象可反复遍历，迭代器只能一次|`range` 是可迭代对象，`map` 返回迭代器|⭐⭐|
|**惰性计算**|`map`、`filter`、`zip`、`reversed` 返回迭代器，仅当需要时计算|链式调用可提前终止，节省计算|⭐⭐⭐|
|**回文检测**|两种方法：列表比较 vs `zip` 逐对比较|`zip` 版本更通用、惰性|⭐⭐|
|**Blackjack 模拟**|用迭代器表示牌组，实现发牌和策略|理解迭代器在现实问题中的用途|⭐⭐⭐|

---

## 八、自测题

### 1. 基础概念

```python

a = [1, 2, 3]
b = iter(a)
c = iter(b)
print(next(b))
print(next(c))
```
输出是什么？`b` 和 `c` 是同一个迭代器吗？

 输出： ``` 1 2 ``` `c = iter(b)` 返回的是 `b` 本身（因为迭代器的 `__iter__` 返回自身），所以 `b` 和 `c` 是同一个对象。第一次 `next(b)` 消耗了 1，第二次 `next(c)` 继续消耗 2。 

### 2. 字典迭代顺序

```python

d = {'x': 1, 'a': 2, 'b': 3}
print(list(d.keys()))
d['c'] = 4
print(list(d.values()))
```
在 Python 3.6+ 中，输出是什么？

``` ['x', 'a', 'b'] [1, 2, 3, 4] ``` 因为字典保持插入顺序，先插入的 `'x'`, `'a'`, `'b'`，后插入 `'c'`。

### 3. 惰性计算

```python

def noisy_double(x):
    print(f"doubling {x}")
    return 2 * x
m = map(noisy_double, [1, 2, 3, 4])
f = filter(lambda y: y > 5, m)
print(next(f))
```
输出是什么？程序会计算几次 `noisy_double`？

输出： ``` doubling 1 doubling 2 doubling 3 6 ``` 共计算了三次：1→2, 2→4, 3→6。当 6 满足 >5 时，`next(f)` 返回 6，不再计算 4。 

### 4. 回文检测

实现一个函数 `is_palindrome(seq)`，使用 `zip` 方法。

```python

def is_palindrome(seq):
    return all(a == b for a, b in zip(seq, reversed(seq)))

```

### 5. 思考题

为什么在 Blackjack 示例中使用迭代器而不是直接操作列表索引？有什么好处？

<details> <summary>提示</summary>

- 迭代器封装了“当前位置”，发牌函数只需关心拿到下一张牌，无需维护索引变量。
    
- 可以轻松替换牌组的来源（例如从文件读取牌序）而不改变发牌逻辑。
    
- 避免意外修改牌组（如删除已发的牌），因为迭代器只允许单向读取。
    

</details>

---

## 九、总结与展望

本节课我们深入学习了迭代器，这是 Python 中一种非常重要的抽象。你学会了：

- 如何用 `iter` 和 `next` 手动遍历可迭代对象。
    
- 字典视图的迭代特性及注意事项。
    
- 区分可迭代对象与迭代器，理解 `for` 循环的工作机制。
    
- 使用 `map`、`filter`、`zip`、`reversed` 等内置函数进行惰性计算。
    
- 用迭代器实现回文检测和 Blackjack 游戏模拟。
    

迭代器不仅是高效处理数据的基础，也是生成器、协程等高阶概念的前置知识。在后续课程中，你将学习如何自定义迭代器和生成器，进一步发挥惰性计算的威力。
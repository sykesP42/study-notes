# 📘 Lecture 25：数据示例 —— 列表变异、类属性与高级操作技巧 

> 本节课将综合运用前面学到的知识，通过大量示例深入理解列表变异的细节、类与实例属性的继承关系，以及如何使用内置函数和推导式高效处理数据。最后，我们还将探索链表的递归操作，巩固递归思维。

---

## 一、列表变异与环境图

### 1.1 列表变异的本质

列表是可变对象，这意味着我们可以修改其内容（增删改元素）而不改变列表对象的身份。多个变量可以引用同一个列表，通过一个变量修改列表会影响其他所有引用该列表的变量。环境图是理解这些变化的最佳工具。

### 1.2 基础操作示例

假设初始状态：

```python

s = [2, 3]
t = [5, 6]

```
#### 1. `append` 操作

```python

s.append(t)   # 将 t 作为一个元素添加到 s 末尾
```
执行后：

- `s` 变为 `[2, 3, [5, 6]]`（`t` 本身是一个列表，被作为整体添加）
    
- `t` 保持不变 `[5, 6]`
    
- **注意**：添加的是 `t` 所引用的列表对象，不是 `t` 变量的副本。
    

#### 2. `extend` 操作

```python

t.extend(t)   # 将 t 的所有元素添加到自身末尾
```
执行前 `t = [5, 6]`，执行后：

- `t` 变为 `[5, 6, 5, 6]`（将自身的元素扩展到自己末尾）
    
- `s` 不受影响。
    

接着修改：

```python

t[1] = 0      # 将索引 1 的元素改为 0
```
现在 `t = [5, 0, 5, 6]`。

#### 3. 列表加法与切片

```python

a = s + [t]   # 创建新列表 a，包含 s 的所有元素和 t 列表本身
b = a[1:]     # 切片创建新列表 b，包含 a 从索引 1 开始的所有元素
```
此时：

- `a = [2, 3, [5, 0, 5, 6]]`（`t` 现在是 `[5,0,5,6]`）
    
- `b = [3, [5, 0, 5, 6]]`
    

现在修改 `b` 中的子列表：

```python

b[1][1] = 99
```
这会修改 `b[1]` 所指向的列表的第二个元素，而这个列表正是 `a[2]` 和 `t` 所引用的同一个列表。因此：

- `b` 变为 `[3, [5, 99, 5, 6]]`
    
- `a` 变为 `[2, 3, [5, 99, 5, 6]]`
    
- `t` 变为 `[5, 99, 5, 6]`
    

**关键**：多个列表可能包含对同一子列表的引用，修改子列表会通过所有引用体现出来。

#### 4. 列表函数 `list()`

```python

c = list(s)   # 创建 s 的浅拷贝
```
`list(s)` 创建一个新列表，其元素与 `s` 相同。但注意，如果 `s` 包含可变对象（如列表），这些对象本身不会被复制，只是引用被复制。

python

s.append(4)   # 修改 s
c 不受影响，因为 c 是独立列表。

但如果修改 `s` 中的子列表（如 `s[2]` 指向的子列表），那么 `c[2]` 也会反映该变化，因为它们引用同一个子列表。

#### 5. `pop` 操作

```python

t = s.pop()   # 移除 s 的最后一个元素并返回它
```
如果 `s = [2, 3, [5,6]]`，则 `t` 变为 `[5,6]`，`s` 变为 `[2,3]`。

#### 6. `remove` 操作

```python

t = [5,6,5,6]
t.remove(5)   # 移除第一个匹配的 5
```
结果 `t = [6,5,6]`，只移除第一个，后面的 5 还在。

#### 7. 切片赋值与自引用

```python

t = [1,2,3,4]
t[1:3] = [t]   # 将切片 [1:3]（即 [2,3]）替换为包含 t 自身的列表
```
结果 `t` 变为 `[1, [...], 4]`，其中 `[...]` 表示列表对自身的引用（循环引用）。打印时会显示 `[1, [...], 4]`，避免无限展开。

**环境图**：这种操作会导致列表的一个元素指向列表自身，形成环。

---

## 二、实例属性和类属性

### 2.1 类定义与继承

我们通过一个工人（Worker）和资产阶级（Bourgeoisie）的示例来展示属性查找规则和继承。

```python

class Worker:
    greeting = 'Sir'                     # 类属性
    def __init__(self):
        self.elf = Worker                 # 实例属性，指向 Worker 类本身
    def work(self):
        return self.greeting + ', I work'
    def __repr__(self):
        return Bourgeoisie.greeting       # 注意：直接引用 Bourgeoisie 的类属性
class Bourgeoisie(Worker):
    greeting = 'Peon'                     # 覆盖类属性
    def work(self):
        print(Worker.work(self))          # 调用父类方法
        return 'I gather wealth'
```
### 2.2 实例创建与属性访问

```python

jack = Worker()
john = Bourgeoisie()
```
- `jack` 是 `Worker` 实例。
    
- `john` 是 `Bourgeoisie` 实例。
    

#### 属性查找规则

1. 先查找实例属性（如 `jack.greeting` 若存在则返回）。
    
2. 若未找到，则查找类属性（`Worker.greeting`）。
    
3. 若类中未找到，则沿继承链向上查找（`Bourgeoisie` 会查找父类 `Worker`）。
    

#### 覆盖实例属性

```python

jack.greeting = 'Maam'   # 为 jack 创建实例属性 greeting
```
现在 `jack.greeting` 返回 `'Maam'`（实例属性覆盖类属性），而 `Worker.greeting` 仍是 `'Sir'`，其他 `Worker` 实例不受影响。

#### 方法调用

```python

print(jack.work())   # 输出 "Maam, I work"（使用实例属性 greeting）
print(john.work())   # 先打印 "Peon, I work"（调用父类方法时使用 john 的实例？注意：父类方法 Worker.work(self) 中的 self 是 john，因此 self.greeting 查找 john 的类属性 greeting='Peon'），然后返回 "I gather wealth"
```
**详细分析 `john.work()`**：

- `john.work()` 调用 `Bourgeoisie.work`。
    
- `Bourgeoisie.work` 第一行 `print(Worker.work(self))` 显式调用父类方法，传入 `self=john`。
    
- `Worker.work` 中 `self.greeting` 会查找 `john` 的属性。`john` 没有实例属性 `greeting`，因此查找其类 `Bourgeoisie`，找到 `greeting='Peon'`，所以打印 `"Peon, I work"`。
    
- 然后返回 `"I gather wealth"`。
    

#### 特殊方法 `__repr__`

```python

print(jack)   # 输出 "Peon"
```
`jack` 是 `Worker` 实例，但它的 `__repr__` 方法返回 `Bourgeoisie.greeting`，即 `'Peon'`。这展示了方法可以跨类引用，但实际中应避免这样奇怪的依赖。

#### 继承链与方法查找

```python

john.elf.work(john)   # john.elf 是 Worker 类（因为 __init__ 中设置了 self.elf = Worker），调用 Worker.work(john)，相当于 Worker.work(john)，结果同上 "Peon, I work"
```
### 2.3 总结

- 实例属性优先于类属性。
    
- 类属性被子类继承，除非子类覆盖。
    
- 方法调用中的 `self` 指向调用实例，因此属性查找基于该实例的类型。
    

---

## 三、操纵可迭代对象和迭代器的示例

本部分展示如何使用内置函数、列表推导和字典推导解决常见数据问题。这些问题通常小而精，是面试和实际编程中的高频考点。

### 3.1 求具有最小绝对值元素的索引

**问题**：给定列表 `s = [-4, -3, -2, 3, 2, 4]`，找出所有绝对值最小的元素的索引。

**分析**：

- 先计算最小绝对值：`min_abs = min(map(abs, s))` → `2`。
    
- 然后找出所有绝对值等于 `min_abs` 的元素的索引。
    

**实现**：

```python

s = [-4, -3, -2, 3, 2, 4]
min_abs = min(abs(x) for x in s)          # 生成器表达式，节省内存
indices = [i for i, x in enumerate(s) if abs(x) == min_abs]
print(indices)   # [2, 4]
```
**注意**：使用 `enumerate` 同时获取索引和值，比 `range(len(s))` 更 Pythonic。

### 3.2 列表相邻元素最大和

**问题**：给定列表 `s`（长度 >1），求相邻两元素之和的最大值。

**方法1**：使用索引遍历

```python

max_sum = max(s[i] + s[i+1] for i in range(len(s)-1))
```
**方法2**：使用 `zip` 生成相邻对

```python

max_sum = max(a + b for a, b in zip(s, s[1:]))
```
`zip(s, s[1:])` 会生成 `(s[0], s[1]), (s[1], s[2]), ...`，正好是相邻对。

**示例**：

```python

s = [-4, -3, -2, 3, 2, 4]
print(max(a+b for a,b in zip(s, s[1:])))   # 3+2=5
```
### 3.3 创建按末位数字分组的字典

**问题**：给定数字列表，创建字典，键为末位数字（0-9），值为以该数字结尾的元素列表。只保留那些至少有一个元素的键。

**输入**：`[5,8,13,21,34,55,89]`  
**输出**：`{1:[21], 3:[13], 4:[34], 5:[5,55], 8:[8], 9:[89]}`

**实现**：

```python

s = [5,8,13,21,34,55,89]
last_digits = {x % 10 for x in s}   # 先收集存在的末位数字
result = {d: [x for x in s if x % 10 == d] for d in last_digits}
```
或者用 `any` 判断存在性，但上面的集合版本更高效。

**另一种写法**（使用 `any` 在字典推导中过滤）：

```python

result = {d: [x for x in s if x % 10 == d] 
          for d in range(10) if any(x % 10 == d for x in s)}
```
但注意 `any` 内部生成器会遍历整个列表，导致重复计算。推荐先计算存在的末位集合。

### 3.4 判断每个元素是否至少有一个其他相等元素

**问题**：给定列表，判断是否每个元素都在列表中至少出现两次（即每个元素都有另一个相等的元素）。

**示例**：

- `[-4, -3, -2, 3, 2, 4]` → `False`（所有元素唯一）
    
- `[4,3,2,3,2,4]` → `True`（每个元素都有重复）
    

**方法1**：使用 `count` 和 `all`

```python

def all_have_an_equal(s):
    return all(s.count(x) > 1 for x in s)
```
**方法2**：利用切片检查元素是否出现在除自身外的位置

```python

def all_have_an_equal(s):
    return all(x in s[:i] + s[i+1:] for i, x in enumerate(s))
```
这种方法对每个元素检查是否出现在除当前位置外的列表中，避免了 `count` 对每个元素的两次遍历（但仍是 O(n²) 复杂度，对于小列表可接受）。

**优化**：可以使用 `collections.Counter` 先统计出现次数，然后检查所有计数 >1。

```python

from collections import Counter
def all_have_an_equal(s):
    counts = Counter(s)
    return all(counts[x] > 1 for x in s)
```
---

## 四、链表练习

### 4.1 判断链表是否有序

假设我们有链表类 `Link`（定义同之前），实现函数判断链表是否按指定顺序排列（默认升序，可指定 `key` 函数）。

```python

def ordered(s, key=lambda x: x):
    """返回链表 s 是否按 key 值非降序排列"""
    if s is Link.empty or s.rest is Link.empty:
        return True
    elif key(s.first) > key(s.rest.first):
        return False
    else:
        return ordered(s.rest, key)
```
- 空链表或单节点视为有序。
    
- 比较当前节点与下一节点的 `key` 值，若当前 > 下一节点，则无序；否则递归检查剩余部分。
    

**示例**：

```python

s = Link(1, Link(-3, Link(4)))
print(ordered(s, key=abs))   # True，因为绝对值为 1,3,4 递增
```
### 4.2 合并两个有序链表

**函数式合并**（返回新链表，不修改原链表）：

```python

def merge(s, t):
    """合并两个有序链表 s 和 t，返回新的有序链表"""
    if s is Link.empty:
        return t
    if t is Link.empty:
        return s
    if s.first < t.first:
        return Link(s.first, merge(s.rest, t))
    else:
        return Link(t.first, merge(s, t.rest))
```
**原地合并**（修改原链表结构）：

```python

def merge_in_place(s, t):
    """将 t 合并到 s 中，返回合并后的链表头（可能修改 s 和 t 的 rest 属性）"""
    if s is Link.empty:
        return t
    if t is Link.empty:
        return s
    if s.first < t.first:
        s.rest = merge_in_place(s.rest, t)
        return s
    else:
        t.rest = merge_in_place(s, t.rest)
        return t
```
**区别**：

- 函数式合并创建新节点，原链表不变。
    
- 原地合并通过重新连接节点来合并，不创建新节点（除了可能递归调用中的栈），修改原链表结构。
    

**示例**：

```python

a = Link(1, Link(3, Link(5)))
b = Link(2, Link(4, Link(6)))
merged = merge(a, b)   # 新链表 1-2-3-4-5-6，a 和 b 仍保持原状
merge_in_place(a, b)   # a 变成合并后的链表头，b 可能不再是一个独立链表（其节点被重连）
```
---

## 五、知识点总结表

|知识点|核心内容|考试重点 / 易混淆点|难度|
|---|---|---|---|
|**列表变异**|`append`、`extend`、`pop`、`remove`、切片赋值|区分修改原列表与创建新列表；共享子列表的副作用|⭐⭐⭐|
|**列表加法与切片**|`+` 创建新列表，切片创建新列表（浅拷贝）|切片赋值（如 `lst[1:3]=...`）会修改原列表|⭐⭐|
|**列表函数 `list()`**|创建浅拷贝|内层可变对象仍是引用|⭐⭐|
|**自引用列表**|切片赋值使列表包含自身，形成环|打印显示 `[...]`|⭐⭐⭐|
|**实例属性 vs 类属性**|实例属性优先；类属性可被继承和覆盖|方法中的 `self` 动态决定查找|⭐⭐⭐|
|**继承与方法调用**|子类可覆盖方法，通过 `Parent.method(self)` 调用父类版本|显式调用父类方法时需传入 `self`|⭐⭐⭐|
|**最小绝对值索引**|`min(map(abs, s))` + 列表推导|使用 `enumerate` 获取索引|⭐⭐|
|**相邻元素最大和**|`zip(s, s[1:])` 生成相邻对|边界条件处理|⭐⭐|
|**末位数字分组**|字典推导结合 `any` 或集合预处理|避免重复计算|⭐⭐⭐|
|**元素重复性判断**|`all(s.count(x)>1 for x in s)` 或切片技巧|复杂度考量|⭐⭐|
|**链表有序判断**|递归比较相邻节点|支持 `key` 函数|⭐⭐|
|**链表合并**|递归比较首元素，连接剩余部分|区分新建 vs 原地修改|⭐⭐⭐|

---

## 六、自测题

### 1. 列表变异预测

已知：

```python

s = [1, 2]
t = [3, 4]
a = s + [t]
b = a[1:]
b[1][0] = 99
```
请问 `s`, `t`, `a`, `b` 分别是什么？

```
- `s = [1, 2]`（不变）
    
- `t = [99, 4]`（因为 `b[1]` 是 `t`，修改了 `t[0]`）
    
- `a = [1, 2, [99, 4]]`
    
- `b = [2, [99, 4]]`
    
```

### 2. 类属性查找

```python

class A:
    x = 1
    def __init__(self):
        self.x = 2
class B(A):
    x = 3
a = A()
b = B()
print(a.x, b.x)
```


`2 3`。`a.x` 找到实例属性 `2`；`b.x` 没有实例属性，找到类 `B` 的类属性 `3`。


### 3. 相邻元素最大和

用一行代码实现函数 `max_adj_sum(s)`，返回列表 `s` 中相邻两元素的最大和。

```python

def max_adj_sum(s):
    return max(a + b for a, b in zip(s, s[1:]))
```

### 4. 末位数字字典

实现函数 `digit_dict(s)`，返回按末位数字分组的字典（只包含存在的末位数字）。

```python

def digit_dict(s):
    last_digits = {x % 10 for x in s}
    return {d: [x for x in s if x % 10 == d] for d in last_digits}

```

### 5. 链表有序判断

修改 `ordered` 函数，使其支持 `reverse=True` 参数，判断是否非升序（即降序）。

```python

def ordered(s, key=lambda x: x, reverse=False):
    if s is Link.empty or s.rest is Link.empty:
        return True
    if reverse:
        if key(s.first) < key(s.rest.first):
            return False
    else:
        if key(s.first) > key(s.rest.first):
            return False
    return ordered(s.rest, key, reverse)

```

### 6. 思考题

为什么在合并两个有序链表时，函数式合并和原地合并的空间复杂度不同？分别是什么？

```
函数式合并需要创建新节点，空间复杂度 O(n+m)（新链表长度）。原地合并只修改指针，除了递归调用的栈空间外，不需要额外空间，因此空间复杂度 O(1)（不考虑栈）或 O(min(n,m))（递归深度）。但 Python 递归深度有限，对于长链表可能更适合迭代实现。

```
---

## 七、总结与展望

本节课我们通过大量实际代码示例，深入探讨了：

- 列表变异的细节，特别是共享引用带来的副作用。
    
- 类与实例属性的查找规则，以及继承中的方法调用。
    
- 使用内置函数和推导式解决常见数据问题的技巧。
    
- 链表的递归操作（有序判断、合并）。
    

这些知识不仅帮助你通过考试，更重要的是培养了你处理复杂数据结构和编写简洁高效代码的能力。在后续课程中，你将学习更多高级数据结构（如树、图）和算法，届时这些基础将发挥关键作用。
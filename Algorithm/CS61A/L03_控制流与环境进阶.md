# 📘 Lecture 3：控制流与环境进阶

> 本笔记从用户定义函数的生命周期出发，深入探讨环境与名称解析、运算符细节、条件与循环控制、文档测试等主题。每一部分都配有详细的原理说明、代码示例、常见错误分析和自测题，帮助你建立对Python执行模型的深刻理解。

---

## 一、用户定义函数的生命周期

### 1. `def` 语句：创建函数

当Python执行`def`语句时，它会在当前环境中创建一个函数对象，并将函数名绑定到该对象。函数对象包含：

- 函数签名（函数名和形参列表）
    
- 函数体的代码
    
- 定义时的环境（后续用于闭包）
    

```python

from operator import mul
def square(x):
    return mul(x, x)
```
- 执行`def`时，并不会执行函数体，只是记录函数体代码和形参`x`。
    
- 函数对象被创建后，名称`square`在全局帧中绑定到该函数。
    

### 2. 调用用户定义函数

调用表达式的求值步骤：

1. **求值运算符**（函数名）：得到函数对象。
    
2. **求值操作数**（参数表达式）：从左到右求值，得到实参值。
    
3. **创建新帧**（局部帧），将形参与实参绑定。
    
4. **在新帧（加上全局帧构成的环境）中执行函数体**。
    
5. **返回函数体执行结果**（由`return`语句指定）。
    

#### 示例：`square(square(3))`

```python

from operator import mul
def square(x):
    return mul(x, x)
result = square(square(3))
```
执行过程分解：

- 外层调用`square(square(3))`需要先求值内层`square(3)`：
    
    1. 内层`square(3)`：创建帧`f1`，`x`绑定到`3`，执行`mul(3,3)`返回`9`，帧`f1`销毁。
        
- 外层`square(9)`：创建帧`f2`，`x`绑定到`9`，执行`mul(9,9)`返回`81`，帧`f2`销毁。
    

> ⭐ **关键**：每次函数调用都会创建独立的局部帧，帧之间互不干扰。嵌套调用时，先执行最内层，逐步向外。

---

## 二、环境 —— 名称的意义

### 1. 环境的定义

**环境**（environment）是由一系列**帧**（frame）组成的序列。每个帧是一个名称→值的映射。

- **全局帧**（global frame）：程序开始执行时创建，始终存在，没有父帧。
    
- **局部帧**（local frame）：函数调用时创建，父帧是定义该函数的环境（通常是全局帧）。
    

### 2. 名称解析规则

> **名称求值**：返回当前环境中**最早**包含该名称的帧中绑定的值。

即从第一个帧（当前局部帧）开始查找，若找不到则到父帧（全局帧），直到找到为止。若遍历完所有帧仍未找到，抛出`NameError`。

#### 示例：形参与函数同名

```python

def square(square):
    return mul(square, square)
square(4)
```
调用`square(4)`时：

- 创建局部帧，形参`square`绑定到`4`。
    
- 函数体内`mul(square, square)`：查找`square`，先在局部帧找到（值为`4`），不会去全局帧找函数`square`。
    
- 结果：`4*4=16`。
    

> ⚠️ 虽然函数名和形参名都是`square`，但由于查找规则，它们在不同环境中含义不同。全局帧中的`square`是函数，局部帧中的`square`是整数`4`。

### 3. 同一名称在不同环境中的意义

名称的意义由当前环境决定。同一个名称在不同的调用中可能绑定到不同的值，这正是函数参数传递的机制。

---

## 三、运算符 —— 语法糖与优先级

### 1. 运算符本质

Python中的运算符（如`+`、`*`）实际上是内置函数的简写形式，对应`operator`模块中的`add`、`mul`等函数。

- `2 + 3` 等价于 `add(2, 3)`
    
- `2 * 3 + 4` 等价于 `add(mul(2, 3), 4)`
    

### 2. 优先级规则

中缀运算符遵循数学中的优先级规则（乘法高于加法，括号最高）。

#### 示例

```python

2 + 3 * 4 + 5   # 等价于 add(add(2, mul(3, 4)), 5) → 19
(2 + 3) * (4 + 5)  # 等价于 mul(add(2, 3), add(4, 5)) → 45
```
### 3. 除法：真除法、整数除法、取余

|运算符|名称|函数|示例|结果|
|---|---|---|---|---|
|`/`|真除法|`truediv`|`5/3`|`1.6666666666666667`|
|`//`|整数除法|`floordiv`|`5//3`|`1`|
|`%`|取余|`mod`|`5%3`|`2`|

- **真除法**总是返回浮点数。
    
- **整数除法**向下取整（向负无穷），例如`-5//3`结果为`-2`（因为`-1.666...`向下取整为`-2`）。
    
- **取余**满足恒等式：`a = (a // b) * b + (a % b)`。
    

#### 数字分解示例

```python

n = 2013
quotient = n // 10   # 201
remainder = n % 10   # 3
```
---

## 四、返回多个值

Python函数可以返回多个值，实际上返回的是一个元组（tuple），然后可以被解构赋值。

```python

def divide_exact(n, d):
    return n // d, n % d
q, r = divide_exact(2013, 10)   # q=201, r=3

```
- `return n//d, n%d` 等价于 `return (n//d, n%d)`。
    
- 多返回值特性使得函数可以同时返回商和余数，非常直观。
    

---

## 五、Python源代码的编辑与执行

### 1. 文件执行 vs 交互模式

- **交互模式**（REPL）：输入一行执行一行，适合快速测试。
    
- **文件执行**：将代码保存为`.py`文件，用`python3 文件名.py`运行。
    

若希望执行文件后仍停留在交互模式，可以使用`-i`选项：

```bash

python3 -i ex.py
```
这样执行完文件后，可以继续在交互环境中访问文件中定义的变量和函数。

### 2. 文件结构示例

```python

"""Our first Python source file."""
from operator import floordiv, mod
def divide_exact(n, d):
    """Return the quotient and remainder of dividing N by D."""
    return floordiv(n, d), mod(n, d)
# 测试代码
if __name__ == '__main__':
    q, r = divide_exact(2013, 10)
    print(q, r)
```
---

## 六、文档字符串（docstring）与 doctest

### 1. 文档字符串规范

- 函数定义后的第一个字符串（用三重引号`"""`包裹）称为文档字符串。
    
- 第一行简明描述函数功能。
    
- 空一行后，可以包含更详细的说明和使用示例。
    

#### 示例

```python

def divide_exact(n, d):
    """Return the quotient and remainder of dividing N by D.
    >>> q, r = divide_exact(2013, 10)
    >>> q
    201
    >>> r
    3
    """
    return floordiv(n, d), mod(n, d)
```
### 2. doctest 模块

doctest 会扫描文档字符串中的`>>>`示例，执行并验证输出。

- **运行测试**：
    
    ```bash
    
    python3 -m doctest ex.py
    ```
    若无输出，表示所有测试通过。
    
- **查看详细输出**：
    
    ```bash
    
    python3 -m doctest -v ex.py
    ```
- **测试失败时**，会明确指出失败位置和期望值与实际值的差异。
    

> 💡 doctest 非常适合在文档中嵌入可执行的示例，确保代码与文档一致。

---

## 七、默认参数值

函数定义时可以为参数指定默认值，调用时若省略该参数，则使用默认值。

```python

def divide_exact(n, d=10):
    """Return the quotient and remainder of dividing N by D. D defaults to 10."""
    return floordiv(n, d), mod(n, d)
q, r = divide_exact(2013)   # 等价于 divide_exact(2013, 10)
```
- 默认值在函数**定义时**计算并保存，而不是每次调用时。
    
- 默认参数可以是任何表达式，但通常使用不可变值（避免共享可变对象带来的陷阱）。
    

---

## 八、语句与复合语句

### 1. 语句的定义

**语句**（statement）是解释器执行的一个动作单元，例如赋值语句、`def`语句、`return`语句等。语句可以跨越多行。

### 2. 复合语句结构

复合语句由**头部**和**套件**（suite）组成：

- **头部**：以关键字开头（如`if`、`def`、`while`），以冒号结尾。
    
- **套件**：缩进的语句块，可以是一行或多行。
    

#### 示例

```python

if x > 0:          # 头部
    print('positive')   # 套件
```
---

## 九、条件语句

### 1. 语法结构

```python

if <condition>:
    <suite>
elif <condition>:
    <suite>
else:
    <suite>
```
- `if` 是必需部分。
    
- `elif` 可以有0个或多个。
    
- `else` 最多一个，且必须放在最后。
    

### 2. 执行机制

1. 按顺序评估每个条件表达式（在布尔上下文中）。
    
2. 遇到第一个为**真值**的条件，执行对应的套件，然后跳过剩余子句。
    
3. 若所有条件都为假，执行`else`套件（如果存在）。
    

> ⚠️ 条件语句中最多只有一个套件会被执行。

#### 示例：绝对值函数

```python

def absolute(x):
    if x < 0:
        return -x
    elif x == 0:
        return 0
    else:
        return x
```
---

## 十、布尔上下文

在条件语句、循环语句的头部，表达式会在**布尔上下文**（boolean context）中求值，即只关心结果是**真值**（truthy）还是**假值**（falsy）。

- **假值**：`False`、`0`、`0.0`、`''`（空字符串）、`None`、`[]`（空列表）、`{}`（空字典）等。
    
- **真值**：所有其他值。
    

#### 示例

```python

if 'hello':        # 非空字符串为真
    print('true')   # 输出
if 0:              # 0为假
    print('false')  # 不会执行
```
> 💡 布尔上下文是控制流的基础，理解真假值有助于编写简洁的条件。

---

## 十一、迭代 —— while 循环

### 1. while 语句结构

```python

while <condition>:
    <suite>
```
- 只要条件为真，就重复执行套件。
    
- 每次执行完套件后，重新评估条件。
    

### 2. 执行步骤

1. 评估条件表达式（布尔上下文）。
    
2. 若为真值：
    
    - 执行整个套件。
        
    - 回到步骤1。
        
3. 若为假值：
    
    - 结束循环，继续执行后面的代码。
        

#### 示例：计算 1+2+3 的和

```python

i = 0
total = 0
while i < 3:
    i = i + 1
    total = total + i
print(total)   # 6
```
逐步追踪：

|循环次数|`i < 3`|`i`|`total`|
|---|---|---|---|
|初始||0|0|
|第1次|True|1|1|
|第2次|True|2|3|
|第3次|True|3|6|
|第4次|False|3|6|

> ⚠️ **无限循环风险**：如果循环条件永远为真（例如忘记更新循环变量），程序将无限执行。务必确保循环体中有改变条件的语句。

---

## 十二、知识点总结表（含扩展说明）

|知识点|核心内容|详细说明 / 示例|常见错误 / 易混淆点|难度|
|---|---|---|---|---|
|**函数生命周期**|`def`创建函数，调用时创建新帧|`square(square(3))` 嵌套调用先内后外|混淆函数名与形参|⭐⭐⭐|
|**环境与帧**|环境是帧序列，名称从前往后查找|局部帧优先于全局帧|认为所有名称都在全局帧|⭐⭐⭐|
|**运算符优先级**|`*` 高于 `+`，括号可改变|`2+3*4` = 14，`(2+3)*4`=20|忽略优先级导致错误结果|⭐⭐|
|**除法类型**|`/`浮点除，`//`整数除，`%`取余|`5//3=1`，`5%3=2`|对负数除法的方向理解错误|⭐⭐|
|**多返回值**|函数返回元组，可解构赋值|`q, r = divmod(2013,10)`|返回值数量与变量数量不匹配|⭐⭐|
|**文档字符串**|函数内首个三重引号字符串|包含示例，可用doctest测试|忘记写文档，或示例格式错误|⭐⭐|
|**doctest**|自动验证文档中的示例|`python3 -m doctest file.py`|不理解静默通过的含义|⭐⭐|
|**默认参数**|参数可指定默认值|`def f(x, y=10):`|默认值为可变对象时的陷阱|⭐⭐⭐|
|**条件语句**|`if`-`elif`-`else` 结构|最多执行一个分支|忘记冒号或缩进错误|⭐|
|**布尔上下文**|真假值决定分支|假值：`False,0,'',None,...`|误将非空列表当作假|⭐⭐|
|**while循环**|条件为真时重复执行|需要更新循环变量|无限循环|⭐⭐|

---

## 十三、自测题 —— 检验理解

### 1. 函数调用与环境

```python

def f(x):
    return g(x) * 2
def g(x):
    return x + 1
print(f(3))
```
请描述调用`f(3)`时帧的创建顺序和名称查找过程。

<details> <summary>答案</summary>

1. 全局帧：f→函数，g→函数。
    
2. 调用`f(3)`：创建局部帧`f1`，`x`绑定到3。
    
3. 执行`f`体：计算`g(x)`，查找`g`：在`f1`中找不到，到全局帧找到`g`函数。
    
4. 调用`g(3)`：创建局部帧`f2`，`x`绑定到3。
    
5. 执行`g`体：返回`3+1=4`，帧`f2`销毁。
    
6. 回到`f1`，计算`4*2=8`，返回8，帧`f1`销毁。
    
7. 输出8。
    

</details>

### 2. 名称解析

```python

def square(square):
    return square * square
print(square(5))
```
输出是什么？解释原因。

<details> <summary>答案</summary> 输出25。调用`square(5)`时，局部帧中`square`绑定到5，函数体内的`square`查找得到5，计算5*5=25。全局函数`square`被局部参数覆盖。 </details>

### 3. 运算符优先级

将表达式`2 + 3 * 4 ** 2`改写成等价的函数调用形式（使用`add`、`mul`、`pow`）。

<details> <summary>答案</summary> `add(2, mul(3, pow(4, 2)))` 因为`**`优先级最高，先计算`4**2=16`，然后`3*16=48`，最后`2+48=50`。 </details>

### 4. 除法与取余

`-7 // 3` 和 `-7 % 3` 的结果是多少？验证恒等式。

<details> <summary>答案</summary> `-7 // 3` = -3（向下取整，-2.33...向下为-3）。 `-7 % 3` = 2（因为 `-7 = (-3)*3 + 2`）。 恒等式成立：`(-3)*3 + 2 = -9+2 = -7`。 </details>

### 5. 多返回值与解构

```python

def swap(a, b):
    return b, a
x, y = swap(10, 20)
print(x, y)
```
输出什么？

<details> <summary>答案</summary> 20 10。函数返回元组(20, 10)，解构赋值给x和y。 </details>

### 6. while 循环

以下代码输出什么？

```python

i = 1
total = 0
while i <= 5:
    total = total + i
    i = i + 1
print(total)
```
<details> <summary>答案</summary> 15（1+2+3+4+5）。 </details>

### 7. 思考题

如果在一个函数内部定义另一个函数，那么内部函数的环境是怎样的？这将为后续学习闭包打下基础。

<details> <summary>提示</summary> 内部函数定义时，其父环境是定义它的那个函数的环境（包括该函数的局部变量）。这种机制称为词法作用域（lexical scoping）。 </details>

---

## 十四、总结与展望

本节课深入探讨了函数调用的底层机制（环境与帧）、控制流（条件与循环）、文档测试以及默认参数等实用特性。这些知识是编写可靠、可维护代码的基础。在后续课程中，你将学习高阶函数、递归、迭代器等内容，而这些都建立在对环境与执行流程的深刻理解之上。

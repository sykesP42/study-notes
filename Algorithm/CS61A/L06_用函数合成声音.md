# 📘 Lecture 6：用函数合成声音

> 本笔记通过一个声音合成的实例，展示如何定义一系列函数并在程序最后阶段组合它们，从而构建复杂系统。你将学习到 WAV 文件格式、波形生成、音符与节奏控制，并最终用代码“演奏”一段马里奥主题曲。这不仅是对高阶函数的实践，也是函数式编程思想的生动应用。

---

## 一、为什么用声音示例？

在之前的课程中，我们学习了高阶函数、闭包和环境图。这些概念在纯粹的数字计算中可能显得抽象。本讲通过**声音合成**这一有趣的应用，展示：

- 如何将问题分解为一系列函数（波形生成、音符构建、节奏叠加）。
    
- 如何在“函数空间”中工作，直到最后一步才将结果写入文件。
    
- 函数组合和参数化如何让我们用少量代码生成复杂的音乐片段。
    

声音（特别是未压缩的 WAV 格式）非常适合作为教学示例，因为：

- 波形数据容易生成（只需计算振幅值）。
    
- 采样和播放的原理直观，与数学函数紧密相关。
    
- 合成音乐需要组合多个函数，天然契合高阶函数思想。
    

---

## 二、WAV 文件格式基础

### 1. 什么是 WAV？

**WAV**（Waveform Audio File Format）是一种未压缩的音频格式，直接存储声波的采样值。它简单、无损，易于程序生成和处理。

### 2. 采样原理

计算机无法存储连续的声波，只能每隔一小段时间记录一个振幅值，这个过程称为**采样**。

- **采样率**：每秒钟采样的次数，单位 Hz。例如，CD 音质为 44100 Hz，本示例使用 **11025 Hz**（人耳听起来已足够自然）。
    
- **采样位数**：每个采样值用多少位二进制表示。常见的有 8 位、16 位。本示例使用 **16 位有符号整数**，取值范围 -32768 到 32767，对应振幅 -1.0 到 1.0。
    

### 3. 振幅与音量

振幅表示声波的强度，通常归一化到 `[-1, 1]` 之间的浮点数。在写入文件时，需要将其映射到 16 位整数的范围。

例如，振幅 `0.5` 对应整数 `0.5 * 32767 ≈ 16383`。

---

## 三、所需模块与辅助函数

### 1. `math` 模块

我们只需要 `math.floor` 用于向下取整（在生成三角波时可能用到），以及 `math.pi` 用于正弦波。但本示例以三角波为主，故 `math` 主要用作备用。

### 2. `struct` 模块：编码二进制数据

WAV 文件将采样值存储为二进制。`struct.pack` 可以将 Python 整数打包成指定格式的字节。


```python

import struct
def encode_sample(value):
    """将 [-1, 1] 的浮点数编码为 16 位有符号整数的字节"""
    scaled = int(value * 32767)
    return struct.pack('<h', scaled)   # '<h' 表示小端序的 16 位有符号整数
```
### 3. 写入 WAV 文件的函数

我们需要一个函数将一系列采样值写入 WAV 文件。假设已有现成的 `write_wav(filename, samples, samplerate=11025)`，它负责写入 WAV 头部并将采样值逐个编码。在示例中，我们使用 `write` 模块（可能是一个自定义模块），其核心逻辑如下：

```python

def write_wav(filename, sampler, duration, samplerate=11025):
    """
    生成 WAV 文件。
    sampler: 一个函数，接收时间 t（秒），返回该时刻的振幅（-1 到 1）。
    duration: 时长（秒）。
    samplerate: 采样率。
    """
    with open(filename, 'wb') as f:
        # 写入 WAV 头部（省略细节）
        ...
        for i in range(int(duration * samplerate)):
            t = i / samplerate
            value = sampler(t)
            f.write(encode_sample(value))
```
> 注意：实际头部需包含声道数（单声道）、采样率、比特率等信息，这里不展开。

---

## 四、波形生成

声音的基本元素是**波形**。不同波形产生不同音色。常见的波形有：正弦波、方波、三角波、锯齿波。

### 1. 正弦波

公式：`sin(2 * pi * frequency * t)`

```python

import math
def sine_wave(frequency, amplitude=0.3):
    def sampler(t):
        return amplitude * math.sin(2 * math.pi * frequency * t)
    return sampler
```
### 2. 方波

公式：`sign(sin(2πft))`，即正半周为 +A，负半周为 -A。

```python

def square_wave(frequency, amplitude=0.3):
    def sampler(t):
        return amplitude * (1 if math.sin(2 * math.pi * frequency * t) >= 0 else -1)
    return sampler
```
### 3. 锯齿波

公式：`2 * (f*t - floor(f*t + 0.5))` 或更简单：`2 * (t % period) / period - 1`。

```python

def sawtooth_wave(frequency, amplitude=0.3):
    period = 1 / frequency
    def sampler(t):
        return amplitude * (2 * (t % period) / period - 1)
    return sampler
```
### 4. 三角波

三角波是锯齿波的绝对值变形，听起来更柔和。公式：`2 * abs(2*(t/period - floor(t/period + 0.5))) - 1` 或使用对称三角。

简洁实现：

```python

def triangle_wave(frequency, amplitude=0.3):
    period = 1 / frequency
    def sampler(t):
        # 先得到锯齿波，然后取绝对值并调整范围
        saw = 2 * (t % period) / period - 1
        return amplitude * (2 * abs(saw) - 1)
    return sampler
```
> 讲师认为三角波听起来最好，因此示例中使用三角波。

---

## 五、生成一个音符

### 1. 频率对应音高

标准音 A4 = 440 Hz。其他音符的频率可以通过公式计算：  
`f = 440 * 2^((n-49)/12)`，其中 n 是 MIDI 音符编号（C4 对应 60）。但本示例直接给出常用频率：

- C4 = 261.63 Hz
    
- E4 = 329.63 Hz
    
- G4 = 392.00 Hz
    

### 2. 音符函数

一个音符可以看作是一个特定频率的波形，持续一段时间。最简单的音符函数如下：

```python

def note(frequency, duration, amplitude=0.3, waveform=triangle_wave):
    wave = waveform(frequency, amplitude)
    def play(t):
        if 0 <= t < duration:
            return wave(t)
        else:
            return 0.0
    return play
```
这样，`note` 返回一个函数，接收时间 t，返回振幅。如果 t 不在指定时间内，返回 0（静音）。

### 3. 验证波形

我们可以生成一小段音符，并打印前几个采样值来观察波形：

```python

c = note(261.63, 1.0)   # 持续 1 秒的 C 音符
for i in range(10):
    t = i / 11025
    print(c(t))
```
可以看到从 -0.3 开始，逐渐上升然后下降的三角波形状。

---

## 六、组合音符 —— 和弦与叠加

### 1. 两个音符同时播放（和弦）

我们可以定义一个函数 `both`，将两个音符的采样值相加，生成和音。

```python

def both(note1, note2):
    def play(t):
        return note1(t) + note2(t)
    return play
```
使用示例：C 大调三和弦（C、E、G）

```python

c = note(261.63, 1.0)
e = note(329.63, 1.0)
g = note(392.00, 1.0)
chord = both(c, both(e, g))   # 或者用 both(both(c, e), g)
```
**注意**：直接相加可能导致振幅超出 [-1, 1] 范围，造成**削波**（clipping），产生失真。一种简单解决是整体降低振幅，例如将每个音符的振幅设为 0.1，三个叠加后最大 0.3。更高级的方法可做归一化，但本例简化处理。

### 2. 多个音符按顺序播放（旋律）

要按时间顺序播放不同音符，我们需要一个函数 `sequentially`，它接受多个音符及其起始时间。但更简单的方法是使用 `note` 的起始和结束参数，并在组合时判断时间。

实际应用中，我们可能会构建一个“乐谱”数据结构，然后用一个调度函数来播放。但在本示例中，讲师通过硬编码时间来实现马里奥主题曲。

---

## 七、节奏控制与淡入淡出

### 1. 带起始时间的音符

为了控制每个音符的出现时机，我们可以在 `note` 函数中添加 `start` 参数：

```python

def note(frequency, start, end, amplitude=0.3, waveform=triangle_wave):
    wave = waveform(frequency, amplitude)
    def play(t):
        if start <= t < end:
            return wave(t - start)   # 相对于音符开始的时间
        else:
            return 0.0
    return play
```
这样，我们可以定义不同时间开始的音符，然后将它们叠加起来。

### 2. 淡入淡出

直接截断音符会产生“爆音”（click），因为波形在边界处不连续。解决方法是添加**淡入淡出**（fade in/out），通常使用线性渐变，持续几毫秒。

例如，在 `note` 中加入淡入淡出（0.01 秒）：

```python

def note(frequency, start, end, amplitude=0.3, waveform=triangle_wave, fade=0.01):
    wave = waveform(frequency, amplitude)
    def play(t):
        if t < start or t >= end:
            return 0.0
        dt = t - start
        if dt < fade:                      # 淡入
            return wave(dt) * (dt / fade)
        elif t > end - fade:                # 淡出
            return wave(dt) * ((end - t) / fade)
        else:
            return wave(dt)
    return play
```
这样保证了边界处振幅平滑过渡到 0，消除爆音。

---

## 八、马里奥主题曲片段

讲师展示了一个示例：用上述函数组合出《超级马里奥》主题曲的前几个音符。这涉及：

- 定义不同音符（C、E、G 等）及其八度（通过乘以或除以 2 的频率）。
    
- 设置精确的起始和结束时间。
    
- 将多个音符函数用 `both` 或加法组合成最终播放器。
    

示例结构（伪代码）：

```python

def mario_theme():
    # 定义一些基础音符
    c4 = note(261.63, 0.0, 0.5)
    e4 = note(329.63, 0.5, 1.0)
    g4 = note(392.00, 1.0, 1.5)
    c5 = note(523.25, 1.5, 2.0)   # 高八度 C
    # 同时播放某些音符形成和弦
    chord1 = both(c4, e4)   # 只是示例，实际节奏更复杂
    # 最终组合所有音轨
    def play(t):
        return c4(t) + e4(t) + g4(t) + c5(t)   # 简单叠加
    return play
```
然后将 `play` 函数传入 `write_wav`，生成完整的 WAV 文件。

### 八度控制

频率加倍则高一个八度，减半则低一个八度。因此我们可以定义：

```python

def octave_up(note_func, multiplier=2):
    """将音符函数的频率乘以 multiplier"""
    # 但由于 note_func 是闭包，需要重新构造，更简单的是定义音符时使用变量
    pass
```
实际上，更常见的是直接传入不同频率。

---

## 九、代码整合与执行

最终，我们只需要调用 `write_wav`，传入一个组合好的 `sampler` 函数和时长，即可生成音乐文件。

```python

if __name__ == '__main__':
    theme = mario_theme()
    write_wav('mario.wav', theme, duration=5.0)   # 假设主题曲 5 秒
```
整个过程中，我们一直在操作函数（生成器、组合器），直到最后才求值（写入文件）。这正是函数式编程的核心：**将计算延迟到最后，中间只构建复合函数**。

---

## 十、知识点总结表（扩展解释）

|知识点|核心内容|详细说明 / 示例|常见错误 / 易混淆点|难度|
|---|---|---|---|---|
|**WAV 文件原理**|未压缩音频格式，直接存储采样值|采样率 11025 Hz，16 位有符号整数，振幅范围 [-1,1]|混淆采样率与比特率；振幅缩放错误导致失真|⭐⭐|
|**波形生成函数**|用数学函数生成周期波形|三角波：`abs(sawtooth)`，正弦波：`sin(2πft)`|相位计算错误；忘记归一化|⭐⭐⭐|
|**高阶函数与闭包**|波形函数返回采样函数，捕获频率、振幅|`def note(freq): return lambda t: ...`|闭包变量延迟绑定可能导致意外（如循环中）|⭐⭐⭐|
|**音符组合（加法）**|将多个采样函数相加得到和弦|`both = lambda f,g: lambda t: f(t)+g(t)`|振幅叠加导致削波；需适当降低振幅|⭐⭐|
|**时序控制**|通过时间参数控制音符起止|`note` 函数内部判断 `start <= t < end`|边界处不连续产生爆音，需淡入淡出|⭐⭐⭐|
|**淡入淡出**|线性渐变消除爆音|在起止处乘以渐变系数 `(t-start)/fade`|渐变时间过短仍可能爆音；需正确计算系数|⭐⭐|
|**八度变换**|频率加倍/减半实现八度升降|高八度：频率 ×2；低八度：频率 ÷2|混淆音分与八度关系|⭐|
|**函数式编程思想**|构建函数组合，最后统一求值|先定义音符函数，再组合，最后传入写入函数|过早求值导致失去组合灵活性|⭐⭐⭐|

---

## 十一、自测题 —— 检验理解

### 1. 基础概念

- 什么是采样率？如果采样率是 11025 Hz，那么一个持续 2 秒的声音有多少个采样点？
    
- WAV 文件中 16 位有符号整数的取值范围是多少？如何将浮点数振幅 -0.5 转换为对应的整数？
    

<details> <summary>答案</summary> 采样率是每秒采样的次数，11025 Hz 表示每秒 11025 个采样点，2 秒共 22050 个采样点。16 位有符号整数范围 -32768 到 32767，-0.5 对应 -0.5 * 32767 ≈ -16383。 </details>

### 2. 波形生成

编写一个函数 `sawtooth_wave(freq, amp)`，返回一个采样函数，生成锯齿波（上升沿陡峭，下降沿缓慢）。

<details> <summary>参考实现</summary>

python

def sawtooth_wave(freq, amp):
    period = 1 / freq
    def sampler(t):
        return amp * (2 * (t % period) / period - 1)
    return sampler

</details>

### 3. 函数组合

现有两个音符函数 `note1` 和 `note2`，定义 `both` 函数将它们叠加，并确保叠加后的振幅不超出 [-1,1]（提示：除以 2）。

<details> <summary>参考实现</summary>

python

def both(note1, note2):
    def play(t):
        return (note1(t) + note2(t)) / 2   # 平均振幅避免削波
    return play

</details>

### 4. 淡入淡出

修改下面的 `note` 函数，使其在开始和结束时各有 0.05 秒的淡入淡出。

```python

def note(freq, start, end, amp):
    wave = triangle_wave(freq, amp)
    def play(t):
        if start <= t < end:
            return wave(t - start)
        return 0.0
    return play

```
ans:
```python

def note(freq, start, end, amp, fade=0.05):
    wave = triangle_wave(freq, amp)
    def play(t):
        if t < start or t >= end:
            return 0.0
        dt = t - start
        if dt < fade:
            return wave(dt) * (dt / fade)
        elif t > end - fade:
            return wave(dt) * ((end - t) / fade)
        else:
            return wave(dt)
    return play
```

### 5. 思考题

为什么说这个示例体现了“在函数空间中工作直到最后”？如果不这样做，而是直接在循环中生成采样值并写入，会有什么不同？

<details> <summary>提示</summary> 通过构建函数组合，我们可以先定义各种音符和效果，然后将它们像积木一样拼装成最终的音乐。这种“声明式”编程让代码更易读、易修改。如果直接在循环中写入，每次修改都需要重写循环逻辑，且难以复用。此外，函数组合允许我们动态地创建新函数（如 `both`），而无需预先知道所有组合方式。 </details>

---

## 十二、总结与展望

本讲通过声音合成的实例，展示了函数式编程思想在实际问题中的应用。你学到了：

- 如何用函数生成波形数据。
    
- 如何通过高阶函数组合音符，形成和弦与旋律。
    
- 如何控制时序与淡入淡出，生成自然的音符。
    
- 最终将所有函数组合成一个播放器，再写入文件。
    

这种“先构建函数，最后再执行”的模式，正是函数式编程的核心优势之一：**将计算延迟，通过组合构建复杂行为**。在后续课程中，你将看到更多类似的模式，如迭代器、生成器、装饰器等。
# 📘 Lecture 17：生成器（Generators）

> 生成器是 Python 中一种特殊的迭代器，它允许你以惰性（lazy）的方式生成一系列值，而不需要一次性构建整个序列。生成器通过 `yield` 关键字暂停和恢复执行，使得我们可以编写简洁、内存友好的代码来处理无限序列或大规模组合搜索。本节课将带你从零掌握生成器，并学会用它们解决实际问题。

---

## 一、什么是生成器？

### 1. 生成器函数与生成器对象

**生成器函数**是指函数体中包含 `yield` 关键字的函数。调用生成器函数不会立即执行函数体，而是返回一个**生成器对象**（generator object），该对象是一个迭代器。

**生成器对象**支持 `next()` 方法，每次调用 `next()` 时，函数体从上一次 `yield` 的位置继续执行，直到遇到下一个 `yield` 或函数结束。当函数结束时，抛出 `StopIteration` 异常。

#### 最简单的示例


```python

def plus_minus(x):
    yield x
    yield -x
t = plus_minus(3)      # 返回生成器对象，不执行函数体
print(next(t))         # 输出 3，执行到第一个 yield
print(next(t))         # 输出 -3，从上次暂停处继续，执行到第二个 yield
print(next(t))         # StopIteration，函数结束
```
**执行过程**：

- 调用 `plus_minus(3)` 创建生成器对象，函数体**暂停**在开头。
    
- 第一次 `next(t)`：进入函数体，执行 `yield x`，返回 `3`，并暂停在 `yield` 之后。
    
- 第二次 `next(t)`：从暂停处恢复，执行 `yield -x`，返回 `-3`，再次暂停。
    
- 第三次 `next(t)`：函数体已无更多 `yield`，结束并抛出 `StopIteration`。
    

> 💡 **关键区别**：普通函数用 `return` 一次性返回结果并结束；生成器用 `yield` 多次返回中间结果，并保持局部状态（变量绑定、指令指针等）以供下次恢复。

---

## 二、`yield from` 语法

### 1. 为什么需要 `yield from`？

当我们需要从一个迭代器中逐个产生所有元素时，通常需要手动 `for` 循环遍历并 `yield`。例如，想要先遍历 `a` 再遍历 `b`：

```python

def a_then_b(a, b):
    for x in a:
        yield x
    for x in b:
        yield x
```
这种写法很常见，但略显啰嗦。Python 3.3 引入了 `yield from`，它可以直接将另一个迭代器的所有元素“委托”给当前生成器。

```python

def a_then_b(a, b):
    yield from a
    yield from b
```
`yield from <iterable>` 等价于：

```python

for x in <iterable>:
    yield x
```
**示例**：

```python

>>> list(a_then_b([1,2], [3,4]))
[1, 2, 3, 4]
```
### 2. 递归生成器中的应用

`yield from` 在递归生成器中特别有用，因为它避免了手动循环嵌套，使代码更简洁。

#### 倒计时示例

```python

def countdown(k):
    if k > 0:
        yield k
        yield from countdown(k-1)   # 递归生成剩余数字
    else:
        yield 'Blast off!'
>>> list(countdown(3))
[3, 2, 1, 'Blast off!']
```
如果没有 `yield from`，我们需要显式迭代递归结果：

```python

def countdown(k):
    if k > 0:
        yield k
        for val in countdown(k-1):
            yield val
    else:
        yield 'Blast off!'
```
显然，`yield from` 版本更简洁且意图更清晰。

---

## 三、生成器的递归应用

生成器可以像普通函数一样递归，每次递归调用返回一个子生成器，通过 `yield from` 将其值展开。

### 1. 生成字符串的所有前缀

```python

def prefixes(s):
    """生成字符串 s 的所有前缀（包括空串？通常不包括）"""
    if s:
        yield from prefixes(s[:-1])   # 先生成前缀的前缀
        yield s                       # 再生成自身
    else:
        yield ''                       # 空串
>>> list(prefixes('abc'))
['', 'a', 'ab', 'abc']
```
**执行顺序**：

- 对 `'abc'`，先递归生成 `'ab'` 的所有前缀，得到 `'', 'a', 'ab'`，然后 yield `'abc'`。
    
- 对 `'ab'`，先递归生成 `'a'` 的所有前缀，得到 `'', 'a'`，然后 yield `'ab'`。
    
- 对 `'a'`，先递归生成 `''` 的所有前缀，得到 `''`，然后 yield `'a'`。
    
- 对 `''`，直接 yield `''`。
    

因此最终顺序是先短后长。

### 2. 生成字符串的所有子串

```python

def substrings(s):
    if s:
        yield from prefixes(s)           # 生成以当前 s 结尾的所有前缀
        yield from substrings(s[1:])     # 去掉第一个字符，继续
    else:
        yield ''
>>> list(substrings('abc'))
['', 'a', 'ab', 'abc', 'b', 'bc', 'c']
```
这个生成器会递归地生成所有可能的连续子串。注意它包含了空串。

---

## 四、生成器解决组合问题：整数划分

整数划分（Partition）是组合数学中的经典问题：将一个正整数 `n` 拆分成若干个不超过 `m` 的正整数之和（顺序不计，即按递增顺序列出）。之前我们用递归函数计算了划分的**数量**，现在我们要用生成器**列出所有划分**。

### 1. 递归思路回顾

- 如果 `n == 0`：只有一种划分：空和（即不取任何数）。
    
- 如果 `n < 0` 或 `m == 0`：无有效划分。
    
- 否则，划分可以分为两类：
    
    1. **包含至少一个 `m`**：先取一个 `m`，然后划分 `n - m`，且最大仍可为 `m`。
        
    2. **完全不包含 `m`**：划分 `n`，但最大不超过 `m-1`。
        

### 2. 生成器版本

我们不再返回计数，而是 `yield` 每个划分（用列表表示）。

```python

def partitions(n, m):
    """生成 n 的所有划分，每个划分由不超过 m 的整数递增组成"""
    if n == 0:
        yield []                        # 空和
    elif n > 0 and m > 0:
        # 情况1：至少使用一个 m
        for p in partitions(n - m, m):
            yield [m] + p                # 注意保持递增？这里 p 是从 n-m 的划分，其元素都 ≤ m，所以 [m] + p 是递增的吗？需要确保 p 的第一个元素 ≥ m？不一定，所以可能需要调整顺序。
            # 实际上，如果 p 是递增的，且所有元素 ≤ m，那么 [m] + p 不一定递增，因为 m 可能大于 p 的第一个元素。因此更好的方式是先递归包含 m 的情况，然后递归不包含 m 的情况，但列表构造时需保证顺序。
            # 更严谨的实现：将包含 m 的划分表示为 [m] + p，但要求 p 的每个元素 ≥ m？但 p 来自 n-m 的划分，其元素不超过 m，所以 p 中可能有小于 m 的元素，这样拼接后就不是递增了。所以正确的做法是：在递归包含 m 时，划分的最大值仍然是 m，但后续元素可以小于等于 m，我们只需保证整体不递减。但 [m] + p 中 m 可能大于 p[0]？实际上 p 是 n-m 的划分，其元素都不超过 m，但可以是任意顺序？我们要求划分是递增的，所以 p 本身必须是递增的。如果 p 是递增的，那么 [m] + p 只有在 m ≤ p[0] 时才递增，否则不是。而 p 来自 partitions(n-m, m)，其元素最大为 m，但第一个元素可能小于 m，所以 [m] + p 不满足递增。因此我们需要调整思路：包含 m 的划分，应该是先放置 m，然后后面跟一个从 n-m 且最大不超过 m 的划分，但这个划分的每个元素都必须 ≤ m，且为了整体递增，这个划分的每个元素都应该 ≥ m？不对，如果后面有比 m 小的数，那么整体就不是递增了。所以实际上，包含 m 的划分中，m 应该是最后一个（最大的）数？但我们的划分习惯上是递增顺序，所以最小的数在前，最大的数在后。如果我们先取一个 m，然后剩余部分用不超过 m 的数划分，那么剩余部分的每个数都应该 ≤ m，但为了整体递增，剩余部分的数应该都 ≥ m？这矛盾，因为剩余部分的数如果都 ≥ m，那它们至少是 m，但总和会超过。所以正确的递归分解应该是：要么使用一个最大数 m，然后剩余部分用不超过 m 的数划分，但剩余部分的数可以小于等于 m，并且为了整体递增，我们需要把 m 放在最后（即作为最大数）。因此我们构造列表时，应该把 m 放在末尾，即 `p + [m]`，其中 p 是 n-m 的划分，且 p 的元素都不超过 m，并且 p 本身递增，那么 `p + [m]` 也是递增的（因为 p 的最后一个元素 ≤ m，且 m 更大？不一定，p 的最后一个元素可能等于 m，但等于时也可以）。这样合理。
修正实现：
```python
def partitions(n, m):
    """生成 n 的所有划分，每个划分按递增顺序排列"""
    if n == 0:
        yield []
    elif n < 0 or m == 0:
        return
    else:
        # 使用至少一个 m：先取 m，然后剩余 n-m 用不超过 m 的数划分
        for p in partitions(n - m, m):
            yield p + [m]          # 将 m 放在最后，保证递增
        # 不使用 m：只用不超过 m-1 的数划分
        for p in partitions(n, m - 1):
            yield p

但这样会包含重复吗？注意 `p + [m]` 已经保证了 `m` 是最大的（因为 p 的元素都不超过 m，且 p 递增，所以最后一个元素 ≤ m，加上 m 后，如果 p 的最后一个元素等于 m，则列表末尾有两个相同的 m，这是允许的，因为划分中允许重复数字。所以递增顺序依然保持。
```
#### 测试

```python

>>> list(partitions(6, 4))
[[2, 4], [1, 1, 4], [3, 3], [1, 2, 3], [1, 1, 1, 3], [2, 2, 2], [1, 1, 2, 2], [1, 1, 1, 1, 2], [1, 1, 1, 1, 1, 1]]
```
这正是我们期望的 9 种划分。

### 3. 生成器的优势

- **内存友好**：不需要一次性存储所有划分（对于大 n，划分数量极大），而是逐个生成，可以随时停止。
    
- **惰性计算**：只有在需要时才递归展开下一个划分，避免不必要的计算。
    
- **代码简洁**：递归生成器的结构直接反映了问题的递归分解，易于理解和验证。
    

---

## 五、知识点总结表

|知识点|核心内容|考试重点 / 易混淆点|难度|
|---|---|---|---|
|**生成器函数**|包含 `yield` 的函数，调用返回生成器对象，可用 `next()` 驱动|`yield` 暂停并保存状态，函数体不会立即执行|⭐⭐|
|**生成器对象**|迭代器的一种，支持 `next()` 和 `for` 循环|生成器是一次性的，耗尽后不能再使用|⭐⭐|
|**`yield from`**|委托给另一个迭代器，相当于 `for x in iter: yield x`|简化递归生成器中的嵌套循环|⭐⭐⭐|
|**递归生成器**|生成器可以递归调用，通过 `yield from` 展开子结果|递归终止条件必须明确，否则无限递归|⭐⭐⭐|
|**整数划分生成器**|递归分解为“含 m”和“不含 m”，逐个生成列表|注意构造列表的顺序以保证递增|⭐⭐⭐⭐|
|**惰性计算优势**|节省内存，支持无限序列，可中途停止|对比一次性计算全部结果|⭐⭐|

---

## 六、自测题

### 1. 基础生成器

写出以下代码的输出：

```python

def gen():
    yield 1
    yield 2
    yield 3
g = gen()
print(next(g))
print(next(g))
print(next(g))
print(next(g))
```
 ``` 1 2 3 StopIteration 异常（或 for 循环会正常结束，但显式 next 会报错） ``` 

### 2. `yield from` 简化

用 `yield from` 重写以下生成器：

```python

def flatten(lst):
    for sublist in lst:
        for item in sublist:
            yield item
```

```python

def flatten(lst):
    for sublist in lst:
        yield from sublist
```

### 3. 递归生成器

实现一个生成器 `fib()`, 无限生成斐波那契数列（0, 1, 1, 2, 3, 5, ...）。

```python

def fib():
    a, b = 0, 1
    while True:
        yield a
        a, b = b, a + b

```

### 4. 整数划分计数 vs 生成

为什么生成器版本的 `partitions` 比之前返回计数的递归函数更适合探索所有划分？

```
- 返回计数的函数只能得到一个数字，无法知道具体划分。
    
- 生成器可以逐个产生划分，用户可以处理每个划分（如打印、统计、筛选），且可以提前停止。
    
- 对于大的 n，划分数量可能极大，生成器避免了一次性存储所有结果，节省内存。
    
```

### 5. 思考题

如果我们在 `partitions` 中把 `yield p + [m]` 改成 `yield [m] + p`，会有什么问题？请举例说明。

```
会导致划分不是递增顺序。例如 `partitions(6,4)` 中，`[2,4]` 是正确的递增顺序；如果改成 `[4] + [2]` 得到 `[4,2]`，这就不符合递增要求，且会导致重复（如 `[4,2]` 和 `[2,4]` 被视为不同，但实际上它们表示同一个划分）。因此必须保证生成的列表是递增的。

```

---

## 七、总结与展望

生成器是 Python 中强大而优雅的特性，它让我们能够以惰性的方式处理序列和递归组合。本节课你学会了：

- 生成器函数的基本写法与执行过程。
    
- `yield from` 简化迭代器委托。
    
- 递归生成器的设计模式（倒计时、前缀、子串）。
    
- 用生成器解决整数划分问题，并理解其优势。
    

生成器不仅是高效的迭代工具，也是协程和异步编程的基础。在后续课程中，你将看到生成器如何用于流式数据处理、无限序列模拟以及实现轻量级并发。
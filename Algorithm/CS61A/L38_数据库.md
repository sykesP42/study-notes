# 📘 Lecture 38：数据库（可选

> 数据库是存储和管理结构化数据的核心工具，而 SQL 是操作数据库的标准语言。本节课将带你掌握 SQL 中的数据定义（CREATE/DROP TABLE）、数据操作（INSERT/UPDATE/DELETE），并学习如何在 Python 中通过 `sqlite3` 模块与 SQLite 数据库交互。最后，通过一个黑杰克游戏模拟案例，你将看到数据库如何用于多进程共享状态、数据持久化和策略分析。

---

## 一、创建和删除表格

### 1.1 创建表格：`CREATE TABLE`

在 SQL 中，`CREATE TABLE` 语句用于定义一个新的表结构，包括列名、数据类型以及约束条件。

**基本语法**：

```sql

CREATE TABLE [IF NOT EXISTS] table_name (
    column1 datatype [constraints],
    column2 datatype [constraints],
    ...
) [AS select_statement];
```
- `IF NOT EXISTS`：可选，如果表已存在则不会报错。
    
- 列定义：每个列需要指定名称和数据类型（如 `INT`, `TEXT`, `REAL` 等），还可以附加约束：
    
    - `PRIMARY KEY`：主键，唯一标识一行。
        
    - `UNIQUE`：列值不能重复。
        
    - `NOT NULL`：列值不能为空。
        
    - `DEFAULT value`：指定默认值。
        
    - `CHECK (condition)`：检查约束，确保列值满足条件。
        
- `AS select_statement`：可选，从查询结果直接创建并填充表（类似 `CREATE TABLE ... AS SELECT`）。
    

**临时表**：可在 `CREATE` 前加 `TEMPORARY` 或 `TEMP`，表只在当前连接会话中存在。

**示例**：创建一个存储质数的表

```sql

CREATE TABLE IF NOT EXISTS primes (
    n INT UNIQUE,           -- 数字，唯一
    prime INT DEFAULT 1      -- 是否为质数，1 表示是，0 表示否
);
```
这里 `DEFAULT 1` 表示如果不指定 `prime` 列的值，默认为 1。

### 1.2 删除表格：`DROP TABLE`

`DROP TABLE` 用于完全移除表及其所有数据，释放表名供以后使用。

**基本语法**：

```sql

DROP TABLE [IF EXISTS] table_name;
```
- 如果不加 `IF EXISTS` 而表不存在，会报错。建议在脚本中使用 `IF EXISTS` 避免错误。
    

**示例**：

```sql

DROP TABLE IF EXISTS primes;
```
### 1.3 修改表格数据

#### 插入数据：`INSERT INTO`

向表中添加新行。

**基本语法**：

```sql

INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...);
```
- 列名列表可选，如果省略，则必须为所有列提供值（按定义顺序）。
    
- 可以一次插入多行：用逗号分隔多组 `VALUES`。
    
- 也可以从 `SELECT` 查询结果插入：`INSERT INTO table_name SELECT ...`。
    

**示例**：

```sql

-- 插入单行，指定列
INSERT INTO primes (n) VALUES (2);
INSERT INTO primes (n) VALUES (3);
-- 插入多行
INSERT INTO primes (n) VALUES (4), (5), (6);
-- 从查询插入
INSERT INTO primes (n) SELECT value FROM another_table;
```
如果列有 `DEFAULT` 约束，未指定的列会自动使用默认值。例如 `prime` 默认为 1，所以上面插入的 `n=2` 等行，`prime` 列都是 1。

#### 更新数据：`UPDATE`

修改表中已有行的某些列。

**基本语法**：

```sql

UPDATE table_name SET column1 = value1, column2 = value2, ... WHERE condition;
```
- `WHERE` 子句指定要更新的行，如果省略，将更新所有行。
    
- 新值可以是固定值，也可以是表达式（如 `column = column + 1`）。
    

**示例**：标记所有大于 2 的偶数为非质数

```sql

UPDATE primes SET prime = 0 WHERE n > 2 AND n % 2 = 0;
```
此操作会将 `prime` 列从 1 改为 0 对于符合条件的行。

#### 删除数据：`DELETE`

删除表中的行。

**基本语法**：

```sql

DELETE FROM table_name WHERE condition;
```
- `WHERE` 指定要删除的行，如果省略，将删除表中**所有行**（但表结构保留）。
    
- 若想删除所有行，也可以使用 `TRUNCATE`，但 SQLite 不支持 `TRUNCATE`，只能用 `DELETE FROM table_name`。
    

**示例**：删除所有非质数记录

```sql

DELETE FROM primes WHERE prime = 0;
```
删除后，表中只保留质数。

**注意**：`DELETE` 只删除数据，表结构（列定义、索引等）依然存在。要彻底移除表，需用 `DROP TABLE`。

---

## 二、Python 与 SQL 的交互

Python 内置了 `sqlite3` 模块，可以轻松连接 SQLite 数据库并执行 SQL 语句。

### 2.1 连接数据库

```python

import sqlite3
# 连接数据库（如果文件不存在，会自动创建）
db = sqlite3.connect("mydb.db")
```
- `connect` 返回一个 `Connection` 对象，代表与数据库的连接。
    
- 可以指定内存数据库：`":memory:"`，用于临时测试。
    

### 2.2 执行 SQL 语句

使用 `execute()` 方法执行单条 SQL 语句。对于查询，返回一个 `Cursor` 对象，可以通过它获取结果。

```python

# 创建表
db.execute("CREATE TABLE IF NOT EXISTS nums (n INT)")
# 插入数据
db.execute("INSERT INTO nums VALUES (2), (3)")
# 使用参数化查询避免 SQL 注入（用 ? 作为占位符）
values = [(4,), (5,), (6,)]
db.executemany("INSERT INTO nums VALUES (?)", values)
# 查询
cursor = db.execute("SELECT * FROM nums")
rows = cursor.fetchall()   # 返回元组列表 [(2,), (3,), (4,), (5,), (6,)]
print(rows)
# 提交事务（修改数据的操作需要提交才能持久化）
db.commit()
```
### 2.3 事务管理

SQLite 默认是自动提交模式，但使用 `execute()` 执行修改语句时，实际上是在一个隐式事务中。为了确保数据持久化，需要调用 `commit()`。如果发生错误，可以调用 `rollback()` 撤销未提交的更改。

```python

try:
    db.execute("UPDATE nums SET n = n + 1 WHERE n = 2")
    db.commit()
except:
    db.rollback()
    raise
```
### 2.4 关闭连接

完成操作后，应关闭连接释放资源。

```python

db.close()
```
### 2.5 动态构建 SQL

Python 的字符串操作可以动态生成 SQL，但要小心 SQL 注入。始终使用参数化查询（`?`）传递值，而不是直接拼接字符串。

**错误示例**（易受注入攻击）：

```python

n = 5
db.execute(f"DELETE FROM nums WHERE n = {n}")   # 危险！
```
**正确示例**：

```python

db.execute("DELETE FROM nums WHERE n = ?", (n,))
```
---

## 三、数据库连接与并发

数据库管理系统（DBMS）能够处理多个程序同时连接到同一个数据库，进行读写操作，并保证数据的一致性和完整性。SQLite 支持多进程并发读，但写操作会锁定整个数据库（所以不适合高并发写）。其他 DBMS（如 PostgreSQL、MySQL）有更复杂的并发控制机制。

**多连接示例**：你可以在一个终端运行 Python 脚本，同时在另一个终端用 SQLite 命令行工具打开同一个数据库，两者可以实时看到对方的修改（取决于事务隔离级别）。

---

## 四、应用案例：黑杰克游戏模拟

本案例展示如何使用 SQLite 数据库来管理黑杰克（21点）游戏的牌局状态，支持多玩家（模拟多个客户端）共享数据。

### 4.1 游戏规则回顾

- 牌值：2-10 按面值，J/Q/K 为 10 点，A 可计为 1 或 11 点（自动选择对玩家有利的方式，但通常总分 ≤11 时计 11，否则计 1）。
    
- 初始发牌：玩家 2 张明牌，庄家 1 张明牌 + 1 张暗牌。
    
- 玩家轮流决策：可要牌（Hit）或停牌（Stand）。若要牌后总分 >21 则爆牌（Bust）直接输。
    
- 玩家停牌后，庄家翻开暗牌，并持续要牌直到总分 ≥17（有些规则是必须 ≥17 且硬 17 或软 17 有区别，本例简化）。
    
- 比较总分，高者胜，平局为 Push。
    

### 4.2 数据库设计

创建一个 `cards` 表，存储每张牌的信息：

```sql

CREATE TABLE cards (
    card TEXT,      -- 牌面字符串，如 '2♠', 'A♥'
    who TEXT        -- 当前持有者：'player', 'dealer', 'discard'（弃牌堆）
);
```
- 牌面包含数字/字母和花色，但计分时只需解析数字部分。
    
- `who` 字段记录当前牌在谁手中。
    

### 4.3 Python 实现

我们将实现以下函数：

- `deal()`：初始化牌局（洗牌、发牌）。
    
- `hand_score(who)`：计算指定玩家的手牌总分，处理 A 的特殊计分。
    
- `bust(who)`：判断玩家是否爆牌。
    
- 主游戏循环。
    

#### 初始化牌组

```python

import random
import sqlite3
def setup_db(db):
    db.execute("DROP TABLE IF EXISTS cards")
    db.execute("CREATE TABLE cards (card TEXT, who TEXT)")
def create_deck():
    """生成一副牌（52张，无大小王）"""
    suits = ['♠', '♥', '♦', '♣']
    ranks = ['2','3','4','5','6','7','8','9','10','J','Q','K','A']
    deck = [rank + suit for rank in ranks for suit in suits]
    random.shuffle(deck)
    return deck
```
#### 发牌

```python

def deal(db):
    """清空旧牌，重新发牌"""
    db.execute("DELETE FROM cards")
    deck = create_deck()
    # 玩家两张明牌
    for _ in range(2):
        card = deck.pop()
        db.execute("INSERT INTO cards (card, who) VALUES (?, 'player')", (card,))
    # 庄家一张明牌
    card = deck.pop()
    db.execute("INSERT INTO cards (card, who) VALUES (?, 'dealer_up')", (card,))
    # 庄家一张暗牌
    card = deck.pop()
    db.execute("INSERT INTO cards (card, who) VALUES (?, 'dealer_down')", (card,))
    # 剩余牌放入弃牌堆（这里简单处理，实际可以另建一个表或字段，但为了简化，剩余牌先不管）
    # 我们只关心手牌，剩余牌不记录，游戏结束后会丢弃所有牌。
    db.commit()
```
#### 计分函数

```python

def hand_score(db, who):
    """计算 who 的手牌总分，who 可以是 'player', 'dealer_up', 'dealer_down'，或 'dealer' 表示庄家所有牌"""
    # 查询指定 who 的所有牌
    if who == 'dealer':
        cursor = db.execute("SELECT card FROM cards WHERE who IN ('dealer_up', 'dealer_down')")
    else:
        cursor = db.execute("SELECT card FROM cards WHERE who = ?", (who,))
    cards = [row[0] for row in cursor.fetchall()]
    total = 0
    aces = 0
    for card in cards:
        rank = card[:-1]  # 去掉花色
        if rank in ['J','Q','K']:
            total += 10
        elif rank == 'A':
            aces += 1
            total += 11
        else:
            total += int(rank)
    # 调整 A 的值（如果超过 21，将 A 从 11 降为 1）
    while total > 21 and aces > 0:
        total -= 10
        aces -= 1
    return total
```
#### 判断爆牌

```python

def bust(db, who):
    return hand_score(db, who) > 21
```
#### 要牌函数

```python

def hit(db, who):
    """从弃牌堆取一张牌给 who（本例简化：随机生成新牌？实际应该从剩余牌中取，但剩余牌未记录，所以我们从一副新牌中随机抽一张作为要牌，这不符合真实游戏，但演示逻辑）"""
    # 真实实现需要维护剩余牌表。这里为简单，随机生成一张牌（忽略剩余牌计数）
    import random
    ranks = ['2','3','4','5','6','7','8','9','10','J','Q','K','A']
    suits = ['♠', '♥', '♦', '♣']
    card = random.choice(ranks) + random.choice(suits)
    db.execute("INSERT INTO cards (card, who) VALUES (?, ?)", (card, who))
    db.commit()
```
更好的实现是单独创建一个 `deck` 表存储剩余牌，每次要牌从 `deck` 中取一张，并更新 `deck`。但为了简化示例，我们采用简单版本。

#### 游戏主循环

```python

def play_blackjack(db):
    deal(db)
    print("你的手牌：")
    cursor = db.execute("SELECT card FROM cards WHERE who = 'player'")
    for row in cursor:
        print(row[0], end=' ')
    print("\n庄家明牌：")
    cursor = db.execute("SELECT card FROM cards WHERE who = 'dealer_up'")
    print(cursor.fetchone()[0])
    while True:
        action = input("要牌(h)或停牌(s)？")
        if action == 'h':
            hit(db, 'player')
            print("你拿到了新牌，现在手牌：")
            cursor = db.execute("SELECT card FROM cards WHERE who = 'player'")
            for row in cursor:
                print(row[0], end=' ')
            print()
            if bust(db, 'player'):
                print("爆牌！你输了。")
                break
        else:
            break
    if not bust(db, 'player'):
        # 庄家回合
        print("庄家回合。")
        # 翻开暗牌
        db.execute("UPDATE cards SET who='dealer_up' WHERE who='dealer_down'")
        print("庄家手牌：")
        cursor = db.execute("SELECT card FROM cards WHERE who='dealer_up'")
        for row in cursor:
            print(row[0], end=' ')
        print()
        while hand_score(db, 'dealer') < 17:
            hit(db, 'dealer_up')
            print("庄家要牌，新牌：", end='')
            cursor = db.execute("SELECT card FROM cards WHERE who='dealer_up' ORDER BY rowid DESC LIMIT 1")
            print(cursor.fetchone()[0])
            if bust(db, 'dealer'):
                print("庄家爆牌，你赢了！")
                break
        else:
            player_score = hand_score(db, 'player')
            dealer_score = hand_score(db, 'dealer')
            print(f"你的总分：{player_score}，庄家总分：{dealer_score}")
            if player_score > dealer_score:
                print("你赢了！")
            elif player_score < dealer_score:
                print("你输了！")
            else:
                print("平局。")
    # 牌局结束，将所有牌移至弃牌堆
    db.execute("UPDATE cards SET who='discard'")
    db.commit()
```
### 4.4 多连接交互

由于数据库文件可以被多个程序同时打开，你可以在另一个终端运行 SQLite 命令行工具，实时查看牌局状态。例如：

```bash

sqlite3 blackjack.db
sqlite> SELECT * FROM cards WHERE who!='discard';
```
这可以在游戏进行时看到当前玩家和庄家的手牌，体验数据库的共享特性。

### 4.5 策略与算牌

专业玩家会通过已出现的牌估算剩余牌中高牌（10/J/Q/K/A）的比例，从而调整决策。你可以通过查询弃牌堆（`who='discard'`）统计已出的高牌数量，辅助决策。但赌场禁止算牌，本案例仅作演示。

**作弊示例**（禁止）：

```sql

UPDATE cards SET card='A' WHERE who='player';
```
直接修改数据库会破坏游戏公平性。

---

## 五、知识点总结表

|知识点|核心内容|关键语法/示例|应用场景|
|---|---|---|---|
|**CREATE TABLE**|创建表结构，支持列约束和默认值|`CREATE TABLE primes (n INT UNIQUE, prime INT DEFAULT 1)`|初始化数据库|
|**DROP TABLE**|删除表结构及数据|`DROP TABLE IF EXISTS primes`|清理重建表|
|**INSERT INTO**|插入数据，支持单行/多行/查询插入|`INSERT INTO primes (n) VALUES (2), (3)`|添加数据|
|**UPDATE**|修改满足条件的行|`UPDATE primes SET prime=0 WHERE n%2=0`|批量更新|
|**DELETE**|删除满足条件的行|`DELETE FROM primes WHERE prime=0`|数据清理|
|**参数化查询**|使用 `?` 占位符避免 SQL 注入|`db.execute("SELECT * FROM nums WHERE n=?", (5,))`|安全执行 SQL|
|**事务提交**|修改数据后需 `commit()` 持久化|`db.commit()`|确保数据保存|
|**多连接并发**|多个程序可同时访问同一数据库|一个写多个读（SQLite）|协同处理|
|**黑杰克案例**|数据库管理牌局状态，支持实时查询|`cards` 表记录牌和持有者|游戏开发、状态共享|

---

## 六、自测题

### 1. 创建表

写出 SQL 语句创建一个 `students` 表，包含 `id`（整数，主键）、`name`（文本，非空）、`age`（整数，默认为 18）。

```sql

CREATE TABLE students (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    age INTEGER DEFAULT 18
);
```

### 2. 插入与更新

基于 `students` 表，写出 SQL：

- 插入一行：id=1, name='Alice', age=20。
    
- 将 Alice 的年龄改为 21。
    

```sql

INSERT INTO students (id, name, age) VALUES (1, 'Alice', 20);
UPDATE students SET age = 21 WHERE name = 'Alice';
```

### 3. Python 参数化查询

以下 Python 代码有何安全风险？如何改正？

```python

name = "Bob"
db.execute(f"SELECT * FROM students WHERE name = '{name}'")
```

ANS:

存在 SQL 注入风险，如果 `name` 包含特殊字符（如 `' OR '1'='1`），可能泄露所有数据。应使用参数化查询：

```python

db.execute("SELECT * FROM students WHERE name = ?", (name,))

```

### 4. 事务管理

为什么在修改数据后需要调用 `commit()`？如果不调用会发生什么？

<details> <summary>答案</summary>

`commit()` 将事务中的更改持久化到数据库文件。如果不调用，更改只在内存中，当连接关闭时会被丢弃。在自动提交模式下，每次 `execute` 后可能自动提交，但显式调用 `commit` 可以控制事务边界，确保一系列操作原子性。

</details>

### 5. 黑杰克计分

假设手牌有 `['A♠', 'K♥']`，计算总分。

<details> <summary>答案</summary>

A 先计 11，K 计 10，总和 21。如果 A 计 11 不爆，则总分 21。

</details>

### 6. 思考题

为什么 SQLite 不适合高并发写操作？什么情况下你会选择 SQLite 而不是更重的 DBMS（如 PostgreSQL）？

<details> <summary>提示</summary>

SQLite 写操作会锁定整个数据库，并发写性能差。但 SQLite 轻量、零配置、适合嵌入式应用、移动应用或低并发的桌面软件。对于高并发 Web 服务，应选择 PostgreSQL、MySQL 等。

</details>

---

## 七、总结与展望

本节课我们深入学习了 SQL 中的数据定义和数据操作语句，掌握了如何通过 Python 与 SQLite 交互，并通过黑杰克游戏案例体验了数据库在实际项目中的应用。你学会了：

- 创建、删除表以及插入、更新、删除数据。
    
- 参数化查询的重要性。
    
- 事务管理的基本概念。
    
- 数据库并发访问的简单认识。
    
- 用数据库管理游戏状态，实现多连接共享。
    

数据库是软件开发中不可或缺的一部分，掌握这些基础将为你后续学习更复杂的数据库系统（如关系型数据库设计、ORM 框架）打下坚实基础。
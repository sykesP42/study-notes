# 📘 Lecture 39：最终示例 —— 树与函数设计

> 在本课程的最后一讲，我们将通过两个树处理问题来综合运用所学知识，并引入系统化的函数设计方法。你将看到如何用递归思维解决“统计大于所有祖先的节点”和“找出小于所有后代的非叶节点”这两个问题。同时，我们将借鉴《如何设计程序》（HtDP）中的六步设计流程，培养规范的编程习惯。

---

## 一、树形结构数据回顾

### 1.1 树的两种表示方法

在之前的课程中，我们学习了两种表示树的方式：**函数式抽象**（使用列表）和**面向对象**（使用类）。

#### 列表抽象


```python

def tree(label, branches=[]):
    return [label] + list(branches)
def label(t):
    return t[0]
def branches(t):
    return t[1:]
def is_leaf(t):
    return not branches(t)
```
#### 类实现

```python

class Tree:
    def __init__(self, label, branches=[]):
        self.label = label
        self.branches = list(branches)
    def is_leaf(self):
        return not self.branches
```
类实现更符合面向对象风格，属性直接通过 `self.label` 和 `self.branches` 访问，无需额外选择器函数。

### 1.2 树的普遍性

树结构在计算机科学中无处不在：

- **嵌套列表**：如 `[1, [2, [3, 4]]]`
    
- **Scheme 表达式**：如 `(+ (* 3 4) 5)` 本身就是一棵树（操作符为根，操作数为子树）
    
- **句法分析树**：句子分解为名词短语、动词短语等
    
- **HTML/XML 文档**：标签嵌套形成 DOM 树
    

理解树的关键在于：**任何由部分组成，且部分本身也是同样结构的对象，都可以视为树**。这种递归定义使得树的处理通常也是递归的。

---

## 二、问题一：`bigs` —— 统计大于所有祖先的节点

### 2.1 问题描述

给定一棵整数标签的树，统计其中**标签大于其所有祖先节点标签**的节点个数。注意：

- 根节点没有祖先，因此默认计入结果。
    
- “祖先”包括从根到当前节点路径上的所有节点（不包括当前节点本身）。
    

### 2.2 示例分析

考虑如下树：

```text

        1
      /   \
     4     3
    / \    |
   4   5   0
           |
           2
```
用代码表示为：

```python

a = Tree(1, [Tree(4, [Tree(4), Tree(5)]), Tree(3, [Tree(0, [Tree(2)])])])
```
**手动计算**：

- 根节点 1：没有祖先 → **计入**
    
- 节点 4（第一个）：祖先只有 1，4 > 1 → **计入**
    
- 节点 4（第二个）：祖先为 1 和 4（第一个），4 不大于 4 → **不计入**
    
- 节点 5：祖先为 1 和 4，5 > 1 且 5 > 4 → **计入**
    
- 节点 3：祖先为 1，3 > 1 → **计入**
    
- 节点 0：祖先为 1 和 3，0 不大于 3 → **不计入**
    
- 节点 2：祖先为 1、3、0，2 不大于 3 → **不计入**
    

总计 4 个节点，符合示例输出。

**关键观察**：需要比较当前节点与**所有**祖先节点，而不仅仅是父节点。因此递归时需要传递当前路径上的**最大值**。

### 2.3 解决方案一：辅助函数传递最大祖先值

我们可以定义一个辅助函数 `f(t, max_ancestor)`，它接收当前子树和当前路径上的最大祖先值，返回该子树中符合条件的节点数。

```python

def bigs(t):
    def f(t, max_ancestor):
        if t.label > max_ancestor:
            # 当前节点满足条件，计数 1
            count = 1
            new_max = t.label
        else:
            count = 0
            new_max = max_ancestor
        # 递归处理所有分支，将它们的计数累加
        for b in t.branches:
            count += f(b, new_max)
        return count
    # 初始时，根节点的最大祖先设为比根节点标签小的值，确保根节点被计入
    # 由于标签是整数，可以用 t.label - 1，或者用负无穷（如 float('-inf')）
    return f(t, t.label - 1)
```
**递归过程分析**（以节点 4 为例）：

- 调用 `f(节点4, max_ancestor=1)`，因为 4 > 1，所以计数 1，更新 `new_max=4`。
    
- 递归处理它的两个子节点（4 和 5），分别传入 `new_max=4`。
    
    - 子节点 4：4 不大于 4，计数 0，`new_max` 仍为 4。
        
    - 子节点 5：5 > 4，计数 1，更新 `new_max=5`。
        
- 返回 1+0+1=2，加上父节点自身的 1，最终节点 4 子树贡献 3？等等，注意我们的 `f` 返回值是包括当前节点在内的子树的总计数。在节点 4 的 `f` 中，当前节点 4 计数 1，加上子节点返回的 0+1=1，所以节点 4 子树共 2 个（4 和 5）。然后回到根节点，根节点计数 1，加上两个子树的计数（节点4子树 2，节点3子树 1？节点3子树包括 3 本身（计数1）和它的后代（0 不计，2 不计），所以共 1），总和 1+2+1=4。正确。
    

### 2.4 解决方案二：使用可变列表累积结果

另一种常见模式是在递归过程中通过一个**可变对象**（如列表）来累积结果，这样无需返回值。这种方法在某些情况下更符合“自上而下”的思考方式。

```python

def bigs(t):
    result = [0]          # 使用列表包装可变整数
    def traverse(t, max_ancestor):
        if t.label > max_ancestor:
            result[0] += 1
            new_max = t.label
        else:
            new_max = max_ancestor
        for b in t.branches:
            traverse(b, new_max)
    traverse(t, t.label - 1)
    return result[0]
```
这里 `result` 是一个列表，我们通过修改 `result[0]` 来更新计数，避免了返回值。两种方法各有优劣，但核心思想相同：在遍历过程中传递当前路径的最大值。

### 2.5 时间复杂度与空间复杂度

- 时间复杂度：O(n)，每个节点访问一次。
    
- 空间复杂度：O(h)，其中 h 为树的高度，递归调用栈深度。
    

---

## 三、问题二：`smalls` —— 返回小于所有后代的非叶节点

### 3.1 问题描述

实现 `smalls(t)`，返回树中所有**非叶节点**（即有至少一个分支的节点）中，**标签小于其所有后代节点标签**的节点列表（返回节点本身，而非标签）。例如：

```python

a = Tree(1, [Tree(2, [Tree(4), Tree(5)]), Tree(3, [Tree(0, [Tree(6)])])])
result = smalls(a)
# 结果应为两个节点：标签为 2 的节点和标签为 0 的节点
# 注意：结果返回的是节点对象，因此可以用列表推导提取标签验证
sorted([t.label for t in result])   # [0, 2]
```
### 3.2 示例分析

树结构：

```text

        1
      /   \
     2     3
    / \    |
   4   5   0
           |
           6
```
- 根节点 1：非叶节点，后代最小值是 0，1 不小于 0 → 不满足。
    
- 节点 2：非叶节点，后代最小值是 4（4 和 5 中的最小值），2 < 4 → 满足。
    
- 节点 3：非叶节点，后代最小值是 0（6 和 0 中的最小值），3 不小于 0 → 不满足。
    
- 节点 0：非叶节点，后代只有 6，0 < 6 → 满足。
    
- 叶节点 4、5、6 不参与（因为要求非叶节点）。
    

### 3.3 设计步骤（HtDP 方法）

我们将遵循《如何设计程序》中的六步设计流程：

#### 第一步：数据定义

已经明确：输入是一棵整数标签的树（`Tree` 类），输出是树的节点列表。无需额外数据定义。

#### 第二步：签名、目的声明、函数头

```python

def smalls(t):
    """返回树 t 中所有非叶节点中，标签小于其所有后代标签的节点列表。
    参数 t: Tree
    返回值: list of Tree
    """
```
#### 第三步：功能示例

上面已给出示例，可作为测试用例。

#### 第四步：设计模板

树处理的一般模板：

- 如果是叶节点，直接返回某种基本值。
    
- 如果是非叶节点，递归处理每个分支，然后组合结果。
    

对于本问题，我们需要在递归过程中**同时**做两件事：

1. 计算当前节点的后代最小值（用于判断当前节点是否应加入结果）。
    
2. 根据后代最小值决定是否将当前节点加入结果列表。
    

我们可以设计一个辅助函数 `process(t)`，它返回以 `t` 为根的子树中的**最小标签值**，同时（作为副作用）将满足条件的节点添加到结果列表中。

#### 第五步：实现

```python

def smalls(t):
    result = []
    def process(t):
        # 处理叶节点
        if t.is_leaf():
            return t.label
        # 处理非叶节点
        # 先递归处理所有分支，得到每个分支的最小值
        branch_mins = [process(b) for b in t.branches]
        # 当前子树的最小值 = min(当前节点标签, 所有分支的最小值)
        subtree_min = min([t.label] + branch_mins)
        # 判断当前节点是否应加入结果：当前标签小于所有后代标签
        # 即当前标签小于所有分支的最小值（因为后代最小值就是分支的最小值）
        if t.label < min(branch_mins):
            result.append(t)
        return subtree_min
    process(t)
    return result
```
**关键点**：

- `process` 的返回值是子树的最小标签，这个值会被父节点用来比较。
    
- 对于非叶节点，我们比较当前标签与**所有分支的最小值**，如果当前标签更小，则满足条件。
    
- 注意：`min(branch_mins)` 可能会抛出 `ValueError` 如果分支为空（但非叶节点至少有一个分支），所以安全。
    
- 结果列表 `result` 通过闭包被 `process` 访问，这是可变对象累积的另一种形式。
    

#### 第六步：测试

使用示例测试：

```python

a = Tree(1, [Tree(2, [Tree(4), Tree(5)]), Tree(3, [Tree(0, [Tree(6)])])])
res = smalls(a)
print(sorted([n.label for n in res]))  # [0, 2]
```
### 3.4 复杂度分析

- 时间复杂度：O(n)，每个节点访问一次。
    
- 空间复杂度：O(h)，递归栈深度。
    

---

## 四、函数设计的一般原则（HtDP 六步法）

1. **数据定义**：明确需要表示的信息以及如何用编程语言表示。
    
2. **签名、目的声明、函数头**：说明函数输入输出类型，以及一句话描述函数行为。
    
3. **功能示例**：给出具体例子说明函数预期行为。
    
4. **设计模板**：根据数据结构推导出递归骨架。
    
5. **实现**：填写模板中的空白，完成函数。
    
6. **测试**：用示例验证，并考虑边界情况。
    

这种系统化的方法尤其适合处理递归数据结构和复杂问题，能帮助我们在编码前理清思路，减少错误。

---

## 五、知识点总结表

|知识点|核心内容|考试重点 / 易混淆点|难度|
|---|---|---|---|
|**树的两种表示**|列表抽象（`tree` 函数） vs 类（`Tree`）|选择器 vs 属性访问|⭐⭐|
|**树递归通用模式**|处理当前节点，然后递归处理所有分支|根节点特殊处理；返回值聚合 vs 参数传递|⭐⭐⭐|
|**`bigs` 问题**|统计大于所有祖先的节点数|需要传递当前路径最大值；根节点初始值设定|⭐⭐⭐|
|**`smalls` 问题**|返回小于所有后代的非叶节点|同时计算子树最小值并收集结果|⭐⭐⭐⭐|
|**可变累积对象**|使用列表包装可变值，在递归中修改|与返回值累积的区别|⭐⭐|
|**HtDP 设计步骤**|六步设计法：数据定义 → 签名 → 示例 → 模板 → 实现 → 测试|模板推导的重要性|⭐⭐⭐|

---

## 六、自测题

### 1. 理解 `bigs`

对于以下树：

```text

    5
   / \
  3   7
     / \
    6   8
```
手动计算 `bigs` 的结果，并用代码验证。

 - 5：根，计入 
 - 3：祖先 5，3<5，不计 
 - 7：祖先 5，7>5，计入 
 - 6：祖先 5,7，6<7，不计 
 - 8：祖先 5,7，8>7，计入 结果：5,7,8 → 3 

### 2. 实现 `bigs` 的另一种方式

不使用辅助函数，直接在原函数中递归并传递一个默认参数，如何实现？

```python

def bigs(t, max_ancestor=None):
    if max_ancestor is None:
        max_ancestor = t.label - 1
    count = 1 if t.label > max_ancestor else 0
    new_max = max(max_ancestor, t.label) if count else max_ancestor
    for b in t.branches:
        count += bigs(b, new_max)
    return count
```
注意：这里用 `new_max` 的更新需要小心：无论当前节点是否计入，都要传递正确的最大值。更简单的写法是 `new_max = max(max_ancestor, t.label)`，因为即使当前节点不计入，也可能比祖先大（但这里不计入意味着当前节点不大于祖先，所以 `max(max_ancestor, t.label) = max_ancestor`，实际上一样）。因此可以统一用 `new_max = max(max_ancestor, t.label)`。


### 3. `smalls` 变体

如果要求返回这些节点的标签列表，而不是节点本身，如何修改 `smalls` 函数？



只需将 `result.append(t)` 改为 `result.append(t.label)`，并修改返回值为 `result`。其他不变。

 

### 4. 设计练习

按照 HtDP 六步法，设计一个函数 `count_leaves(t)`，返回树中叶子节点的个数。


1. 数据定义：树 `Tree`
    
2. 签名：`Tree -> int`，目的：返回树中叶子节点个数
    
3. 示例：`t = Tree(1, [Tree(2), Tree(3)])` 应返回 2
    
4. 模板：
    
    - 如果是叶子，返回 1
        
    - 否则，返回各分支叶子数之和
        
5. 实现：
    
    ```python
    
    def count_leaves(t):
        if t.is_leaf():
            return 1
        else:
            return sum(count_leaves(b) for b in t.branches)
    ```
1. 测试
    



### 5. 思考题

在 `bigs` 的第二种实现中，我们使用了列表 `result = [0]` 来累积结果。为什么不能用普通的整数变量？请解释。

<details> <summary>提示</summary>

Python 中整数是不可变类型，在函数内修改外层整数的副本不会影响外层变量。而列表是可变对象，修改其元素会反映到外部。因此，如果要用普通整数，需要将其作为返回值传递并累加，而不能在递归中直接修改。

</details>

---

## 七、总结与展望

本节课是 61A 的最后一讲，我们通过两个树处理问题回顾了递归、可变对象、函数设计等重要概念，并引入了系统化的设计方法。这些知识将帮助你应对更复杂的编程挑战，并为后续课程（如数据结构、算法、编程语言原理）打下坚实基础。

**祝贺你完成全部 39 节课程的学习！** 希望这些笔记能成为你未来编程道路上的有力工具。记住，编程不仅是写代码，更是解决问题的艺术。祝你在计算机科学的世界里继续探索，享受创造的乐趣！
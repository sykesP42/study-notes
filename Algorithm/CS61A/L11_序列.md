# 📘 Lecture 11：序列（列表、range、for循环与列表推导）

> 序列是Python中最基本的数据结构之一。本章将深入介绍列表（list）的创建、索引、操作，以及用于遍历序列的 `for` 循环和用于生成整数序列的 `range` 类型。最后，我们将学习列表推导式——一种简洁而强大的构建列表的方式。

---

## 一、列表基础

### 1. 创建列表

列表是Python内置的可变序列类型，用方括号 `[]` 表示，元素之间用逗号分隔。


```python

# 字面量创建
odds = [41, 43, 47, 49]
# 空列表
empty = []
# 列表元素可以是任意类型，甚至混合类型
mixed = [42, 'hello', 3.14, True]
```
- 列表可以包含零个或多个元素。
    
- 元素可以是数值、字符串、布尔值，甚至是其他列表（嵌套列表）。
    

### 2. 列表元素选择

#### 基本索引

Python使用**从0开始的整数索引**访问列表元素。索引的本质是偏移量：`0` 表示第一个元素，`1` 表示第二个，依此类推。

```python

>>> odds = [41, 43, 47, 49]
>>> odds[0]
41
>>> odds[1]
43
>>> odds[2]
47
>>> odds[3]
49
```
最后一个元素的索引是 `len(odds) - 1`。

```python

>>> len(odds)
4
```
#### 表达式索引

索引位置可以是任意整数表达式，Python会先计算表达式，再使用结果作为索引。

```python

>>> odds[3 - 2]   # 等价于 odds[1]
43
>>> odds[odds[3] - odds[2]]   # odds[3]=49, odds[2]=47, 49-47=2 → odds[2]=47
47
```
**执行顺序**：先计算列表表达式（如 `odds`），再计算索引表达式，最后进行元素查找。

#### 使用 `getitem` 函数

`operator` 模块提供了 `getitem` 函数，功能与索引语法相同。

```python

>>> from operator import getitem
>>> getitem(odds, 3)
49
```
### 3. 列表的连接与重复

- **连接**（`+`）：将两个列表合并成一个新列表。
    
- **重复**（`*`）：将列表重复多次，生成新列表。
    

```python

>>> [2, 7] + odds
[2, 7, 41, 43, 47, 49]
>>> odds * 2
[41, 43, 47, 49, 41, 43, 47, 49]
>>> [2, 7] + odds * 2
[2, 7, 41, 43, 47, 49, 41, 43, 47, 49]
```
同样可以使用 `operator` 模块的 `add` 和 `mul` 函数实现相同功能。

```python

>>> from operator import add, mul
>>> add([2, 7], odds)
[2, 7, 41, 43, 47, 49]
>>> mul(odds, 2)
[41, 43, 47, 49, 41, 43, 47, 49]
```
### 4. 嵌套列表

列表的元素可以是任何类型，包括列表本身，从而形成多维结构。

```python

>>> pairs = [[1, 2], [3, 4], [5, 6]]
>>> pairs[0]        # 第一个元素是 [1, 2]
[1, 2]
>>> pairs[0][1]     # 第一个元素的第二个分量
2
```
访问嵌套元素需要链式索引：`pairs[i][j]`。

### 5. 成员检测：`in` 和 `not in`

使用 `in` 运算符判断某个元素是否存在于列表中。

```python

>>> digits = [1, 8, 2, 8]
>>> 1 in digits
True
>>> 5 in digits
False
>>> 5 not in digits
True
```
**注意**：

- `in` 进行的是**值相等**比较，**类型敏感**。例如，字符串 `'1'` 与整数 `1` 不相等，因此 `'1' in [1, 8, 2]` 返回 `False`。
    
- `in` 只检查顶层元素，不会递归搜索子列表。例如 `[1, 8] in [1, [1, 8], 2]` 返回 `True`，但 `[1, 8] in [1, 8, 2]` 返回 `False`，因为顶层没有 `[1, 8]` 这个元素。
    

```python

>>> [1, 8] in [1, [1, 8], 2]
True
>>> [1, 8] in [1, 8, 2]
False
```
---

## 二、遍历列表：`for` 循环

### 1. `for` 语句的基本结构

`for` 循环是遍历序列（如列表、字符串、range）的常用工具。

```python

for <变量名> in <可迭代对象>:
    <语句块>
```
**执行过程**：

1. 计算 `<可迭代对象>` 的值，它必须是一个可迭代的序列（如列表）。
    
2. 依次将序列中的每个元素绑定到 `<变量名>`，并执行一次 `<语句块>`。
    
3. 循环结束后继续执行后续代码。
    

> ⚠️ `for` 循环**不会创建新的帧**，变量绑定在当前环境的第一帧中。这意味着循环结束后，变量仍然存在，并持有最后一个元素的值（除非在循环内被修改）。

### 2. 示例：计数函数

使用 `for` 循环统计某个值在列表中出现的次数。

```python

def count(s, value):
    """返回序列 s 中 value 出现的次数"""
    total = 0
    for element in s:
        if element == value:
            total += 1
    return total
```
与 `while` 版本对比：

```python

def count_while(s, value):
    total, index = 0, 0
    while index < len(s):
        if s[index] == value:
            total += 1
        index += 1
    return total
```
显然，`for` 循环更简洁，无需手动管理索引。

### 3. 序列解包在 `for` 循环中

当列表的元素本身是固定长度的序列（如二元组或两个元素的列表）时，可以在 `for` 语句中直接解包。

```python

pairs = [[1, 2], [2, 2], [3, 2], [4, 4]]
same_count = 0
for x, y in pairs:
    if x == y:
        same_count += 1
print(same_count)   # 输出 2
```
**工作原理**：每次迭代时，将当前元素（如 `[1, 2]`）解包，第一个值赋给 `x`，第二个值赋给 `y`。这类似于多重赋值：`x, y = [1, 2]`。

> 要求所有子序列长度一致，否则会引发 `ValueError`。

### 4. 忽略循环变量：使用 `_`

如果循环中不需要使用变量本身，可以使用下划线 `_` 作为变量名，表明该值被有意忽略。

```python

def cheer(n):
    for _ in range(n):
        print('Go Bears!')
```
- `_` 只是一个合法的变量名，按约定表示“不关心这个值”。
    
- 使用 `_` 可以避免未使用变量的警告，并提高代码可读性。
    

---

## 三、`range` 类型

### 1. 基本概念

`range` 表示一个不可变的整数序列，通常用于 `for` 循环中指定循环次数。它的特点是**左闭右开**：包含起始值，不包含结束值。

### 2. 创建方式

- `range(stop)`：从 0 开始到 `stop-1` 的整数序列。
    
- `range(start, stop)`：从 `start` 到 `stop-1`。
    
- `range(start, stop, step)`：步长为 `step`（可为负数）。
    

```python

>>> list(range(5))
[0, 1, 2, 3, 4]
>>> list(range(2, 5))
[2, 3, 4]
>>> list(range(2, 10, 2))
[2, 4, 6, 8]
>>> list(range(5, 0, -1))
[5, 4, 3, 2, 1]
```
### 3. 转换为列表

`range` 本身是惰性求值的，不立即生成所有元素。使用 `list()` 可以将其转换为列表，便于查看具体内容。

```python

>>> r = range(3, 8)
>>> r
range(3, 8)
>>> list(r)
[3, 4, 5, 6, 7]
```
### 4. 应用示例

#### 例1：`sum_below(n)`

计算 0 到 `n-1` 的和。

```python

def sum_below(n):
    total = 0
    for i in range(n):
        total += i
    return total
```
`range(n)` 生成 `0, 1, ..., n-1`，正好满足需求。

#### 例2：`cheer(n)`

重复打印 `n` 次 `'Go Bears!'`，无需使用循环变量。

python

def cheer(n):
    for _ in range(n):
        print('Go Bears!')

---

## 四、列表推导式

列表推导式（List Comprehension）提供了一种简洁的创建列表的方式，通常比 `for` 循环更紧凑、更易读。

### 1. 基本语法

```python

[<表达式> for <元素> in <可迭代对象>]
```
新列表的每个元素是 `<表达式>` 对 `<可迭代对象>` 中每个元素计算的结果。

**示例**：将列表 `odds` 中的每个元素加 1。

```python

>>> odds = [41, 43, 47, 49]
>>> [x + 1 for x in odds]
[42, 44, 48, 50]
```
### 2. 条件筛选

可以在推导式末尾添加 `if` 子句，只保留满足条件的元素。

```python

[<表达式> for <元素> in <可迭代对象> if <条件>]
```
**示例**：从一个列表中选出所有偶数并平方。

```python

>>> nums = [1, 2, 3, 4, 5, 6]
>>> [x**2 for x in nums if x % 2 == 0]
[4, 16, 36]
```
**执行顺序**：先 `for` 循环，然后 `if` 判断，最后计算表达式。可以理解为嵌套的 `for` 和 `if`。

### 3. 多重循环与嵌套

列表推导式可以包含多个 `for` 子句，相当于嵌套循环。

```python

>>> [x + y for x in [1, 2] for y in [10, 20]]
[11, 21, 12, 22]

这等价于：

python

result = []
for x in [1, 2]:
    for y in [10, 20]:
        result.append(x + y)
```
### 4. 与 `for` 循环的对比

|方法|代码|特点|
|---|---|---|
|`for` 循环|`result = []`  <br>`for x in lst:`  <br>    `result.append(x+1)`|步骤清晰，适合复杂操作|
|列表推导|`[x+1 for x in lst]`|简洁，适合简单变换|

**选择原则**：当变换逻辑简单且意图明确时，优先使用列表推导；当需要复杂处理或副作用时，使用 `for` 循环。

---

## 五、常见错误与陷阱

1. **索引越界**  
    访问不存在的索引会引发 `IndexError`。确保索引在 `0` 到 `len(list)-1` 范围内。
    
2. **修改列表时遍历**  
    如果在遍历列表的同时增删元素，可能导致意想不到的结果或错误。后续课程会详细介绍。
    
3. **误用 `in` 检查子列表**  
    `in` 只检查顶层元素，不会递归查找。例如 `[1, 2] in [1, 2, 3]` 是 `False`。
    
4. **range 的结束值**  
    记住 `range(start, stop)` 不包含 `stop`，这是 Python 的常见设计（方便与 `len` 配合）。
    
5. **列表推导中的变量泄漏**  
    在 Python 2 中，列表推导的循环变量会泄漏到外部作用域；但在 Python 3 中，列表推导有自己的局部作用域，不会泄漏。不过，变量名仍可能覆盖外部变量，需注意命名。
    

---

## 六、知识点总结表

|知识点|核心内容|考试重点 / 易混淆点|难度|
|---|---|---|---|
|**列表创建**|用方括号 `[]` 创建，元素任意|字面量与赋值绑定|⭐|
|**索引与切片**|0-based，索引可为表达式|最后一个元素索引为 `len-1`；`getitem` 函数|⭐⭐|
|**连接与重复**|`+` 和 `*` 运算符，返回新列表|也可用 `add` 和 `mul` 函数|⭐|
|**嵌套列表**|列表元素可为列表，形成多维结构|访问方式：`lst[i][j]`|⭐⭐|
|**成员检测**|`in` / `not in`，值相等且类型敏感|不递归搜索子列表|⭐⭐|
|**`for` 循环**|遍历可迭代对象，自动绑定元素|不创建新帧，变量在外部可见|⭐⭐|
|**序列解包**|`for x, y in pairs` 解包子序列|要求所有子序列长度一致|⭐⭐|
|**`range`**|表示整数序列，左闭右开|`range(n)` 生成 0~n-1；`list()` 查看内容|⭐⭐|
|**列表推导**|`[expr for elem in iter if cond]`|多重 `for` 的顺序；条件过滤|⭐⭐⭐|
|**忽略变量**|用 `_` 表示循环变量不被使用|约定俗成，不强制|⭐|

---

## 七、自测题

### 1. 基础操作

给定 `lst = [2, 4, 6, 8]`，写出下列表达式的值：

- `lst[1]`
    
- `lst[1 + 2]`
    
- `lst[-1]`
    
- `len(lst)`
    
- `lst * 2`
    
- `[3] + lst`
    
ANS:
- `lst[1]` → `4`
    
- `lst[1 + 2]` → `lst[3]` → `8`
    
- `lst[-1]` → `8`（最后一个元素）
    
- `len(lst)` → `4`
    
- `lst * 2` → `[2, 4, 6, 8, 2, 4, 6, 8]`
    
- `[3] + lst` → `[3, 2, 4, 6, 8]`
    



### 2. 成员检测

判断下列表达式的值：

- `3 in [1, 2, 3]`
    
- `[1, 2] in [1, 2, 3, 4]`
    
- `'2' in [2, 3, 4]`
    
- `[2] in [1, [2], 3]`
    

ans:
- `True`
    
- `False`（顶层没有 `[1,2]` 这个元素）
    
- `False`（`'2'` 是字符串，列表中元素是整数 2）
    
- `True`（顶层有 `[2]` 这个元素）
    



### 3. `for` 循环与 `range`

写一个函数 `sum_squares(n)`，返回 `1^2 + 2^2 + ... + n^2` 的值。

ans:
```
python

def sum_squares(n):
    total = 0
    for i in range(1, n+1):
        total += i * i
    return total
```

### 4. 序列解包

已知 `pairs = [(1, 2), (3, 4), (5, 6)]`，使用 `for` 循环和序列解包打印出每个元组的和。

```python

for a, b in pairs:
    print(a + b)
```
输出：

```text

3
7
11
```

### 5. 列表推导

用列表推导生成 `[1, 4, 9, 16, 25, 36]`（即 1 到 6 的平方）。

```python

[x**2 for x in range(1, 7)]
```

### 6. 带条件的列表推导

从列表 `[1, 2, 3, 4, 5, 6]` 中选出所有能被 3 整除的数，并乘以 10。

```python

[x * 10 for x in [1,2,3,4,5,6] if x % 3 == 0]
```
结果：`[30, 60]`


### 7. 思考题

为什么 `range` 设计为左闭右开？这种设计有什么好处？

<details> <summary>提示</summary>

左闭右开区间与 Python 的 0-based 索引一致，使得 `range(len(lst))` 直接生成所有有效索引，并且可以方便地计算长度（`stop - start`）。它也便于分割序列，例如 `range(5,10)` 和 `range(10,15)` 不重叠。

</details>

---

## 八、总结与展望

本节课我们学习了 Python 中最常用的序列类型——列表，以及如何遍历、检测和生成序列。`for` 循环和 `range` 是控制迭代的基础工具，而列表推导式则提供了一种高效、简洁的构建列表的方式。这些知识是后续学习数据抽象、字典、集合和更复杂算法的基石。在下一讲中，我们将探索列表的可变性及其带来的影响。
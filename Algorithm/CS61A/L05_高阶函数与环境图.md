# 📘 Lecture 5：高阶函数与环境图 

> 本笔记从高阶函数的执行过程入手，深入剖析环境图的绘制与解读，系统讲解嵌套函数、闭包、函数组合、lambda 和柯里化。环境图是理解 Python 执行模型的核心工具，掌握它你就能真正“看到”代码如何运行。

---

## 一、高阶函数与环境示意图

### 1. 高阶函数的定义

> **高阶函数**（Higher-Order Function）是指满足以下至少一个条件的函数：
> 
> - 接受一个或多个函数作为参数
>     
> - 返回一个函数作为结果
>     

高阶函数让我们能够抽象出通用的计算模式，将具体操作委托给传入的函数。

### 2. 示例：`apply_twice`

```python

def apply_twice(f, x):
    """返回 f(f(x)) 的结果"""
    return f(f(x))
def square(x):
    return x * x
result = apply_twice(square, 2)   # 结果：16

```
- `apply_twice` 接受一个函数 `f` 和一个值 `x`，然后调用 `f` 两次：先对 `x` 应用 `f`，再对结果应用 `f`。
    
- 这里 `square` 作为参数传入，体现了高阶函数的特性。
    

### 3. 环境图逐步分析

#### 初始状态（执行 `def` 语句后）

- 全局帧（Global frame）中绑定了两个函数名：`apply_twice` 和 `square`。每个函数对象都有一个 `parent` 指针指向定义时的环境（这里是全局帧）。
    

#### 调用 `apply_twice(square, 2)`

1. **创建局部帧**：以 `apply_twice` 为名创建一个新帧（记为 f1），其父帧为全局帧。
    
2. **绑定形参**：在 f1 中，`f` 绑定到函数对象 `square`，`x` 绑定到 `2`。
    
3. **执行函数体**：`return f(f(x))` 需要分步求值：
    
    - 首先求值 `f(x)`：在当前环境（f1）中查找 `f` 得到 `square`，查找 `x` 得到 `2`，调用 `square(2)`。
        
        - 为 `square(2)` 创建新帧 f2（父帧为全局帧），形参 `x` 绑定到 `2`。
            
        - 执行 `return x * x`，在 f2 中找到 `x=2`，返回 `4`。f2 销毁。
            
    - 然后求值 `f(4)`：再次查找 `f`（在 f1 中得到 `square`），调用 `square(4)`。
        
        - 创建新帧 f3（父帧全局），`x` 绑定到 `4`，返回 `16`。f3 销毁。
            
    - 最终 `f(f(x))` 得到 `16`，返回给调用者。
        
4. **绑定返回值**：全局帧中 `result` 绑定到 `16`。
    

#### 环境图关键点

- 每次函数调用都会创建新的局部帧，帧的父帧是被调用函数的 `parent` 属性（即定义时的环境）。
    
- 名称查找从当前帧开始，沿父帧链向上，直到找到第一个绑定。
    
- 函数参数传递是通过形参绑定到实参值实现的，不是“共享变量”。
    

---

## 二、嵌套定义的环境

### 1. 示例：`make_adder`

```python

def make_adder(n):
    """返回一个函数，该函数接受参数 k 并返回 k + n"""
    def adder(k):
        return k + n
    return adder
add_three = make_adder(3)
print(add_three(4))   # 输出 7
```
- `make_adder` 是一个高阶函数，它返回内部定义的函数 `adder`。
    
- `adder` 引用了外部函数的参数 `n`，这形成了**闭包**。
    

### 2. 环境图分析

#### 执行 `make_adder(3)`

1. 创建新帧 f1（父帧为全局），形参 `n` 绑定到 `3`。
    
2. 在 f1 中执行 `def adder(k):`，创建函数对象 `adder`，其 `parent` 指向当前帧 f1（因为定义时所在环境是 f1）。
    
3. 将名称 `adder` 绑定到该函数对象（在 f1 中）。
    
4. 返回 `adder` 函数对象，f1 并未销毁（因为返回的函数需要保留其环境）。
    
5. 在全局帧中，`add_three` 绑定到返回的 `adder` 函数。
    

#### 调用 `add_three(4)`

1. 创建新帧 f2，以 `adder` 为名（父帧为 `adder` 的 `parent`，即 f1）。
    
2. 形参 `k` 绑定到 `4`。
    
3. 执行 `return k + n`：
    
    - 查找 `k`：在当前帧 f2 中找到 `k=4`。
        
    - 查找 `n`：当前帧 f2 中没有 `n`，到父帧 f1 中查找，找到 `n=3`。
        
4. 计算 `4+3=7`，返回。f2 销毁，f1 仍然存在（可能还有其他引用）。
    

#### 闭包的核心

- 内部函数 `adder` 携带了定义时的环境（帧 f1），因此即使 `make_adder` 调用结束，f1 仍然被 `adder` 引用而存活。
    
- 这种“函数 + 环境”的组合称为**闭包**（closure）。
    

---

## 三、如何绘制环境图

### 1. 函数定义时的操作

- 创建一个函数对象，包含：
    
    - 函数名（如 `adder`）
        
    - 形参列表（如 `(k)`）
        
    - 函数体代码
        
    - **`parent` 指针**：指向定义该函数时的当前帧。
        
- 在当前帧中将函数名绑定到该函数对象。
    

### 2. 函数调用时的操作

1. **创建新帧**：帧的标题使用被调用函数的名称，帧的 `parent` 设置为该函数的 `parent` 属性。
    
2. **绑定形参**：将实参值按顺序绑定到形参名（在新帧中）。
    
3. **在新帧中执行函数体**：函数体中的名称查找从该帧开始，沿 `parent` 链向上。
    
4. **函数返回后**：若无外部引用，局部帧可被销毁；若返回的函数或值引用了该帧，则帧保留（如闭包）。
    

### 3. 名称查找规则

> 名称求值：在当前环境中，从第一个帧（最近调用帧）开始，依次沿 `parent` 链查找，返回第一个找到的绑定。

### 4. 示例标记规范

- 帧用 `f1, f2, ...` 标记，便于引用。
    
- 函数对象标记为 `func <name>(<params>) [parent=<frame>]`。
    

---

## 四、形式参数的局部性

对比以下两段代码：

**嵌套定义（可工作）**

```python

def make_adder(n):
    def adder(k):
        return k + n
    return adder
```
**独立函数（错误）**

```python

def f(y):
    x = y * 2
    return x
def g(z):
    return x + z   # 错误：x 未定义
```
- 在独立函数版本中，`g` 无法访问 `f` 的局部变量 `x`，因为 `g` 的环境只有自己的局部帧和全局帧，不包含 `f` 的帧。
    
- 嵌套函数之所以能访问外层变量，是因为内部函数的 `parent` 指向外层函数的帧，从而形成了作用域链。
    
- 这种设计实现了变量的**封装**，防止意外干扰。
    

---

## 五、函数组合

### 1. 定义：`compose1`

```python

def compose1(f, g):
    """返回一个函数 h，使得 h(x) = f(g(x))"""
    def h(x):
        return f(g(x))
    return h
```
### 2. 示例

```python

def square(x):
    return x * x
def triple(x):
    return 3 * x
squiple = compose1(square, triple)   # 先 triple 再 square
print(squiple(5))                    # (3*5)^2 = 225
tripare = compose1(triple, square)   # 先 square 再 triple
print(tripare(5))                     # 3*(5^2) = 75
```
### 3. 组合与柯里化混合

```python

def make_adder(n):
    return lambda k: k + n
squadder = compose1(square, make_adder(2))   # 先加2再平方
print(squadder(3))                            # (3+2)^2 = 25
```
#### 环境图分析（`squadder(3)`）

- `make_adder(2)` 调用创建帧 f1，绑定 `n=2`，返回 `adder` 函数（parent=f1）。
    
- `compose1(square, adder)` 调用创建帧 f2，绑定 `f=square`, `g=adder`，定义内部函数 `h`（parent=f2），返回 `h` 并绑定到全局 `squadder`。
    
- 调用 `squadder(3)` 创建帧 f3（parent=f2），绑定 `x=3`。
    
- 执行 `return f(g(x))`：
    
    - 先 `g(x)`：在当前帧 f3 查找 `g`，得到 `adder` 函数，调用 `adder(3)` 创建帧 f4（parent=f1），绑定 `k=3`，返回 `3+2=5`，f4 销毁。
        
    - 然后 `f(5)`：查找 `f` 得到 `square`，调用 `square(5)` 创建帧 f5（parent=全局），返回 `25`，f5 销毁。
        
- 最终返回 `25`，f3 销毁。
    

**关键**：环境链由多个帧构成，每个函数都记住自己定义时的环境。

---

## 六、lambda 表达式

### 1. 语法与特点

```python

lambda <参数>: <表达式>
```
- 创建匿名函数，求值后得到函数对象。
    
- 函数体只能是一个表达式（不能包含语句）。
    
- 自动返回表达式的结果（无需 `return`）。
    

#### 示例

```python

square = lambda x: x * x
add = lambda a, b: a + b
```
### 2. 与 `def` 的对比

|特性|`def`|`lambda`|
|---|---|---|
|名称|必须有函数名（绑定到名称）|匿名，可赋值给变量|
|函数体|可包含多条语句、循环、条件等|只能包含单个表达式|
|返回值|通过 `return` 语句返回|自动返回表达式结果|
|适用场景|复杂逻辑|简单运算、作为参数传递|

### 3. 使用场景

- 作为高阶函数的参数，如 `compose1(square, lambda x: x+1)`
    
- 定义简单的辅助函数，无需 `def` 语句。
    

### 4. 环境图中的表示

- lambda 创建的函数对象与 `def` 创建的无本质区别，同样有 `parent` 指针。
    
- 在环境图中通常标记为 `func lambda(<params>) [parent=<frame>]`。
    

---

## 七、函数柯里化

### 1. 定义

**柯里化**（Currying）是将一个多参数函数转换为一系列单参数嵌套函数的过程。每个函数接收一个参数，返回下一个函数，直到所有参数收集完毕，最后返回结果。

- 由 Moses Schönfinkel 提出，Haskell Curry 推广。
    

### 2. 示例：柯里化加法

```python

def make_adder(n):
    return lambda k: n + k
# 调用方式
make_adder(2)(3)   # 5
```
- 这本质上是柯里化的加法：先固定第一个参数 `2`，返回一个函数，再传入第二个参数 `3` 得到结果。
    

### 3. 通用柯里化函数 `curry2`

```python

def curry2(f):
    """将双参数函数 f 转换为柯里化形式"""
    def g(x):
        def h(y):
            return f(x, y)
        return h
    return g
def add(x, y):
    return x + y
curried_add = curry2(add)
print(curried_add(2)(3))   # 5
```
- `curry2` 接收一个双参数函数 `f`，返回一个函数 `g`，`g` 接收第一个参数 `x`，返回函数 `h`，`h` 接收第二个参数 `y`，最后调用 `f(x, y)`。
    

### 4. 柯里化的优势

- **参数部分应用**：可以固定一部分参数，生成专用函数，如 `add_two = curried_add(2)`。
    
- **函数组合更灵活**：柯里化函数容易与其他单参数函数组合。
    

### 5. 柯里化与普通函数的关系

- 任何多参数函数都可以转换为柯里化形式，反之亦然。
    
- 柯里化是函数式编程中的重要工具，在 Python 中也有应用（如 `functools.partial` 实现了类似功能）。
    

---

## 八、知识点总结表

|知识点|核心内容|详细说明 / 示例|常见错误 / 易混淆点|难度|
|---|---|---|---|---|
|**高阶函数**|以函数为参数或返回值的函数|`apply_twice(f, x)`、`compose1(f, g)`|混淆传入的函数对象与调用结果|⭐⭐⭐|
|**环境图**|帧序列，记录名称绑定和父帧关系|函数定义时创建函数对象并设 parent；调用时创建新帧|忽略父帧链，误认为所有变量都在全局|⭐⭐⭐⭐|
|**闭包**|内部函数携带定义时的环境|`make_adder` 返回的 `adder` 记住 `n`|认为外部函数返回后局部变量消失|⭐⭐⭐⭐|
|**嵌套作用域**|内层函数可访问外层函数的变量|`adder` 访问 `make_adder` 的 `n`|独立函数无法跨作用域访问|⭐⭐⭐|
|**函数组合**|将多个函数组合成新函数|`compose1(f, g)(x) = f(g(x))`|组合顺序错误导致结果不同|⭐⭐⭐|
|**lambda**|匿名函数，只能含表达式|`lambda x: x*2`|忘记 lambda 自动返回值，试图写语句|⭐⭐|
|**柯里化**|将多参数函数转为单参数链|`curry2(add)(2)(3)`|调用方式与传统函数混淆|⭐⭐⭐|
|**父帧指针**|函数对象的 parent 指向定义时的帧|定义 `adder` 时 parent 指向 `make_adder` 的帧|误将 parent 设为调用帧|⭐⭐⭐⭐|

---

## 九、自测题 —— 检验理解

### 1. 环境图绘制

给定以下代码，画出执行到 `result` 赋值后的环境图。

```python

def compose(f, g):
    def h(x):
        return f(g(x))
    return h
def inc(x):
    return x + 1
def square(x):
    return x * x
f = compose(square, inc)
result = f(3)
```

- 全局帧：`compose`、`inc`、`square`、`f`（指向 compose 返回的 h 函数）。
    
- `compose(square, inc)` 调用时创建帧 f1（parent=全局），形参 `f=square`, `g=inc`，定义 `h`（parent=f1），返回 `h`。
    
- `f(3)` 调用时创建帧 f2（parent=f1），形参 `x=3`。
    
- 执行 `return f(g(x))`：
    
    - 查找 `g`：f2 中无，到 f1 中找到 `g=inc`。
        
    - 调用 `inc(3)` 创建帧 f3（parent=全局），返回 4。
        
    - 查找 `f`：f2 中无，到 f1 中找到 `f=square`。
        
    - 调用 `square(4)` 创建帧 f4（parent=全局），返回 16。
        
- `result` 绑定到 16。
    

### 2. 闭包变量捕获

以下代码输出什么？为什么？

```python

def multipliers():
    funcs = []
    for i in range(3):
        def func(x):
            return x * i
        funcs.append(func)
    return funcs
for m in multipliers():
    print(m(2))
```
<details> <summary>答案</summary> 输出：4 4 4。因为函数定义时捕获的是变量 `i` 本身，而不是循环每次的 `i` 值。循环结束后 `i` 的值为 2，所有函数共享同一个 `i`。若希望每次循环捕获当前值，可使用默认参数：`def func(x, i=i): return x * i`。 </details>

### 3. 柯里化与部分应用

使用 `curry2` 和 `add` 定义一个函数 `add_five`，使其对任意参数加 5。

<details> <summary>答案</summary>

python

curried_add = curry2(add)
add_five = curried_add(5)
print(add_five(3))   # 8

</details>

### 4. lambda 与 def 等价性

将以下 `def` 函数改写为 lambda 表达式，并说明是否总是可以等价替换。

```python

def sign(x):
    if x > 0:
        return 1
    elif x < 0:
        return -1
    else:
        return 0
```
 - 不能直接用 lambda 替换，因为 lambda 体只能是单个表达式，而 `sign` 需要条件分支。可以用条件表达式（三元运算符）模拟，但可读性较差： ```python sign = lambda x: 1 if x > 0 else (-1 if x < 0 else 0) ``` 但复杂逻辑仍建议用 `def`。

### 5. 思考题

为什么需要闭包？闭包在实际编程中有哪些应用？

<details> <summary>提示</summary> 闭包允许函数携带私有状态，而不必使用全局变量。常见应用： - 函数工厂（如 `make_adder`） - 装饰器（decorator） - 回调函数中保留上下文 - 实现私有变量（通过内部函数 + 闭包） </details>

---

## 十、总结与展望

本节课深入探讨了高阶函数与环境的交互，通过环境图揭示了 Python 中名称查找、作用域链和闭包的底层机制。你学会了：

- 高阶函数的执行过程及环境图绘制。
    
- 嵌套函数如何通过父帧访问外层变量，形成闭包。
    
- 函数组合、lambda 表达式和柯里化的概念与实现。
    

这些知识不仅是函数式编程的基础，也是理解 Python 装饰器、迭代器、生成器等高阶特性的关键。在后续课程中，你将看到它们如何被用于构建更强大、更抽象的代码。
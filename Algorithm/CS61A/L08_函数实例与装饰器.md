# 📘 Lecture 8：函数实例与装饰器 

> 本笔记通过一系列精心设计的例题，巩固对函数调用、环境、闭包的理解，并系统介绍装饰器这一高阶函数的典型应用。你将学会如何分析复杂函数调用，掌握逐步实现函数的策略，并理解装饰器的本质与用法。

---

## 一、复习例题

### 1. `print` 函数的特性

**要点回顾：**

- `print` 是一个**非纯函数**，它会将参数显示到控制台（副作用），并返回 `None`。
    
- 多个参数打印时用空格分隔。
    
- 在交互式环境中，表达式的结果会自动显示，**但 `None` 除外**（即 `None` 不会被自动显示，必须用 `print` 才能看到）。
    

#### 示例 1：基本行为


```python

>>> print(5)
5
>>> x = print(5)
5
>>> x
>>> print(x)
None
```
- `print(5)` 显示 `5`，返回值赋给 `x`，此时 `x` 为 `None`。
    
- 直接输入 `x` 不会显示任何内容（因为是 `None`），需要 `print(x)` 才能看到 `None`。
    

#### 示例 2：嵌套调用

```python

>>> print(print(5))
5
None
```
**执行过程：**

1. 内层 `print(5)` 执行：显示 `5`，返回 `None`。
    
2. 外层 `print(None)` 执行：显示 `None`，返回 `None`（但交互环境不显示最后的 `None`）。
    

> 💡 关键：内层返回值作为外层参数，先内后外执行。

### 2. `delay` 函数 —— 闭包与延迟返回

```python

def delay(arg):
    print("delayed")
    def g():
        return arg
    return g
```
- `delay` 接受一个参数 `arg`，打印 `"delayed"`，然后返回一个内部函数 `g`。
    
- `g` 是一个闭包，它捕获了 `arg`，当 `g` 被调用时返回该 `arg`。
    

#### 复杂调用分析：`delay(delay)(6)(6)`

逐步分解：

1. **`delay(delay)`**
    
    - 调用 `delay`，传入参数 `delay`（函数本身）。
        
    - 打印 `"delayed"`。
        
    - 返回内部函数 `g`（该 `g` 捕获的 `arg` 是函数 `delay`）。
        
2. **`delay(delay)(6)`**
    
    - 上一步返回的函数被调用，传入参数 `6`。
        
    - 注意：这里调用的实际上是 `g(6)`？不，`g` 定义时不带参数！仔细看，`g` 没有参数，所以 `g(6)` 会报错。但原题中调用是 `delay(delay)(6)(6)`，意味着 `delay(delay)` 返回的 `g` 被调用时传入了 `6`，但 `g` 不接受参数，因此这会产生类型错误？我们需要检查原题。
        

原笔记中描述的是 `delay(delay)(6)(6)` 最终返回 6，并打印两次 `"delayed"`。这意味着 `delay` 的实现可能不同？让我们重新阅读笔记原文：

> delay函数行为：- 接受任意参数arg，返回函数g- g被调用时返回arg- 每次调用delay会打印"delayed"

如果 `g` 没有参数，那么 `delay(delay)(6)` 就是调用 `g(6)`，这会导致 `TypeError`，因为 `g` 不接受参数。所以可能 `g` 的定义是 `def g(x): return arg`？但笔记中没写。或许这是一个简化，实际例子中 `g` 可能接收一个参数但忽略它？或者原意是 `delay(delay)(6)` 返回的仍然是函数，需要再次调用？我们来构建一个合理的版本。

为了让 `delay(delay)(6)(6)` 有效，`delay` 返回的 `g` 必须接受一个参数，但返回的是捕获的 `arg`，而不是传入的参数。例如：

```python

def delay(arg):
    print("delayed")
    def g(x):
        return arg
    return g
```
这样：

- `delay(delay)` 返回 `g`（捕获 `arg=delay`）。
    
- `g(6)` 调用，忽略参数，返回 `arg`（即 `delay` 函数本身）。
    
- 然后又对返回的 `delay` 函数调用 `(6)`，即 `delay(6)`，打印 `"delayed"`，返回新的 `g`（捕获 `arg=6`）。
    
- 最后 `g(6)` 调用，返回 `6`。
    

整个过程打印两次 `"delayed"`，最终返回 `6`。

这符合笔记描述。因此我们采用这种解释。

**执行环境图（简化）**：

- 第一次调用 `delay(delay)`：创建帧 f1，绑定 `arg=delay`，打印，返回 `g`（parent=f1）。
    
- 调用 `g(6)`：创建帧 f2（parent=f1），形参 `x=6`，执行 `return arg`，在 f1 中找到 `arg=delay`，返回 `delay`。
    
- 调用 `delay(6)`：创建帧 f3，绑定 `arg=6`，打印，返回新的 `g`（parent=f3）。
    
- 调用 `g(6)`：创建帧 f4（parent=f3），返回 `arg=6`。
    

> ✅ 闭包允许内部函数访问定义时的外部变量，即使外部函数已返回。

### 3. `pirate` 函数 —— 不使用闭包的返回

```python

from operator import add, mul
def square(x):
    return mul(x, x)
def pirate(arggg):
    print('matey')
    def plunder(arggg):
        return arggg
    return plunder
```
- `pirate` 每次调用打印 `"matey"`，然后返回内部函数 `plunder`。
    
- `plunder` 直接返回其参数 `arggg`，注意这里的 `arggg` 是 `plunder` 自己的形参，不是外部函数的 `arggg`。由于同名，内部形参**遮蔽**了外部变量，所以 `plunder` 并不形成闭包（它不需要访问外部变量）。
    

#### 调用示例：`pirate(3)(square)(4) + 1`

逐步分析：

1. `pirate(3)` 调用：
    
    - 打印 `"matey"`
        
    - 返回 `plunder` 函数（定义时内部形参名为 `arggg`，但尚未绑定）。
        
2. 接着调用 `(square)`，即上一步返回的 `plunder(square)`：
    
    - `plunder` 被调用，形参 `arggg` 绑定到 `square` 函数。
        
    - `plunder` 返回 `arggg`，即 `square` 函数本身。
        
3. 接着调用 `(4)`，即上一步返回的 `square(4)`：
    
    - 计算 `square(4)` → `16`。
        
4. 最后 `+ 1` 得 `17`。
    

最终表达式值：`17`，过程中打印一次 `"matey"`。

#### 错误示例：`pirate(pirate)(5)(7)`

- `pirate(pirate)` 返回 `plunder`（此时内部 `arggg` 尚未绑定）。
    
- `plunder(5)` 返回 `5`（因为 `plunder` 直接返回参数）。
    
- 然后尝试 `5(7)`，但 `5` 不是函数，导致 `TypeError: 'int' object is not callable`。
    

> ⚠️ 区分闭包与非闭包：`plunder` 不依赖外部变量，直接返回自己的参数，因此不会记住外部值。

### 4. `horse` 与 `mask` —— 复杂环境题

```python

def horse(mask):
    horse = mask
    def mask(horse):
        return horse(2)
    return horse(mask)
mask = lambda horse: horse(2)
```
这是经典的变量遮蔽与多层调用题。我们一步步分析。

**定义阶段**：

- 全局帧：定义函数 `horse`，同时全局变量 `mask` 尚未绑定（后续才绑定 lambda）。
    
- 执行到 `mask = lambda horse: horse(2)` 时，全局帧中 `mask` 绑定到该 lambda。
    

**调用 `horse(mask)`**：

- 调用 `horse`，传入全局 lambda 作为参数。
    
- 创建帧 f1（parent=全局），形参 `mask` 绑定到全局 lambda（记为 `lambda1`）。
    
- 执行函数体：
    
    - `horse = mask`：在 f1 中，将局部变量 `horse` 绑定到 `mask`（即 `lambda1`）。注意此时 f1 中有两个名字：`mask`（形参）和 `horse`（局部变量），都指向 `lambda1`。
        
    - 定义内部函数 `mask(horse): return horse(2)`。在 f1 中定义，其 parent 为 f1。形参名为 `horse`，注意这会遮蔽外部变量。
        
    - 执行 `return horse(mask)`：这里的 `horse` 是哪个？在 f1 中查找 `horse`，得到 `lambda1`。`mask` 是哪个？在 f1 中查找 `mask`，得到刚刚定义的内部函数 `mask`（因为内部函数定义后，名字 `mask` 在 f1 中绑定到了这个内部函数）。
        
    - 因此调用 `lambda1(mask)`，即 `lambda horse: horse(2)` 被调用，传入参数是内部函数 `mask`（记为 `inner_mask`）。
        
        - 为 `lambda1` 创建帧 f2（parent=全局），形参 `horse` 绑定到 `inner_mask`。
            
        - 执行 `horse(2)`：即调用 `inner_mask(2)`。
            
            - 创建帧 f3（parent=f1，因为 `inner_mask` 定义在 f1 中），形参 `horse` 绑定到 `2`。
                
            - 执行 `return horse(2)`：这里的 `horse` 是形参，值为 `2`，因此尝试 `2(2)`，导致错误？不对，我们需要仔细看 `inner_mask` 的函数体：`return horse(2)`，其中 `horse` 是它的形参，当 `horse=2` 时，`2(2)` 显然是错误。但最终结果应该是 `2` 才对？原笔记说返回数字 2，说明调用链不会出错。
                

让我们重新审视：`inner_mask` 定义为 `def mask(horse): return horse(2)`。当 `inner_mask` 被调用时，形参 `horse` 被绑定到传入的值，然后返回 `horse(2)`。如果传入的是函数，则调用它；如果传入的是数字，则尝试调用数字，会出错。在 `lambda1` 中，我们调用 `inner_mask(2)`，所以 `horse=2`，然后 `return horse(2)` 就变成了 `2(2)`，这不对。除非 `inner_mask` 的定义是 `def mask(horse): return horse`？或者 `horse(2)` 中的 `horse` 是外部变量？但内部形参名遮蔽了外部。

也许原题中内部函数是 `def mask(horse): return horse`？但笔记原文是：“定义嵌套mask函数返回horse(mask)”。原文可能写错了？我们根据笔记描述：“horse函数内部：将horse绑定到mask 定义嵌套mask函数 返回horse(mask) 全局mask是lambda函数：lambda horse: horse(2)”。最终结果是数字2。这意味着最终 `horse(2)` 中的 `horse` 应该是函数，且调用后返回2。那么嵌套mask应该返回一个函数调用结果，且最终 `horse(mask)` 返回2。

我们可以构造一个合理的版本：假设内部mask定义为 `def mask(horse): return horse`，那么调用 `horse(mask)` 时：

- `horse` 是 `lambda1`，`mask` 是内部函数。
    
- `lambda1(mask)` 调用，内部执行 `mask(2)`，而 `mask` 是内部函数，它返回 `horse`（即传入的参数），但传入的是2，所以返回2。这样得到2。但需要检查：`lambda1` 的参数是 `horse`，它调用 `horse(2)`，如果 `horse` 是内部函数 `mask`，那么 `mask(2)` 返回2。没问题。
    

但内部函数 `mask` 如果定义为 `return horse`，则其返回值是传入的参数本身。那么 `mask(2)` 返回2。这样 `lambda1(mask)` 的结果就是2，最终返回2。

这符合最终结果2。而原始笔记中写的是“返回horse(mask)”，可能意指内部函数返回 `horse(mask)`，但这样就会多一层调用。我们按照能得到2的合理推断来理解。

> 💡 这类题目考察的是对变量遮蔽和作用域链的深刻理解。建议用 Python Tutor 逐步模拟。

---

## 二、实施函数的策略：以 `remove_digit` 为例

### 问题描述

实现函数 `remove(n, digit)`，返回非负整数 `n` 中**不包含**指定数字 `digit`（0-9）的所有数字组成的新整数，保持原有顺序。

例如：

- `remove(231, 3)` → `21`
    
- `remove(243132, 2)` → `4313`
    

### 1. 解题策略步骤

#### (1) 理解描述，验证示例

先确保自己理解正确：从数字中剔除所有等于 `digit` 的数位，剩下的按原顺序组合。

#### (2) 选择一个简单示例

比如 `n = 231, digit = 3`，预期结果 `21`。

#### (3) 设计算法

常见思路：从个位开始逐位提取，但注意最终结果需要保持原顺序（高位在前）。若从个位开始，我们得到的数字是逆序的，需要反转。

**方法一：使用累加构建（正向构建）**

- 从低位开始处理，但构建时使用 `kept = kept * 10 + last` 会得到逆序。比如 231，低位先处理个位1，然后十位3（但3被剔除），百位2，最终得到 12，不是 21。
    
- 因此需要先记录位数，或者先构建逆序再反转。
    

**方法二：先构建逆序，最后反转**

- 用 `kept` 存储逆序结果，最后再反转。  
    例如：231，个位1保留 → `kept = 1`；十位3剔除；百位2保留 → `kept = kept * 10 + 2 = 12`（这是逆序）。最终需要将 12 反转成 21。  
    反转整数可以用循环：`result = 0; while kept > 0: result = result*10 + kept%10; kept//=10`。但注意如果原数末尾有0，反转会丢失，但本题数字中不会出现前导零问题。
    

**方法三：从高位构建（需要先知道数字位数）**

- 可以先将数字转为字符串处理，但题目可能禁止字符串操作，要求纯算术。
    

**方法四：用小数方式（浮点）**

- 将保留的数字作为小数部分构建，最后乘以10的幂次转为整数。例如 231，保留 2 和 1，构建成 0.21，然后乘以 100 得 21。但需要精确计算幂次，且浮点可能精度问题。
    

#### (4) 逐步实现与测试

我们选择方法二（逆序构建再反转）来实现。

```python

def remove(n, digit):
    kept = 0          # 用于存储逆序的保留数字
    while n > 0:
        last = n % 10
        n //= 10
        if last != digit:
            kept = kept * 10 + last   # 构建逆序
    # 现在 kept 是逆序的，需要反转回来
    result = 0
    while kept > 0:
        result = result * 10 + (kept % 10)
        kept //= 10
    return result
```
**测试**：

- `remove(231, 3)`：
    
    - 第一轮：last=1，保留，kept=1
        
    - 第二轮：last=3，剔除
        
    - 第三轮：last=2，保留，kept=1*10+2=12
        
    - 反转：12 → 21，正确。
        
- `remove(243132, 2)`：
    
    - 逐位：2剔除，3保留（kept=3），1保留（kept=31），3保留（kept=313），2剔除，4保留（kept=313*10+4=3134？顺序是逆序的，原数从个位开始：2,3,1,3,4,2 → 保留：3,1,3,4 → 逆序构建：个位2剔除，十位3保留→kept=3，百位1保留→kept=31，千位3保留→kept=313，万位4保留→kept=3134，十万位2剔除。反转3134得4313，正确。
        

**注意**：如果 `n` 本身为0，且0不是要剔除的数字，应返回0？但我们的循环不会执行，kept=0，反转循环也不会执行，返回0，正确。如果n=0且digit=0，应返回0（没有其他数字），返回0也合理。

#### (5) 验证与总结

多测试几个边界：`remove(100, 0)` 应返回1，我们的算法：个位0剔除，十位0剔除，百位1保留，kept=1，反转后1，正确。

### 2. 模板与注释技巧

- 如果题目提供了函数签名或模板，可以先用注释写下变量示例值，帮助推理。
    
   ``` python
    
    def remove(n, digit):
        # n = 231, digit = 3
        kept = 0
        while n > 0:
            last = n % 10   # 1, 3, 2
            n = n // 10     # 23, 2, 0
            if last != digit:
                kept = kept * 10 + last   # 1, 12
        # 此时 kept = 12（逆序）
        result = 0
        while kept > 0:
            result = result * 10 + (kept % 10)   # 2, 21
            kept //= 10
        return result
    
```
### 3. 替代方案：小数法

python

def remove(n, digit):
    kept = 0.0
    power = 1
    while n > 0:
        last = n % 10
        n //= 10
        if last != digit:
            kept = kept / 10 + last   # 构建小数部分
            power *= 10
    return int(kept * power)

例如 231：第一轮 last=1，kept=0/10+1=1.0，power=10；第二轮 last=3剔除；第三轮 last=2，kept=1.0/10+2=2.1，power=100；最后 2.1*100=210.0？不对，应该是 2.1*100=210，但期望21。因为构建的是 2.1，实际是 2 在十分位，1 在百分位？这里算法需要调整。更常见的是：

```python

    kept = 0.0
    place = 1.0
    while n > 0:
        last = n % 10
        n //= 10
        if last != digit:
            kept = kept + last * place
            place *= 10
    return int(kept)
```
这样从低位开始，用 place 表示当前位数（1,10,100...），正确构建整数。但 kept 是浮点数，可能精度问题，但数字不大时可用。推荐用整数法。

---

## 三、装饰器

### 1. 装饰器概念

**装饰器**（Decorator）是 Python 提供的一种语法糖，用于在不修改原函数定义的情况下，为函数添加额外的功能。它本质上是一个高阶函数，接受一个函数作为参数，返回一个新的函数（通常是在原函数前后添加一些逻辑）。

### 2. 简单例子：`trace` 装饰器

假设我们想跟踪函数的调用情况，打印函数名和参数，以及返回值。

```python

def trace1(fn):
    """返回一个函数，它在调用 fn 之前打印调用信息，之后打印返回值。"""
    def traced(x):
        print('Calling', fn.__name__, 'on argument', x)
        result = fn(x)
        print('Returning', result)
        return result
    return traced
```
- `trace1` 是一个装饰器工厂（实际上就是装饰器本身）。
    
- 它返回的新函数 `traced` 会在调用原函数前后打印信息。
    

#### 使用装饰器语法

```python

@trace1
def square(x):
    return x * x
```
这等价于：

```python

def square(x):
    return x * x
square = trace1(square)
```
现在调用 `square(12)` 会输出：

```text

Calling square on argument 12
Returning 144
144
```
### 3. 装饰器的工作原理

- `@trace1` 在定义 `square` 之后立即执行：`square = trace1(square)`，将原来的 `square` 函数替换为 `trace1` 返回的新函数。
    
- 之后任何对 `square` 的调用，实际上调用的是 `traced` 函数，它在内部调用原来的 `square` 并添加额外行为。
    

### 4. 多个装饰器

可以堆叠多个装饰器，执行顺序从下往上（靠近函数的先应用）。例如：

```python

@deco2
@deco1
def f(): ...
```
等价于 `f = deco2(deco1(f))`。

### 5. 带参数的装饰器

有时装饰器本身需要参数，这时需要再嵌套一层函数。例如：

```python

def trace(prefix):
    def decorator(fn):
        def traced(x):
            print(prefix, 'Calling', fn.__name__, x)
            return fn(x)
        return traced
    return decorator
@trace('DEBUG')
def square(x):
    return x * x
```
这等价于 `square = trace('DEBUG')(square)`。

### 6. 装饰器的常见用途

- 日志记录
    
- 计时
    
- 权限检查
    
- 缓存（如 `@lru_cache`）
    
- 注册函数（如 Flask 路由）
    

### 7. 注意事项

- 装饰器会改变函数的 `__name__` 等属性，如果需要保留，可以使用 `functools.wraps` 装饰器。
    
- 装饰器可以应用于任何可调用对象，包括类。
    

---

## 四、知识点总结表

|知识点|核心内容|考试重点 / 易混淆点|难度|
|---|---|---|---|
|**print 返回值**|print 返回 None，交互环境不显示 None|嵌套 print 的输出顺序|⭐⭐|
|**闭包与延迟返回**|内部函数引用外部变量，形成闭包|区分闭包与非闭包（如 plunder）|⭐⭐⭐|
|**变量遮蔽**|内部同名参数遮蔽外部变量|环境图中查找路径|⭐⭐⭐⭐|
|**remove_digit 算法**|逐位处理，逆序构建再反转|边界条件（n=0, 剔除所有数字）|⭐⭐⭐|
|**装饰器本质**|高阶函数语法糖，替换原函数|`@trace` 等价于 `f = trace(f)`|⭐⭐⭐|
|**trace 装饰器实现**|返回内部函数，保留原函数引用|注意打印信息的时机|⭐⭐⭐|
|**调用链分析**|多级函数调用时帧的创建与销毁|如 `pirate(pirate)(5)(7)` 报错原因|⭐⭐⭐⭐|
|**考试信息**|周一晚上考试，可补回分数|复习作业和实验题|⭐|

---

## 五、自测题

### 1. 打印与 None

写出以下代码的输出（假设在交互环境中逐行输入）：

```python

>>> print(print(1), print(2))
>>> x = print(3)
>>> x
>>> print(x)
```
<details> <summary>答案</summary>

text

1
2
None None
3
None

解释：第一行先执行两个内层 print，分别打印 1 和 2，然后外层 print 打印两个 None（因为内层返回 None），输出 "None None"。第二行赋值，打印 3，x 为 None。第三行直接 x 不显示。第四行 print(x) 打印 None。

</details>

### 2. delay 函数变体

假设 `delay` 定义如下：

```python

def delay(arg):
    print('delayed')
    def g():
        return arg
    return g
```
判断 `delay(delay)(6)(6)` 是否会报错？如果会，为什么？如果不会，结果是什么？

<details> <summary>答案</summary> 会报错。因为 `delay(delay)` 返回的 `g` 不接受参数，而 `(6)` 试图传入参数，导致 `TypeError: g() takes 0 positional arguments but 1 was given`。原笔记中假设的版本是 `g` 接受一个参数，但这里没有。 </details>

### 3. remove 函数实现

实现 `remove(n, digit)` 的另一种方法：使用字符串操作（允许用 str），然后比较效率与算术版本。

ans:
```python

def remove(n, digit):
    s = str(n)
    result = ''
    for ch in s:
        if int(ch) != digit:
            result += ch
    return int(result) if result else 0

注意处理空结果（全剔除）返回 0。
```

### 4. 装饰器应用

编写一个装饰器 `@double`，使得被装饰的函数返回值变为原来的两倍。

```python

@double
def square(x):
    return x * x
print(square(3))   # 应输出 18
```
ans:
```python

def double(fn):
    def wrapper(x):
        return 2 * fn(x)
    return wrapper
```

### 5. 环境图题

给定以下代码，画出调用 `f(2)` 时的环境图，并说出输出。

```python

def f(x):
    def g(y):
        return y + x
    x = 5
    return g
result = f(2)(3)
print(result)
```

- 输出 8。调用 `f(2)` 创建帧 f1，绑定 x=2；然后执行 `x = 5` 将局部 x 改为 5；定义 `g`（parent=f1）；返回 `g`。调用 `g(3)` 创建帧 f2（parent=f1），y=3，执行 `y + x`：查找 y 在 f2 得 3，x 在 f1 得 5，和为 8。 

---

## 六、总结与备考建议

本节课通过大量实例，强化了函数、环境、闭包的理解，并介绍了实用的函数实现策略和装饰器概念。这些内容不仅是考试重点，也是日常编程中常用的技巧。

**备考建议**：

- 重点复习环境图的绘制，尤其是闭包和变量遮蔽的案例。
    
- 熟练掌握 `remove` 类数字处理函数的多种实现。
    
- 理解装饰器的本质，能够手写简单的装饰器。
    
- 回顾作业和实验中的相关题目。
# 📘 Lecture 15：可变性（Mutability）

> 从本节课开始，我们引入一个全新的概念：**对象可以改变**。此前，我们学习的数字、字符串、元组等都是不可变的——一旦创建，值就不会变化。但现实世界中的事物是会变化的（比如银行账户余额），编程中也需要能随时间改变状态的数据。Python 中的列表、字典等是**可变**的，这带来了强大的灵活性，也引入了新的复杂性和陷阱。本节课将带你深入理解可变性、对象身份、副作用以及如何利用可变性构建持久本地状态。

---

## 一、对象

### 1. 什么是对象？

在 Python 中，**一切皆对象**。数字、字符串、列表、函数、甚至模块都是对象。

- **对象**是数据和行为的封装体。
    
- 每个对象都有一个**类型**（也称为**类**），决定了它可以有哪些数据和行为。
    
- 对象通过**属性**（attribute）来访问其数据和行为。属性可以是数据（如 `today.year`），也可以是方法（如 `today.strftime()`）。
    

### 2. 日期对象示例

```python

from datetime import date
today = date(2015, 2, 20)      # 创建一个日期对象
freedom = date(2015, 5, 12)    # 另一个日期对象

```
- `date` 是一个类（class），`date(2015,2,20)` 是创建该类的一个**实例**。
    
- 对象的行为应该符合我们对现实日期的期望：
    
    - 两个日期相减得到时间间隔（`timedelta` 对象）：
        
        ```python
        
        days_left = freedom - today
        print(days_left.days)   # 81
        ```
    - 通过点表达式访问属性：
        
        ```python
        
        print(today.year)   # 2015
        print(today.month)  # 2
        print(today.day)    # 20
        ```
    - 调用方法：
        
        ```python
        
        print(today.strftime('%A, %B %d'))   # 例如 "Friday, February 20"
        
```
> 💡 **点表达式**：`对象.属性名` 用于访问对象的属性。如果属性是可调用的（函数），则称为**方法**。

### 3. 对象的核心思想

对象不仅仅代表具体事物，还可以代表抽象概念、属性、交互过程。面向对象编程（OOP）的核心思想是：

- 程序由多个相互通信的对象组成。
    
- 每个对象封装自己的数据和行为。
    
- 通过点表达式等特殊语法提高代码的组织性和可读性。
    

在 Python 中，每个值都是对象，因此所有值都有属性和方法。例如字符串就有很多方法：

```python

name = "hello"
print(name.upper())       # "HELLO"
print(name.lower())       # "hello"
print(name.swapcase())    # "HELLO" ？ 实际上是 "HELLO" ？ 不，原字符串 "hello" 的 swapcase 是 "HELLO"？ 注意原字符串是小写，swapcase 会变成大写，所以是 "HELLO"。
# 更准确：name = "Hello" 时 swapcase() 返回 "hELLO"
```
**重要**：字符串是不可变的，这些方法返回**新字符串**，原字符串不变。

---

## 二、字符串的底层表示：从 ASCII 到 Unicode

### 1. ASCII 编码

早期计算机只处理英语，使用 ASCII（美国信息交换标准代码）编码。

- 用 7 位二进制（实际存储为 8 位，首位为 0）表示 128 个字符。
    
- 包括控制字符（如换行 LF、响铃 BEL）、数字、大写字母、小写字母、标点符号。
    
- 设计特点：大写字母排在小写字母之前，数字排在字母之前，方便排序。
    

**示例**：大写字母 `'A'` 的 ASCII 码是 65（十六进制 `0x41`）。可以通过 `ord()` 和 `hex()` 验证：

```python

print(ord('A'))      # 65
print(hex(ord('A'))) # 0x41
```
### 2. Unicode 标准

随着全球化需求，Unicode 应运而生，旨在为所有语言的每个字符分配一个唯一的**码点**（code point）。

- 目前包含超过 109,000 个字符，覆盖 93 种文字体系。
    
- 除了字母，还包括表情符号（如 😊、☹️）、符号等。
    
- 每个字符有规范名称，例如：
    
    - `U+0058` LATIN CAPITAL LETTER X
        
    - `U+263A` WHITE SMILING FACE
        
    - `U+2639` WHITE FROWNING FACE
        

Python 中可以使用 `unicodedata` 模块查询：

```python

import unicodedata
print(unicodedata.name('X'))      # LATIN CAPITAL LETTER X
print(unicodedata.lookup('WHITE SMILING FACE'))  # ☺
```
**编码与显示**：同一字符在不同操作系统/字体下可能显示不同，但码点是通用的。

**字节表示**：不同字符需要的字节数不同。例如英文字母通常 1 字节，而某些表情可能需要 4 字节。可以通过 `encode()` 查看：

```python

print('a'.encode())       # b'a' (1 字节)
print('😊'.encode())       # 可能 b'\xf0\x9f\x98\x8a' (4 字节)
```
---

## 三、突变操作（Mutation）

**突变**指对象的内容在创建后发生改变。这是可变对象的特征。

### 1. 列表的可变性

列表是可变序列，可以修改元素、添加或删除元素。

```python

suits = ['coin', 'string', 'myriad']   # 原始列表
original_suits = suits                  # 两个名称指向同一列表对象
```
**修改列表**：

```python

suits.pop()          # 移除最后一个元素，返回 'myriad'
suits.remove('string') # 移除指定元素
suits.append('cup')   # 添加元素
```
现在 `suits` 和 `original_suits` 都指向同一个已被修改的列表：

```python

print(original_suits)   # ['coin', 'cup'] （取决于操作顺序）
```
> ⚠️ **关键**：多个变量可以引用同一个可变对象，通过任一变量修改对象，所有引用都会看到变化。

### 2. 字典的可变性

字典也是可变的，可以修改、添加、删除键值对。

```python

numerals = {'I': 1, 'V': 5, 'X': 10}
numerals['X'] = 11        # 修改已有键的值
numerals['L'] = 50        # 添加新键值对
numerals.pop('I')         # 删除键 'I'
print(numerals)           # {'V': 5, 'X': 11, 'L': 50}
```
### 3. 函数修改可变对象

当可变对象作为参数传递给函数时，函数内部对对象的修改会影响原始对象。

```python

def mystery(s):
    s.pop()      # 移除最后一个元素
    s.pop()      # 再移除一个
four = [1, 2, 3, 4]
mystery(four)
print(four)      # [1, 2]
```
如果不想修改原对象，可以在函数内创建副本（例如 `s = s[:]` 或 `s.copy()`）。

---

## 四、元组（Tuple）

### 1. 元组是不可变序列

元组与列表类似，但**不可变**：一旦创建，不能修改其元素。

```python

t = (3, 4, 5, 6)
t[0] = 7          # 错误！TypeError
```
### 2. 创建元组

- 标准方式：`(3, 4, 5, 6)`
    
- 省略括号：`3, 4, 5, 6` 也会被识别为元组（但通常建议加括号）。
    
- 空元组：`()` 或 `tuple()`
    
- 单元素元组：必须加逗号，如 `(2,)` 或 `2,`，否则 `(2)` 就是整数 2。
    

### 3. 元组的操作

支持序列通用操作：拼接、切片、成员检测等。

```python

(1, 2) + (3, 4)       # (1, 2, 3, 4)
(1, 2, 3)[1:3]        # (2, 3)
3 in (1, 2, 3)        # True
```
### 4. 元组作为字典键

由于元组不可变，它可以作为字典的键（需要可哈希）。但若元组中包含可变元素（如列表），则不能作为键。

```python

d = {(1, 2): 'value'}   # 合法
# d = {([1,2],): 'value'}  # 错误：列表不可哈希
```
### 5. 元组不可变性的微妙之处

虽然元组本身不可变，但如果它包含可变对象（如列表），那个列表的内容是可以改变的。

```python

t = (1, [2, 3], 4)
# t[1] = [5,6]       # 错误！不能修改元组元素
t[1].append(4)        # 允许！修改了列表的内容
print(t)              # (1, [2, 3, 4], 4)
```
元组的“不可变”是指**元素引用不可变**，而不是元素引用的对象不可变。

---

## 五、相同与改变

### 1. 身份 vs 相等

- **`==` 运算符**：比较两个对象的值是否相等。
    
- **`is` 运算符**：比较两个对象是否是同一个对象（即内存地址相同）。
    

```python

a = [10]
b = [10]
print(a == b)    # True，值相等
print(a is b)    # False，不同对象
c = a
print(a is c)    # True，同一对象
```
修改 `a` 会影响 `c`，但不影响 `b`。

### 2. `is not` 运算符

`is not` 是 `is` 的反义：

```python

print(a is not b)   # True
```
### 3. 可变默认参数的危险

这是一个经典陷阱：函数的默认参数值在**定义时**创建，并成为函数对象的一部分。如果默认参数是可变对象，那么多次调用会共享同一个对象，导致意外。

```python

def f(s=[]):
    s.append(len(s))
    return s
print(f())   # [0]
print(f())   # [0, 1]  而不是 [0]
print(f())   # [0, 1, 2]
```
**原因**：每次调用不传参数时，使用的都是同一个列表对象。

**最佳实践**：不要使用可变对象作为默认参数。改用 `None`，在函数内部初始化：

```python

def f(s=None):
    if s is None:
        s = []
    s.append(len(s))
    return s
```
---

## 六、可变函数与持久本地状态

### 1. 问题：如何让函数记住状态？

我们希望创建一个函数，每次调用时能基于之前的调用结果进行操作。例如银行账户提款函数：第一次提 25 后余额为 75，第二次提 25 后余额应为 50。

纯函数无法做到，因为纯函数每次相同输入得到相同输出。我们需要函数内部有**状态**，并且这个状态能在多次调用间持久存在。

### 2. 利用可变列表实现

我们可以利用闭包 + 可变列表来存储状态。

```python

def make_withdraw_list(balance):
    b = [balance]          # 用列表包装余额，使其可变
    def withdraw(amount):
        if amount > b[0]:
            return 'Insufficient funds'
        b[0] = b[0] - amount
        return b[0]
    return withdraw
wd = make_withdraw_list(100)
print(wd(25))   # 75
print(wd(25))   # 50
print(wd(60))   # 'Insufficient funds'
```
**工作原理**：

- `make_withdraw_list` 被调用时，创建帧 f1，局部变量 `b` 指向列表 `[balance]`。
    
- 内部函数 `withdraw` 被定义，其父帧为 f1，因此它可以访问 `b`。
    
- 每次调用 `withdraw`，它通过 `b[0]` 读取和修改列表的内容。由于列表是可变的，修改会保留在 f1 帧的列表中。
    
- 我们从未重新绑定 `b`（没有 `b = ...`），只是修改了列表元素，因此闭包始终引用同一个列表。
    

### 3. 环境图分析

- 第一次调用 `make_withdraw_list(100)`：
    
    - 创建帧 f1，`balance=100`，`b` 指向列表 `[100]`。
        
    - 返回 `withdraw` 函数，其父帧为 f1。
        
- 全局帧中 `wd` 指向该函数。
    
- 调用 `wd(25)`：
    
    - 创建帧 f2（父帧 f1），`amount=25`。
        
    - 检查 `25 > b[0]`，在 f2 中无 `b`，到父帧 f1 找到 `b` 指向列表 `[100]`。
        
    - 条件为假，执行 `b[0] = b[0] - 25`，修改列表为 `[75]`。
        
    - 返回 `75`，f2 销毁。
        
- 再次调用 `wd(25)`：
    
    - 创建新帧 f3，再次查找 `b` 得到列表（现为 `[75]`），修改为 `[50]`，返回 `50`。
        

**核心**：通过修改列表内容而非重新绑定变量，实现了状态的持久化。

---

## 七、知识点总结表

|知识点|核心内容|考试重点 / 易混淆点|难度|
|---|---|---|---|
|**对象**|数据和行为的封装，所有 Python 值都是对象|点表达式访问属性/方法|⭐|
|**日期对象**|`datetime.date` 类的实例，支持运算和属性访问|日期相减得到 `timedelta`|⭐|
|**字符串方法**|如 `upper()`, `lower()`, `swapcase()`，返回新字符串|原字符串不变|⭐|
|**ASCII**|7 位编码，128 字符，大写字母在前|`ord()` 和 `hex()` 使用|⭐|
|**Unicode**|全球字符集，每个字符有唯一码点|`unicodedata` 模块|⭐⭐|
|**可变对象**|列表、字典等，内容可修改|多个引用共享同一对象|⭐⭐|
|**元组**|不可变序列，可哈希，可作字典键|单元素元组需加逗号|⭐⭐|
|**身份 vs 相等**|`is` 比较对象身份，`==` 比较值|`a == b` 为真不一定 `a is b`|⭐⭐|
|**可变默认参数**|默认参数在定义时创建，多次调用共享|用 `None` 加内部初始化避免|⭐⭐⭐|
|**持久本地状态**|利用闭包和可变列表实现函数状态|修改列表元素而非重新绑定|⭐⭐⭐|

---

## 八、自测题

### 1. 日期对象

```python

from datetime import date
d1 = date(2020, 1, 1)
d2 = date(2020, 1, 10)
diff = d2 - d1
print(diff.days)
```
输出是什么？

<details> <summary>答案</summary> 9 </details>

### 2. 字符串方法

```python

s = 'Hello'
s.upper()
print(s)
```
输出是什么？

<details> <summary>答案</summary> `'Hello'`，因为字符串不可变，`upper()` 返回新字符串，原 `s` 不变。 </details>

### 3. Unicode 查询

使用 `unicodedata` 找出字符 `'€'` 的官方名称。

```python

import unicodedata
print(unicodedata.name('€'))   # EURO SIGN

```

### 4. 列表修改

```python

lst = [1, 2, 3, 4]
def remove_last(x):
    x.pop()
remove_last(lst)
print(lst)
```
输出什么？

<details> <summary>答案</summary> `[1, 2, 3]`，函数内修改了原列表。 </details>

### 5. 元组与列表

```python

t = (1, [2, 3], 4)
t[1].append(5)
print(t)
```
<details> <summary>答案</summary> `(1, [2, 3, 5], 4)`，元组不可变，但其元素列表可变。 </details>

### 6. 身份与相等

```python

a = [1, 2]
b = [1, 2]
c = a
print(a == b, a is b, a is c)
```
<details> <summary>答案</summary> `True False True` </details>

### 7. 默认参数陷阱

```python

def add_item(item, lst=[]):
    lst.append(item)
    return lst
print(add_item(1))
print(add_item(2))
```
<details> <summary>答案</summary> `[1]` 然后 `[1, 2]`，因为默认列表被共享。 </details>

### 8. 银行账户

写出 `make_withdraw_list(200)(30)` 两次调用的结果。

<details> <summary>答案</summary> 第一次返回 170，第二次返回 140（如果连续调用同一个 `withdraw` 函数）。 </details>

---

## 九、总结与展望

本节课我们迈入了“可变性”的大门。你学会了：

- 对象是数据和行为的封装，所有 Python 值都是对象。
    
- 字符串底层编码从 ASCII 发展到 Unicode。
    
- 列表、字典是可变的，修改它们会影响所有引用。
    
- 元组是不可变的，但可能包含可变对象。
    
- `is` 和 `==` 的区别，以及可变默认参数的陷阱。
    
- 如何利用闭包和可变列表创建拥有持久本地状态的函数（如银行账户）。
    

可变性是构建现实世界模型（如银行账户、游戏角色）的基础，但也带来了副作用和共享引用的复杂性。在后续课程中，你将学习如何用面向对象编程更好地组织这些可变状态。
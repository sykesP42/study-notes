# 📘 Lecture 13：数据抽象 

> 数据抽象是计算机科学中最重要的思想之一。它让我们能够将复合数据（如分数、日期）视为一个整体单元来操作，同时隐藏其内部表示细节。本节课以有理数为例，深入讲解如何通过构造函数和选择器定义抽象数据类型，以及如何利用抽象屏障构建模块化、易维护的程序。

---

## 一、什么是数据？

### 1. 数据的本质

在编程中，“数据”不仅仅是数值或字符串，更核心的是其**行为**。一个对象能否被视为某种数据类型，取决于它是否满足该类型应有的行为特征。

**关键思想**：数据的类型由其**行为**定义，而非其具体实现方式。

### 2. 行为条件：以有理数为例

假设我们想要表示有理数（分数）。一个有理数 x 应该能够通过分子 n 和分母 d 构造出来，并且我们能够从中提取出分子和分母，使得：

$$numer(x)/denom(x)​=n/d​
$$
这就是有理数表示必须满足的**行为条件**。只要我们的构造函数和选择器函数共同满足这个条件，那么无论内部如何实现，我们都认为这个表示是有效的。

### 3. 数据抽象的三要素

- **构造函数**（Constructor）：用于创建新的复合数据对象。例如 `rational(n, d)` 返回一个有理数。
    
- **选择器**（Selector）：用于从复合数据对象中提取其组成部分。例如 `numer(x)` 和 `denom(x)`。
    
- **行为条件**：构造函数和选择器必须协同工作，确保提取出的部分与构造时的输入一致。
    

---

## 二、有理数的两种实现方式

### 1. 使用列表实现（直观方式）


```python

def rational(n, d):
    """构造一个有理数，表示 n/d"""
    return [n, d]
def numer(x):
    """返回有理数 x 的分子"""
    return x[0]
def denom(x):
    """返回有理数 x 的分母"""
    return x[1]
```
这种实现非常直观：有理数就是一个包含两个整数的列表。

**优点**：简单易懂，操作直接。

**缺点**：如果将来想改变内部表示（例如改用元组或字典），所有直接使用列表索引的代码都需要修改。

### 2. 使用函数实现（高阶函数方式）

```python

def rational(n, d):
    """构造一个有理数，返回一个选择器函数"""
    def select(name):
        if name == 'n':
            return n
        elif name == 'd':
            return d
    return select
def numer(x):
    """返回有理数 x 的分子"""
    return x('n')
def denom(x):
    """返回有理数 x 的分母"""
    return x('d')
```
这里，有理数不再是一个列表，而是一个**函数**（称为选择器函数）。这个函数通过闭包记住了创建时的 `n` 和 `d`。当调用 `numer(x)` 时，我们实际上调用这个函数并传入 `'n'`，函数返回保存的 `n` 值。

#### 环境图分析

1. 调用 `rational(3, 4)`：
    
    - 创建新帧 f1，绑定 `n=3, d=4`。
        
    - 定义内部函数 `select`，其父帧为 f1。
        
    - 返回 `select` 函数对象。
        
2. 全局帧中，`x` 绑定到返回的 `select` 函数。
    
3. 调用 `numer(x)`：
    
    - 创建新帧 f2，形参 `x` 绑定到 `select` 函数。
        
    - 执行 `x('n')`：调用 `select('n')`。
        
    - 为 `select` 创建新帧 f3（父帧为 f1），形参 `name='n'`。
        
    - 执行函数体：因为 `name == 'n'`，返回 `n`。在 f3 中找不到 `n`，到父帧 f1 中找到 `n=3`。
        
    - 返回 3。
        

**优点**：完全使用函数实现，不依赖任何内置数据结构，体现了“数据即过程”的思想。

**两种实现的等价性**：对于有理数的使用者来说，无论采用哪种实现，`rational`, `numer`, `denom` 的行为都是一致的。这正是数据抽象的力量——实现可以改变，但接口和行为保持不变。

---

## 三、抽象屏障

### 1. 什么是抽象屏障？

**抽象屏障**（Abstraction Barrier）是程序中不同层级之间的分界线，它将数据的使用与数据的实现隔离开来。每一层只通过明确定义的接口与相邻层通信，无需了解内部细节。

### 2. 有理数系统的三层结构

以有理数算术系统为例，我们可以识别出三个层次：

|层级|角色|将有理数视为...|使用...|示例|
|---|---|---|---|---|
|顶层|应用程序|完整的数据值|有理数运算函数|`add_rational`, `mul_rational`|
|中间层|数据抽象接口|分子与分母的组合|构造函数与选择器|`rational`, `numer`, `denom`|
|底层|具体实现|具体的数据结构|列表或函数|`[n, d]` 或闭包函数|

#### 顶层应用

```python

def add_rational(x, y):
    """返回 x + y 的和（有理数）"""
    nx, dx = numer(x), denom(x)
    ny, dy = numer(y), denom(y)
    return rational(nx * dy + ny * dx, dx * dy)
def mul_rational(x, y):
    """返回 x * y 的积"""
    return rational(numer(x) * numer(y), denom(x) * denom(y))
```
这些函数只通过 `numer`、`denom` 和 `rational` 与有理数交互，完全不知道底层是用列表还是函数实现的。

#### 中间层接口

```python

# 定义在抽象屏障上
rational(n, d)   # 构造函数
numer(x)         # 选择器
denom(x)         # 选择器
```
#### 底层实现

可以是列表实现，也可以是函数实现，甚至可以是元组或其他。只要实现满足接口，上层无需改动。

### 3. 抽象屏障的好处

- **模块化**：各部分职责清晰，可以独立开发和测试。
    
- **可维护性**：修改底层实现不影响上层代码。
    
- **可读性**：每层只需理解相邻层的接口，降低认知负担。
    

### 4. 违反抽象屏障的例子

```python

# 错误示例：直接操作列表
def divide_rational(x, y):
    return [x[0] * y[1], x[1] * y[0]]   # 直接使用列表索引
# 更糟糕：直接使用列表字面量
result = add_rational([1, 2], [1, 4])
```
**问题分析**：

- 假设有理数是列表，直接使用索引 `x[0]`、`x[1]`，而不是调用 `numer(x)` 和 `denom(x)`。
    
- 创建有理数时直接写 `[1,2]`，而不是调用 `rational(1,2)`。
    
- 如果将来底层实现从列表改为函数，这些代码将全部失效。
    

**抽象屏障原则**：

- 永远通过构造函数创建数据。
    
- 永远通过选择器访问数据。
    
- 永远不要假设数据的具体表示形式。
    

> 💡 违反抽象屏障的代码就像在高速公路上逆向行驶——可能暂时能跑，但一旦别人改变方向，你就会撞车。

---

## 四、对（Pairs）

### 1. 什么是“对”？

“对”是最简单的复合数据结构，它将两个值捆绑在一起，作为一个整体单元处理。在Python中，列表是最常用的表示“对”的方式。

```python

pair = [1, 2]   # 一个包含两个元素的对
```
### 2. 操作“对”的方法

- **创建**：使用列表字面量 `[a, b]`。
    
- **解包**：通过多重赋值 `x, y = pair`，将第一个元素赋给 `x`，第二个赋给 `y`。
    
- **选择**：使用索引 `pair[0]` 和 `pair[1]`，或 `getitem(pair, 0)`。
    

```python

from operator import getitem
pair = [1, 2]
x, y = pair          # x=1, y=2
first = pair[0]      # 1
second = getitem(pair, 1)   # 2
```
### 3. 对与有理数

有理数本质上就是一个“对”（分子和分母）。因此，用列表实现有理数非常自然。

---

## 五、改进有理数实现：约分

### 1. 问题

如果直接存储构造时传入的分子和分母，可能会出现未约分的情况，例如 `rational(15, 6)` 存储为 `[15, 6]`，但实际上应该表示为 `5/2`。未约分会导致后续计算产生更大的数，增加计算负担。

### 2. 解决方案：构造函数中约分

在构造函数中计算分子和分母的最大公约数（GCD），然后除以 GCD，存储最简形式。

```python

from math import gcd
def rational(n, d):
    """构造最简形式的有理数"""
    g = gcd(n, d)
    return [n // g, d // g]
```
现在，`rational(15, 6)` 返回 `[5, 2]`。

### 3. 数据抽象的优势

我们只修改了构造函数，所有使用 `rational`、`numer`、`denom` 的上层代码（如 `add_rational`、`mul_rational`）完全不需要改动！这正是抽象屏障保护下的好处——修改局部化，不影响整体。

**加法示例**：

```python

>>> x = rational(2, 5)   # [2, 5]
>>> y = rational(1, 10)  # [1, 10]
>>> z = add_rational(x, y)  # 内部计算得 [25, 50]，但 rational 构造时会约分为 [1, 2]
>>> numer(z) / denom(z)
0.5
```
---

## 六、知识点总结表

|知识点|核心内容|考试重点 / 易混淆点|难度|
|---|---|---|---|
|**数据的行为定义**|数据的类型由其行为（构造函数和选择器的协同）定义|行为条件：`numer(x)/denom(x) = n/d`|⭐⭐⭐|
|**有理数的列表实现**|用 `[n, d]` 存储分子分母，选择器通过索引访问|简单直观，但暴露实现细节|⭐⭐|
|**有理数的函数实现**|用闭包函数存储 `n` 和 `d`，选择器通过消息传递获取|环境图分析；纯函数式实现|⭐⭐⭐⭐|
|**抽象屏障**|将数据使用与数据实现隔离的层级分界线|识别不同层级；理解违反屏障的后果|⭐⭐⭐|
|**构造函数与选择器**|`rational`（构造）、`numer` 和 `denom`（选择）|必须成对使用，不能绕过|⭐⭐|
|**违反抽象屏障**|直接操作底层表示（如 `x[0]`），而不是调用选择器|导致代码脆弱，无法适应变化|⭐⭐⭐|
|**约分优化**|在构造函数中计算 GCD，存储最简形式|修改局部性；不破坏上层|⭐⭐|
|**对（Pair）**|两个值的组合，列表是常见实现|解包与索引选择|⭐|

---

## 七、自测题

### 1. 行为条件验证

假设我们有一个有理数 `x`，是通过 `rational(3, 4)` 构造的。那么 `numer(x)` 和 `denom(x)` 应该返回什么？如果返回的是 `(6, 8)`，这个表示有效吗？为什么？

<details> <summary>答案</summary>

行为条件要求 `numer(x)/denom(x)` 等于构造时的 `n/d`。如果 `numer(x)=6, denom(x)=8`，那么 `6/8 = 3/4`，仍然满足行为条件。因此这个表示是有效的，尽管不是最简形式。但为了计算效率，我们通常希望存储最简形式。

</details>

### 2. 函数式实现的环境图

画出以下代码执行到 `numer(z)` 时的环境图：

```python

def rational(n, d):
    def select(name):
        if name == 'n':
            return n
        else:
            return d
    return select
x = rational(3, 4)
y = rational(5, 6)
z = x
numer(z)
```
答案要点
```
- 全局帧：`rational` 绑定函数，`x` 指向第一次调用返回的 `select` 函数（父帧 f1），`y` 指向第二次调用返回的 `select` 函数（父帧 f2），`z` 与 `x` 指向同一个函数。
    
- 调用 `numer(z)` 时，创建新帧，执行 `z('n')`。
    
- 调用 `select('n')` 时，创建新帧，其父帧为 f1（因为 `z` 的函数来自第一次调用），形参 `name='n'`。
    
- 在 f1 中查找 `n`，得 3，返回。
    
```
### 3. 识别抽象屏障的违反

以下代码中，哪些行违反了有理数的抽象屏障？为什么？

```python

def multiply_rationals(r1, r2):
    n1 = r1[0]          # 行 A
    d1 = r1[1]          # 行 B
    n2 = numer(r2)      # 行 C
    d2 = denom(r2)      # 行 D
    return rational(n1 * n2, d1 * d2)  # 行 E
```

```
行 A 和行 B 违反了抽象屏障，因为它们直接使用列表索引访问 `r1` 的分子和分母，而不是调用 `numer(r1)` 和 `denom(r1)`。行 C、D、E 是正确的，因为它们使用了选择器和构造函数。
```

### 4. 约分的影响

如果我们的 `rational` 构造函数中不进行约分，而 `add_rational` 函数如下：

```python

def add_rational(x, y):
    return rational(numer(x)*denom(y) + numer(y)*denom(x), denom(x)*denom(y))
```
计算 `add_rational(rational(1, 2), rational(1, 6))` 的结果（分子和分母分别是什么）？如果构造函数有约分，结果又是什么？

<details> <summary>答案</summary>

无约分：分子 = 1×6 + 1×2 = 8，分母 = 2×6 = 12，结果为 `8/12`。  
有约分：gcd(8,12)=4，结果为 `2/3`。

</details>

### 5. 思考题

为什么说数据抽象是“抽象”的？它与函数抽象有何异同？

<details> <summary>提示</summary>

函数抽象将计算过程命名并隐藏其实现细节；数据抽象将数据组织方式命名并隐藏其表示细节。两者都通过接口与实现分离来提高模块化。区别在于函数抽象处理“做什么”，数据抽象处理“是什么”。

</details>

---

## 八、总结与展望

本节课我们深入探讨了数据抽象的核心思想，并通过有理数的例子实践了如何定义抽象数据类型、建立抽象屏障。你学会了：

- 数据的行为由构造函数和选择器共同定义。
    
- 同一种抽象数据类型可以有多种实现（列表、函数），且对使用者透明。
    
- 抽象屏障将程序分层，使修改局部化，提高可维护性。
    
- 违反抽象屏障会导致代码脆弱，应始终通过接口操作数据。
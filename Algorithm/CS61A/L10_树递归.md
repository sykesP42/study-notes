# 📘 Lecture 10：树递归

> 本笔记深入探讨递归调用的顺序，引出树形递归的概念。通过斐波那契数列和整数划分两个经典例子，你将理解树递归的执行过程、效率问题以及如何用递归思维解决组合问题。最后介绍trace装饰器，帮助你可视化递归调用。

---

## 一、递归调用的顺序

### 1. 调用机制回顾

当一个函数调用另一个函数时，必须等待被调用函数返回后才能继续执行后续操作。这在递归中尤为重要，因为递归调用会形成嵌套的等待链。

### 2. 示例：`cascade` 函数


```python

def cascade(n):
    """打印数字 n 的级联效果，例如 cascade(123) 打印：
       123
       12
       1
       12
       123
    """
    if n < 10:
        print(n)
    else:
        print(n)
        cascade(n // 10)
        print(n)
```
#### 执行过程分析（以 `cascade(123)` 为例）

1. 调用 `cascade(123)`，`n=123`，执行 `else` 分支：
    
    - 打印 `123`
        
    - 调用 `cascade(12)`
        
2. `cascade(12)` 执行：
    
    - 打印 `12`
        
    - 调用 `cascade(1)`
        
3. `cascade(1)` 执行：
    
    - 进入 `if n < 10`，打印 `1`，返回
        
4. 回到 `cascade(12)`，继续执行 `print(n)`，打印 `12`，返回
    
5. 回到 `cascade(123)`，继续执行 `print(n)`，打印 `123`，返回
    

最终输出：

```text

123
12
1
12
123
```
**关键点**：

- 递归调用发生在两个 `print(n)` 之间，因此形成了“先下降后上升”的打印顺序。
    
- 每次递归调用都必须等待内层调用完全结束后才能继续执行后续语句。
    

### 3. 环境图理解

- 每个递归调用创建独立的帧，帧中 `n` 的值不同。
    
- 调用栈：`cascade(123)` → `cascade(12)` → `cascade(1)`，然后从 `cascade(1)` 返回，依次恢复上层帧。
    
- 在 `cascade(12)` 返回之前，`cascade(123)` 的第二个 `print(n)` 不会执行。
    

### 4. 更简洁的版本

可以将 `cascade` 写得更紧凑：

```python

def cascade_short(n):
    print(n)
    if n >= 10:
        cascade_short(n // 10)
        print(n)
```
这个版本将基本情况和递归情况合并，但逻辑相同。选择原则：在清晰度相同的情况下，优先选择更短的实现。

### 5. 应用：`inverse_cascade`

```python

def inverse_cascade(n):
    """打印数字 n 的逆级联，例如 inverse_cascade(123) 打印：
       1
       12
       123
       12
       1
    """
    def grow(x):
        if x < n:
            grow(x * 10)
            print(x)
    def shrink(x):
        if x > 0:
            print(x)
            shrink(x // 10)
    grow(1)
    shrink(n // 10)   # 注意避免重复打印 n
```
**分析**：

- `grow` 函数递归地构造数字（从1开始，每次乘以10），在递归返回时打印，实现上升效果。
    
- `shrink` 函数先打印再递归，实现下降效果。
    
- 调用 `grow(1)` 打印上升部分，然后 `shrink(n//10)` 打印下降部分（去掉最高位避免重复）。
    

---

## 二、树形递归

### 1. 定义

**树形递归**（Tree Recursion）是指递归函数在执行过程中会调用自身多次（通常两次或以上），从而形成类似树状的分支结构。典型的例子是斐波那契数列的递归实现。

### 2. 斐波那契数列的树递归实现

```python

def fib(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1) + fib(n-2)
```
#### 计算过程树形结构

以 `fib(5)` 为例，其调用关系形成一棵树：

```text

            fib(5)
           /      \
      fib(4)      fib(3)
      /    \      /    \
  fib(3) fib(2) fib(2) fib(1)
   /  \   /  \   /  \     |
fib(2)fib(1)fib(1)fib(0)fib(1)fib(0)
 /  \
fib(1)fib(0)
```
- 每个节点代表一次函数调用。
    
- 叶子节点是基本情况（`n=0` 或 `n=1`）。
    
- 树的高度约为 `n`，节点数呈指数增长。
    

#### 重复计算问题

从图中可以看出，`fib(3)` 被计算了两次，`fib(2)` 被计算了三次。这种重复计算导致效率极低：计算 `fib(35)` 可能需要数百万次调用。

**时间复杂度**：O(ϕn)O(ϕn)，其中 ϕ≈1.618ϕ≈1.618（黄金分割比）。

### 3. 使用 `trace` 装饰器观察递归

可以定义一个 `trace` 装饰器来打印每次函数调用和返回的信息：

```python

def trace(fn):
    def traced(n):
        print('Calling', fn.__name__, 'on', n)
        result = fn(n)
        print('Returning', result, 'from', n)
        return result
    return traced
@trace
def fib(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1) + fib(n-2)
fib(4)
```
输出会清晰展示调用顺序和返回值，帮助你理解树递归的执行流程。

---

## 三、整数划分问题

### 1. 问题定义

**整数划分**：将一个正整数 `n` 分解为若干个不超过 `m` 的正整数之和，且各部分按递增顺序排列（即不考虑顺序），求不同分解方式的数目。

**示例**：`count_partitions(6, 4)` 的所有划分方式：

- 2 + 4 = 6
    
- 1 + 1 + 4 = 6
    
- 3 + 3 = 6
    
- 1 + 2 + 3 = 6
    
- 1 + 1 + 1 + 3 = 6
    
- 2 + 2 + 2 = 6
    
- 1 + 1 + 2 + 2 = 6
    
- 1 + 1 + 1 + 1 + 2 = 6
    
- 1 + 1 + 1 + 1 + 1 + 1 = 6
    

共 9 种。

### 2. 递归分解思路

将问题分解为两个互斥且完备的子问题：

1. **至少使用一个 m**：先取出一个 m，剩下的部分 `n-m` 仍然可以用不超过 m 的数划分（因为可以继续使用 m）。所以这部分划分数为 `count_partitions(n - m, m)`。
    
2. **完全不使用 m**：那么只能用不超过 `m-1` 的数来划分 n，即 `count_partitions(n, m - 1)`。
    

因此，总划分数 = 使用至少一个 m 的划分数 + 不使用 m 的划分数。

### 3. 基本情况

- 当 `n == 0` 时：有一种划分方式（什么都不选，即空和），返回 1。
    
- 当 `n < 0` 时：无效划分，返回 0。
    
- 当 `m == 0` 时：没有可用的数，无法划分（除非 `n==0` 已被处理），返回 0。
    

### 4. 递归实现

```python

def count_partitions(n, m):
    """计算将 n 划分为不超过 m 的正整数之和的不同方式数"""
    if n == 0:
        return 1
    elif n < 0:
        return 0
    elif m == 0:
        return 0
    else:
        with_m = count_partitions(n - m, m)
        without_m = count_partitions(n, m - 1)
        return with_m + without_m
```
#### 执行示例：`count_partitions(5, 3)`

分解树（简化）：

```text

count_partitions(5,3)
  ├─ with_m: count_partitions(2,3)
  │    ├─ with_m: count_partitions(-1,3) → 0
  │    └─ without_m: count_partitions(2,2)
  │         ├─ with_m: count_partitions(0,2) → 1
  │         └─ without_m: count_partitions(2,1)
  │              ├─ with_m: count_partitions(1,1)
  │              │    ├─ with_m: count_partitions(0,1) → 1
  │              │    └─ without_m: count_partitions(1,0) → 0
  │              └─ without_m: count_partitions(2,0) → 0
  └─ without_m: count_partitions(5,2)
       ├─ with_m: count_partitions(3,2)
       │    ├─ with_m: count_partitions(1,2)
       │    │    ├─ with_m: count_partitions(-1,2) → 0
       │    │    └─ without_m: count_partitions(1,1)
       │    │         ├─ with_m: count_partitions(0,1) → 1
       │    │         └─ without_m: count_partitions(1,0) → 0
       │    └─ without_m: count_partitions(3,1)
       │         ├─ with_m: count_partitions(2,1)
       │         │    ├─ with_m: count_partitions(1,1) → 1
       │         │    └─ without_m: count_partitions(2,0) → 0
       │         └─ without_m: count_partitions(3,0) → 0
       └─ without_m: count_partitions(5,1)
            ├─ with_m: count_partitions(4,1)
            │    ├─ with_m: count_partitions(3,1)
            │    │    ├─ with_m: count_partitions(2,1)
            │    │    │    ├─ with_m: count_partitions(1,1) → 1
            │    │    │    └─ without_m: count_partitions(2,0) → 0
            │    │    └─ without_m: count_partitions(3,0) → 0
            │    └─ without_m: count_partitions(4,0) → 0
            └─ without_m: count_partitions(5,0) → 0
```
最终求和得到 5（对应五种划分：1+1+1+1+1, 1+1+1+2, 1+2+2, 1+1+3, 2+3）。

### 5. 树递归的特征

- 每个问题分解为两个子问题，形成二叉树结构。
    
- 存在大量重复计算（例如 `count_partitions(2,1)` 被多次调用）。
    
- 与斐波那契类似，效率不高，但递归解法简洁直观。
    

---

## 四、树递归的优化思路

树递归的效率问题源于重复计算。常见的优化方法是**记忆化**（Memoization）：将已经计算过的结果缓存起来，避免重复计算。

以斐波那契为例：

```python

def fib_memo(n, memo={}):
    if n in memo:
        return memo[n]
    if n == 0:
        memo[0] = 0
        return 0
    if n == 1:
        memo[1] = 1
        return 1
    memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)
    return memo[n]
```
这样每个 `n` 只计算一次，时间复杂度降为 O(n)O(n)。

整数划分也可以类似优化，但需要更复杂的键（`(n, m)` 对）。

---

## 五、知识点总结表

|知识点|核心内容|考试重点 / 易混淆点|难度|
|---|---|---|---|
|**递归调用顺序**|函数调用需等待返回，递归形成嵌套栈|`cascade` 函数先下降后上升的打印顺序|⭐⭐|
|**树递归定义**|递归函数调用自身多次，形成树形调用结构|区别于线性递归（单次调用）|⭐⭐|
|**斐波那契树递归**|`fib(n) = fib(n-1) + fib(n-2)`，存在大量重复计算|指数时间复杂度，可用记忆化优化|⭐⭐⭐|
|**trace 装饰器**|打印函数调用和返回信息，帮助调试递归|装饰器的使用和输出解读|⭐⭐|
|**整数划分问题**|递归分解为“用至少一个 m”和“不用 m”两种情况|边界条件：`n==0` 返回 1，`n<0` 或 `m==0` 返回 0|⭐⭐⭐|
|**树递归的优化**|记忆化（缓存）避免重复计算|键的设计（如 `(n,m)`）|⭐⭐⭐|

---

## 六、自测题

### 1. cascade 变体

写出以下代码的输出：

```python

def mystery(n):
    if n < 10:
        print(n)
    else:
        print(n % 10)
        mystery(n // 10)
        print(n % 10)
mystery(1234)
```
<details> <summary>答案</summary> 输出： ``` 4 3 2 1 2 3 4 ``` 每次打印当前最低位，递归处理去掉最低位的部分，然后再次打印最低位，形成回文效果。 </details>

### 2. 树递归调用次数

对于 `fib(5)`，函数 `fib` 被调用了多少次（包括根节点）？提示：可以画树统计。

<details> <summary>答案</summary> 15 次。斐波那契树中节点数满足递推：`T(0)=1, T(1)=1, T(n)=1+T(n-1)+T(n-2)`，计算得 T(5)=15。 </details>

### 3. 整数划分实现

实现一个函数 `count_partitions_iter`，用迭代方式计算整数划分数（提示：可以用动态规划）。

```python

def count_partitions_iter(n, m):
    dp = [[0]*(m+1) for _ in range(n+1)]
    for i in range(n+1):
        dp[i][0] = 0
    for j in range(m+1):
        dp[0][j] = 1
    for i in range(1, n+1):
        for j in range(1, m+1):
            with_j = dp[i-j][j] if i >= j else 0
            without_j = dp[i][j-1]
            dp[i][j] = with_j + without_j
    return dp[n][m]

```

### 4. 思考题

为什么说树递归在某些情况下比迭代更容易编写？请举例说明。

<details> <summary>提示</summary> 树递归直接反映了问题的数学递归定义（如斐波那契、整数划分），代码简洁清晰。而迭代实现往往需要构造复杂的表格或队列，思维负担更重。但树递归效率较低，需要权衡。 </details>

---

## 七、总结与展望

本节课我们学习了递归的调用顺序，并通过斐波那契数列和整数划分两个经典问题引入了树递归的概念。树递归的特点是自然反映问题的分解结构，但可能带来指数级的重复计算。理解树递归有助于掌握分治算法和动态规划的思想。在后续课程中，你将看到树递归在数据结构（如树遍历）和算法（如回溯）中的广泛应用。
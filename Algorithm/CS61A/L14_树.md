# 📘 Lecture 14：树（Tree）—— 完全自学指南

> 树是一种用于表示层次关系的数据结构，在计算机科学中无处不在：文件系统、HTML DOM、组织结构、表达式树……本节课将带你从零构建树的数据抽象，掌握递归处理树的技巧，并通过经典问题（路径求和、计数路径）深化理解。

---

## 一、什么是树？

### 1. 树的直观理解

计算机科学中的树通常是“倒置”的：**根节点**在顶部，**叶子节点**在底部。每个节点可以有多个子节点，形成分支结构。

### 2. 递归定义

树由以下两部分组成：

- 一个**根标签**（root label）：存储在该树根部的值。
    
- 一系列**分支**（branches）：每个分支本身也是一棵树。
    

这种定义是**递归**的：树由更小的树构成。

- **叶子**（leaf）：没有分支的树（即分支列表为空）。
    

> 💡 类比：想象一棵苹果树，主干是根，分支是其他树枝，每个树枝又可以长出更小的树枝，最后是叶子。

### 3. 家族关系术语

为了描述树中的位置，我们借用家族关系：

- **父节点**（parent）：直接包含某个节点的节点。
    
- **子节点**（child）：被某个节点直接包含的节点。
    
- **祖先**（ancestor）：父节点、父节点的父节点等。
    
- **后代**（descendant）：子节点、子节点的子节点等。
    
- **兄弟**（sibling）：同一父节点的子节点。
    

每个节点都有一个**标签**，可以是任意类型的值。

---

## 二、实现树的数据抽象

我们将使用 Python 的列表来表示树。一个树表示为 `[label, [branch1, branch2, ...]]`，其中 `label` 是根标签，`branch` 是子树。

### 1. 构造函数和选择器


```python

def tree(label, branches=[]):
    """构造一棵树，label 为根标签，branches 为分支列表（默认为空，即叶子）。"""
    for branch in branches:
        assert is_tree(branch), '分支必须是树'
    return [label] + list(branches)   # 使用列表存储：第一个元素是标签，后续是分支
def label(tree):
    """返回树的根标签"""
    return tree[0]
def branches(tree):
    """返回树的分支列表"""
    return tree[1:]
def is_tree(tree):
    """验证 tree 是否为合法的树结构"""
    if type(tree) != list or len(tree) < 1:
        return False
    for branch in branches(tree):
        if not is_tree(branch):
            return False
    return True
def is_leaf(tree):
    """判断树是否为叶子（没有分支）"""
    return not branches(tree)   # 分支列表为空
```
**注意**：

- 构造函数中通过断言确保所有分支都是树。
    
- 选择器 `label` 和 `branches` 直接操作列表。
    
- 验证函数用于确保数据结构的完整性。
    

### 2. 示例：创建简单的树

```python

>>> t = tree(3, [tree(1), tree(2, [tree(0)])])
>>> label(t)
3
>>> branches(t)
[ [1], [2, [0]] ]
>>> is_leaf(branches(t)[0])   # 第一个分支是叶子
True
>>> is_leaf(branches(t)[1])   # 第二个分支不是叶子
False
```
---

## 三、递归构建树：斐波那契树

树的递归定义天然适合用递归函数构建。我们以斐波那契树为例：一棵表示斐波那契计算过程的树。

### 1. 斐波那契树定义

`fib_tree(n)` 返回一棵树，其根标签为第 n 个斐波那契数，左子树为 `fib_tree(n-2)`，右子树为 `fib_tree(n-1)`（当 n≥2）。基本情况：`n=0` 或 `n=1` 时返回叶子，标签分别为 0 和 1。

python

def fib_tree(n):
    """返回一棵表示斐波那契计算过程的树"""
    if n <= 1:
        return tree(n)
    else:
        left = fib_tree(n-2)
        right = fib_tree(n-1)
        return tree(label(left) + label(right), [left, right])

### 2. 示例：`fib_tree(4)`

```python

>>> t = fib_tree(4)
>>> t
[3, [1, [0], [1]], [2, [1], [1, [0], [1]]]]   # 结构复杂
```
为了可视化，我们稍后会学习如何打印树。

### 3. 叶子计数

可以递归统计树的叶子数量：

```python

def count_leaves(t):
    """返回树 t 的叶子节点数"""
    if is_leaf(t):
        return 1
    else:
        return sum([count_leaves(b) for b in branches(t)])
```
对于 `fib_tree(4)`，叶子数应为 5（实际上第 5 个斐波那契数）。一般地，`fib_tree(n)` 的叶子数等于 `fib(n+1)`。

---

## 四、处理树的函数

树处理函数通常也是递归的，因为它们需要遍历整棵树。

### 1. 只递增叶子标签：`increment_leaves`

```python

def increment_leaves(t):
    """返回一棵新树，叶子标签加 1，内部节点标签不变"""
    if is_leaf(t):
        return tree(label(t) + 1)
    else:
        bs = [increment_leaves(b) for b in branches(t)]
        return tree(label(t), bs)
```
- 如果是叶子，返回标签加 1 的新叶子。
    
- 否则，递归处理每个分支，当前节点标签不变。
    

### 2. 递增所有标签：`increment`

```python

def increment(t):
    """返回一棵新树，所有节点标签加 1"""
    return tree(label(t) + 1, [increment(b) for b in branches(t)])
```
- 这里不需要区分叶子，因为列表推导式作用于空列表时，递归自然终止。
    

**对比**：

- `increment_leaves` 需要显式处理叶子情况。
    
- `increment` 更简洁，利用空列表特性。
    

---

## 五、打印树（带缩进）

为了直观查看树的结构，我们可以编写一个打印函数，通过缩进展示层级。

### 1. 基本打印函数

```python

def print_tree(t, indent=0):
    """打印树，indent 为当前缩进空格数"""
    print(' ' * indent + str(label(t)))
    for b in branches(t):
        print_tree(b, indent + 2)   # 每层增加 2 个空格
```
### 2. 示例：`fib_tree(4)` 的打印

```python

>>> print_tree(fib_tree(4))
3
  1
    0
    1
  2
    1
    1
      0
      1
```
这清晰地显示了树的层次结构。

---

## 六、递归处理树的两种策略

在处理树时，我们有两种递归策略：

- **返回值构建**：通过处理子树的返回值，在返回过程中组合结果（如 `count_leaves`）。
    
- **参数传递构建**：将中间结果作为参数向下传递，在递归过程中累积信息（如路径和问题）。
    

### 1. 传统递归（返回值）

以阶乘为例：

```python

def fact(n):
    if n == 0:
        return 1
    else:
        return n * fact(n-1)
```
计算在返回时进行。

### 2. 累积参数（尾递归风格）

```python

def fact_times(n, k):
    """返回 k * n!"""
    if n == 0:
        return k
    else:
        return fact_times(n-1, k * n)
```
计算在递归调用前进行，结果通过参数传递。

### 3. 树上的应用

对于树，两种策略都有用武之地。例如，**路径求和**问题更适合用累积参数。

---

## 七、应用：打印所有根到叶的路径和

### 1. 问题描述

给定一棵树，打印从根到每个叶子节点的路径上所有节点标签之和。

例如，树：

```text

    3
   / \
  4   5
      \
       6
```
路径：`3-4` 和为 7，`3-5-6` 和为 14。

### 2. 累积参数实现

```python

def print_sums(t, so_far):
    """打印从根到当前节点 so_far 的路径和，并递归处理分支"""
    new_sum = so_far + label(t)
    if is_leaf(t):
        print(new_sum)
    else:
        for b in branches(t):
            print_sums(b, new_sum)
```
调用：`print_sums(t, 0)`

**工作原理**：

- `so_far` 记录到达当前节点之前已累积的和。
    
- 到达叶子时，打印最终和。
    
- 非叶子则对每个分支递归，传递更新后的和。
    

### 3. 扩展到字符串拼接

这个模式同样适用于字符串构建，例如拼出路径单词：

```python

def print_words(t, so_far):
    new_str = so_far + label(t)
    if is_leaf(t):
        print(new_str)
    else:
        for b in branches(t):
            print_words(b, new_str)
```
---

## 八、计数符合特定总和的路径

这是一个更复杂的题目：统计树中所有**从根到任意节点**（不一定是叶子）的路径，其节点标签之和等于给定目标值。

### 1. 问题重述

输入：一棵树和一个目标总和 `total`。输出：满足条件的路径数量（路径从根开始，可以在任何节点结束）。

### 2. 示例

树结构（用嵌套列表表示）：

```python

t = tree(3, [tree(-1), tree(1, [tree(2, [tree(1)]), tree(3)]), tree(1, [tree(-1)])])
```
目标总和为 7 的路径有两条：

- 3 → 1 → 2 → 1 (3+1+2+1=7)
    
- 3 → 1 → 3 (3+1+3=7)
    

目标总和为 4 的路径有两条（不延伸到叶子）：

- 3 → 1 (3+1=4)
    
- 3 → 1 (另一分支) 但注意检查。
    

目标总和为 3 的路径有两条：

- 3（根节点本身）
    
- 3 → 1 → -1 (3+1-1=3)
    

### 3. 递归思路

我们可以设计一个递归函数 `count_paths(t, total)`，它返回以 `t` 为根的子树中，从根开始到任意节点且和为 `total` 的路径数。

**关键观察**：

- 路径可以在当前节点结束：如果 `label(t) == total`，则算一条。
    
- 路径也可以延续到子节点：对于每个分支，我们需要寻找和为 `total - label(t)` 的路径（因为当前节点已经贡献了 `label(t)`）。
    
- 注意：即使当前节点满足条件，仍需要继续在子节点中寻找，因为可能有更长的路径（例如总和中包含了当前节点，但后续加正负抵消后仍然等于原总和？实际上，如果当前节点等于 `total`，后续路径和必须为 0 才能继续？不，我们考虑的是从根开始的连续路径，一旦当前节点满足条件，这条路径就结束了；但是可能还有另一条路径从根出发经过当前节点再往下走，最终总和也等于 `total`？那意味着 `label(t) + 某分支和 = total`，这相当于分支和 = 0，分支和为零的路径可能存在。所以即使当前节点满足条件，我们仍需在子节点中寻找和为 0 的路径。因此，我们应无条件递归所有分支，剩余总和为 `total - label(t)`。
    

**递归公式**：

```text

count_paths(t, total) = 
    (1 if label(t) == total else 0) 
    + sum(count_paths(b, total - label(t)) for b in branches(t))
```
### 4. 实现

```python

def count_paths(t, total):
    """返回树 t 中从根到任意节点路径和为 total 的路径数"""
    if is_leaf(t):
        # 叶子节点：只能自己作为路径
        return 1 if label(t) == total else 0
    else:
        # 检查当前节点是否结束路径
        found = 1 if label(t) == total else 0
        # 递归每个分支，剩余总和为 total - label(t)
        for b in branches(t):
            found += count_paths(b, total - label(t))
        return found
```
**注意**：这里并没有在递归时排除当前节点已经匹配的情况，因为剩余总和可能为 0，而分支中可能存在和为零的路径（例如空路径？但空路径不算）。实际上，分支递归会考虑从该分支的根开始的和为 `total - label(t)` 的路径。这正好对应了经过当前节点继续向下的路径。

### 5. 验证

用示例树测试：

```python

>>> t = tree(3, [tree(-1), tree(1, [tree(2, [tree(1)]), tree(3)]), tree(1, [tree(-1)])])
>>> count_paths(t, 7)
2
>>> count_paths(t, 4)
2   # 具体是哪两条？3+1 和 3+1（另一个分支）? 需要确认
>>> count_paths(t, 3)
2   # 3 和 3+1-1
```
**思考**：为什么 `count_paths(t, 4)` 返回 2？从根 3 出发，两个值为 1 的子节点各自形成路径 3+1=4。注意还有一个分支是 -1，3+(-1)=2，不等于 4。所以两条，正确。

---

## 九、知识点总结表

|知识点|核心内容|考试重点 / 易混淆点|难度|
|---|---|---|---|
|**树的递归定义**|树由根标签和分支列表组成，分支本身是树|区分节点和标签；叶子是空分支的树|⭐⭐|
|**树的抽象实现**|用列表 `[label, branch1, ...]` 表示，构造函数和选择器|确保分支合法性；理解 `is_tree` 验证|⭐⭐|
|**斐波那契树**|递归构建树，标签为斐波那契数，反映计算过程|叶子数与斐波那契数的关系|⭐⭐⭐|
|**树处理函数**|递归遍历所有节点，可修改标签或收集信息|`increment` 与 `increment_leaves` 的差异|⭐⭐⭐|
|**打印树**|通过缩进展示层次，递归传递缩进级别|理解字符串乘法生成空格|⭐|
|**递归策略**|返回值构建 vs 参数累积|路径和问题适合参数累积|⭐⭐⭐|
|**路径和打印**|从根到叶的路径和，用参数 `so_far` 累积|何时打印结果（仅在叶子）|⭐⭐|
|**计数路径**|统计从根到任意节点和为定值的路径数|当前节点匹配后仍需递归（剩余和为0）|⭐⭐⭐⭐|
|**项目管理**|Project 2 分阶段提交，注意截止时间|优先级管理|⭐|

---

## 十、自测题

### 1. 树的基础

给定 `t = tree(5, [tree(2), tree(3, [tree(1), tree(7)])])`，写出：

- `label(t)`
    
- `branches(t)` 的长度
    
- `is_leaf(branches(t)[0])`
    
- `is_leaf(branches(t)[1])`
    

```
- `label(t)` = 5
    
- `len(branches(t))` = 2
    
- `is_leaf(branches(t)[0])` = True（因为 `tree(2)` 没有分支）
    
- `is_leaf(branches(t)[1])` = False（它有分支）
    
```

### 2. 实现 `double_tree`

编写一个函数 `double_tree(t)`，返回一棵新树，其中每个节点的标签都变为原来的两倍。



```python

def double_tree(t):
    return tree(label(t) * 2, [double_tree(b) for b in branches(t)])

```

### 3. 收集所有节点值

实现 `collect_labels(t)`，返回一个列表，包含树中所有节点的标签（任意顺序）。

```python

def collect_labels(t):
    result = [label(t)]
    for b in branches(t):
        result.extend(collect_labels(b))
    return result

```
### 4. 路径和打印

给定树 `t = tree(1, [tree(2), tree(3, [tree(4)])])`，写出 `print_sums(t, 0)` 的输出。

```text

3   # 1+2
8   # 1+3+4
```

### 5. 计数路径（进阶）

修改 `count_paths` 使其能够统计从任意节点开始（不一定是根）到任意节点结束的路径和等于目标值。提示：可以对每个节点作为根调用原函数。

```
可以定义一个辅助函数 `count_all_paths(t, total)`，它返回树 `t` 中所有可能的路径（起始节点任意）和为 `total` 的数量。这可以通过递归实现：当前节点作为起点的路径数（即原 `count_paths`），加上所有子树中的路径数。
```

---

## 十一、总结与展望

本节课我们学习了树这一重要的递归数据结构。通过构造函数、选择器建立了数据抽象，并通过斐波那契树、路径求和等问题掌握了递归处理树的技巧。你学会了：

- 树的递归定义和抽象实现。
    
- 如何递归构建树（斐波那契树）。
    
- 如何编写树处理函数（递增叶子、递增所有节点）。
    
- 两种递归策略：返回值构建 vs 参数累积。
    
- 打印树以可视化结构。
    
- 解决路径相关的问题（打印和、计数）。
    

树是后续学习二叉树、二叉搜索树、堆、Trie 等的基础，也是算法面试中的常客。建议你多动手实现各种树操作，加深理解。
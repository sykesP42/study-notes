# 📘 Lecture 29：Scheme 列表

> Scheme 列表是一种基于链表的递归数据结构，是 Lisp 语言家族的核心。通过学习 Scheme 列表，你将深入理解函数式编程中“数据即代码”的理念，并掌握一系列强大的列表处理函数。本节课将带你从零构建列表，探索符号引用，并最终用递归和高阶函数解决实际子集问题。

---

## 一、Scheme 列表基础

### 1.1 历史背景：令人困惑的命名

在 1950 年代末，LISP 语言诞生，其命名风格深受早期计算机科学家喜爱——他们偏爱令人困惑的首字母缩写词。Scheme 作为 Lisp 的方言，继承了这些历史术语。

### 1.2 列表的底层实现：链表

Scheme 列表本质上是通过**链表**实现的。每个节点由两个部分组成：

- **car**：存储当前元素（首元素）。
    
- **cdr**：指向剩余列表的引用。
    

空列表用特殊符号 `nil` 表示。

虽然底层是链表，但在 Scheme 中列表的标准显示方式为括号包围、空格分隔的元素序列，例如 `(1 2 3)`。

### 1.3 三个核心过程

|过程|作用|示例|结果|
|---|---|---|---|
|`cons`|构造一个新节点（将元素与已有列表连接）|`(cons 2 nil)`|`(2)`|
|`car`|返回列表的第一个元素|`(car (cons 2 nil))`|`2`|
|`cdr`|返回列表的剩余部分（去掉第一个元素）|`(cdr (cons 2 nil))`|`nil`|

**命名来源**：`car` 和 `cdr` 源自早期 IBM 704 计算机的术语“Contents of Address Register”和“Contents of Decrement Register”，虽然名字奇怪，但功能简单。

**`nil`**：内置的空列表标记，同时也是列表的结束标志。

### 1.4 构建多元素列表

通过嵌套 `cons` 可以构建任意长度的列表：


```scheme

(cons 1 (cons 2 (cons 3 nil)))   ; => (1 2 3)
```
Scheme 提供了 `list` 函数作为快捷方式：

```scheme

(list 1 2 3)   ; => (1 2 3)
```
**注意**：`list` 可以接受任意多个参数，并返回包含这些参数的列表。

---

## 二、列表可视化与判断

### 2.1 可视化工具

如果你使用的是支持绘图的 Scheme 解释器（如 STk），可以使用以下命令可视化列表结构：

- `(draw <list>)`：显示链表的图形化表示（节点和箭头）。
    
- `(autodraw)`：开启自动可视化，之后每个创建的列表都会自动绘制。
    
- `(visualize)`：显示当前程序的环境图。
    

### 2.2 列表判断函数

|函数|用途|示例|
|---|---|---|
|`(list? obj)`|判断对象是否为列表|`(list? '(1 2))` → `#t`|
|`(null? obj)`|判断对象是否为空列表|`(null? nil)` → `#t`|
|`(pair? obj)`|判断对象是否为 cons 对|`(pair? '(1 2))` → `#t`|

注意：

- 数字 `3` 不是列表：`(list? 3)` → `#f`。
    
- `nil` 是列表：`(list? nil)` → `#t`。
    
- `(car s)` 得到的是元素，不一定为列表。
    

---

## 三、符号引用与引号（Quote）

Lisp 的一大特色是**符号即数据**。通过**引用**（quote），我们可以阻止表达式求值，直接获取符号本身。

### 3.1 基本引用语法

- 单引号 `'` 是 `(quote ...)` 的简写。
    
- 例如：`'a` 等价于 `(quote a)`，结果就是符号 `a`。
    
- `'(1 2)` 等价于 `(list '1 '2)`，得到列表 `(1 2)`（元素是数字，但数字自求值，所以效果同 `(list 1 2)`）。
    

### 3.2 混合使用

可以部分引用，例如：

```scheme

(define b 2)
(list 'a b)   ; => (a 2)
```
如果直接使用未定义的符号而不引用，会报错：

```scheme

(list a)   ; 错误: 符号 a 未定义
```
### 3.3 嵌套引用

引号可以嵌套，产生嵌套列表结构：

```scheme

'(1 (2 3) 4)   ; => (1 (2 3) 4)
```
访问嵌套列表的元素：

```scheme

(car (cdr '(1 (2 3) 4)))   ; => (2 3)
(car (cdr (car (cdr '(1 (2 3) 4)))))   ; => 3
```
同样的操作也适用于符号列表，如 `'(a (b c) d)`。

> 💡 **引号的作用**：将符号视为数据，而不是变量名。这是 Lisp 元编程能力的基础。

---

## 四、高阶列表处理函数

Scheme 提供了一系列内置函数来处理列表，它们都遵循函数式编程风格（不修改原列表，返回新列表）。

### 4.1 `append` —— 合并多个列表

`(append list1 list2 ...)` 返回一个新列表，包含所有输入列表的元素**顺序连接**。

```scheme

(append '(1 2) '(3 4))        ; => (1 2 3 4)
(append '(1 2) '(3 4) '(5 6)) ; => (1 2 3 4 5 6)
```
与 `list` 的对比：

```scheme

(list '(1 2) '(3 4))          ; => ((1 2) (3 4))  创建嵌套列表
(append '(1 2) '(3 4))        ; => (1 2 3 4)      展开元素
```
### 4.2 `map` —— 对每个元素应用函数

`(map proc list1 list2 ...)` 将过程 `proc` 应用于列表中每个对应位置的元素，返回结果列表。

```scheme

(map even? '(1 2 3 4))        ; => (#f #t #f #t)
(map (lambda (x) (* x 2)) '(1 2 3)) ; => (2 4 6)
```
`map` 可以接受多个列表，但要求它们长度相同，且过程接受的参数个数必须与列表个数一致：

```scheme

(map + '(1 2 3) '(4 5 6))     ; => (5 7 9)
```
### 4.3 `filter` —— 筛选满足条件的元素

`(filter pred list)` 返回一个新列表，包含 `list` 中所有满足谓词 `pred` 的元素。

```scheme

(filter even? '(1 2 3 4 5))    ; => (2 4)
(filter list? '(1 (2 3) 4 (5))) ; => ((2 3) (5))
```
### 4.4 `apply` —— 将列表作为参数调用函数

`(apply proc list)` 将列表 `list` 中的元素作为参数传递给过程 `proc`，并调用 `proc` 一次。

```scheme

(apply + '(1 2 3 4))           ; => 10，等价于 (+ 1 2 3 4)
(apply quotient '(10 5))       ; => 2
```
**`apply` 与 `map` 的区别**：

- `map` 对每个元素分别调用过程，结果是一个列表。
    
- `apply` 将列表整体作为参数调用过程一次，结果是单个值。
    

```scheme

(map + '(1 2 3))               ; => (1 2 3)，这里 + 被应用到每个元素？不对，map 要求过程接受单个参数，所以 (map + '(1 2 3)) 会尝试将 + 应用到 1，+ 需要至少两个参数，所以会报错。更正：正确的例子是 (map (lambda (x) (+ x 1)) '(1 2 3))。
```
避免混淆：`map` 和 `apply` 通常结合使用，例如用 `apply` 求总和，用 `map` 求每个数的平方。

---

## 五、综合案例：偶数子集问题

### 5.1 问题定义

给定一个数字列表 `s`（例如 `(3 4 5 7)`），我们希望找出**所有非空子集**，使得子集中元素的和为偶数。子集必须保持元素在原列表中的顺序，且不能为空。

**示例**：对于 `(3 4 5 7)`，和为偶数的非空子集有：

- `(4)` （4 是偶数）
    
- `(3 5)` （3+5=8 偶数）
    
- `(5 7)` （5+7=12 偶数）
    
- `(3 4 5)` （3+4+5=12 偶数）
    
- `(4 5 7)` （4+5+7=16 偶数）
    
- `(3 4 5 7)` （3+4+5+7=19 奇数，排除）
    
- 等等，需要全部列出。
    

### 5.2 递归解法思路

我们可以定义两个递归函数：

- `even-subsets`：返回所有和为偶数的非空子集。
    
- `odd-subsets`：返回所有和为奇数的非空子集。
    

为什么需要两个？因为一个子集的和的奇偶性可以通过首元素和剩余部分的奇偶性组合得到：

- 偶数 + 偶数 = 偶数
    
- 奇数 + 奇数 = 偶数
    
- 偶数 + 奇数 = 奇数
    
- 奇数 + 偶数 = 奇数
    

因此，在处理当前元素时，我们需要根据当前元素的奇偶性，从剩余部分的子集中选择合适奇偶性的子集进行组合。

#### 递归定义（伪代码）

```text

even-subsets(s):
  如果 s 为空: 返回空列表 (无子集)
  否则:
    let first = car(s)
    let rest = cdr(s)
    let even-rest = even-subsets(rest)
    let odd-rest = odd-subsets(rest)
    情况1: 不包含 first 的偶数子集（即 even-rest）
    情况2: 包含 first 的子集：
       如果 first 是偶数：
          - 将 first 添加到 even-rest 中的每个子集（得到偶数+偶数的组合）
          - 如果 first 自身作为子集（单元素偶数）也是有效的
       如果 first 是奇数：
          - 将 first 添加到 odd-rest 中的每个子集（得到奇数+奇数的组合）
          - 注意：单元素奇数不能作为偶数子集，所以不加 first 自身
    将情况1和情况2合并返回。
```
同理，`odd-subsets` 也有类似的递归。

#### Scheme 实现（直接递归）

```scheme

(define (even-subsets s)
  (if (null? s)
      '()   ; 空列表没有非空子集，所以返回空（注意：递归中会用到空列表表示无子集）
      (let ((first (car s))
            (even-rest (even-subsets (cdr s)))
            (odd-rest (odd-subsets (cdr s))))
        (append
         even-rest   ; 情况1: 不包含 first 的偶数子集
         (if (even? first)
             (append (list (list first))   ; 单元素子集
                     (map (lambda (sub) (cons first sub)) even-rest))
             (map (lambda (sub) (cons first sub)) odd-rest))))))
(define (odd-subsets s)
  (if (null? s)
      '()
      (let ((first (car s))
            (even-rest (even-subsets (cdr s)))
            (odd-rest (odd-subsets (cdr s))))
        (append
         odd-rest
         (if (even? first)
             (map (lambda (sub) (cons first sub)) odd-rest)
             (append (list (list first))
                     (map (lambda (sub) (cons first sub)) even-rest)))))))
```
这个实现可以工作，但存在大量重复计算（两次递归调用 `(cdr s)`），并且代码冗长。

### 5.3 高阶函数优化

观察发现 `even-subsets` 和 `odd-subsets` 结构高度相似，可以抽象出一个辅助函数 `subset-helper`，它接受一个**奇偶性判断函数** `parity?`（例如 `even?` 或 `odd?`），然后根据首元素的奇偶性选择组合方式。

但更简洁的方法是**先生成所有非空子集，再用 `filter` 筛选和为偶数的子集**。这样代码更直观，虽然效率稍低（生成所有子集是指数级），但对于中等规模列表是可接受的。

### 5.4 先生成所有子集再过滤

首先，如何生成一个列表的所有非空子集（保持顺序）？

这是一个经典的递归问题：

- 基本情况：空列表 → 没有子集（返回 `'()`）。
    
- 递归情况：包含首元素的子集 + 不包含首元素的子集。
    

```scheme

(define (subsets s)
  (if (null? s)
      '(() )   ; 包含空子集，稍后去掉
      (let ((first (car s))
            (rest-subsets (subsets (cdr s))))
        (append rest-subsets
                (map (lambda (sub) (cons first sub)) rest-subsets)))))
;; 去除空子集
(define (non-empty-subsets s)
  (filter (lambda (sub) (not (null? sub))) (subsets s)))
```
然后筛选和为偶数的子集：

```scheme

(define (sum-even? lst)
  (even? (apply + lst)))
(define (even-subsets-filter s)
  (filter sum-even? (non-empty-subsets s)))
```
测试：

```scheme

> (even-subsets-filter '(3 4 5 7))
((4) (5 7) (3 5) (3 4 5) (4 5 7) ...)   ; 期望的输出
```
这种方法逻辑清晰，代码量少，是函数式编程风格的典范。

---

## 六、知识点总结表

|知识点|核心内容|考试重点 / 易混淆点|难度|
|---|---|---|---|
|**链表结构**|`cons` 构造节点，`car` 取首元素，`cdr` 取剩余部分，`nil` 为空列表|嵌套 `cons` 与 `list` 的区别；链表与 Python 列表的类比|⭐⭐|
|**列表判断**|`list?`, `null?`, `pair?`|`(null? nil)` 为真，`(list? 3)` 为假|⭐|
|**引用（quote）**|`'` 阻止求值，返回符号本身|`'(a b)` 与 `(list a b)` 的区别；嵌套引用的理解|⭐⭐⭐|
|**列表处理函数**|`append`（连接）、`map`（映射）、`filter`（筛选）、`apply`（展开调用）|`append` 展开元素，`list` 创建嵌套；`map` 与 `apply` 的差异|⭐⭐⭐|
|**偶数子集问题**|递归生成所有偶数和的非空子集|两种解法：直接递归奇偶分离 vs 先生成所有子集再过滤|⭐⭐⭐⭐|

---

## 七、自测题

### 1. 基础操作

写出以下 Scheme 表达式的求值结果：

- `(cons 1 nil)`
    
- `(car (cdr (list 1 2 3)))`
    
- `(cdr (cons 1 (cons 2 nil)))`
    
- `(list? (cons 1 2))`（提示：`(cons 1 2)` 不是一个标准列表，因为 `cdr` 不是列表）
    
- `(null? '())`
    
ans:

- `(1)`
    
- `2`
    
- `(2)`
    
- `#f`（因为 `(cons 1 2)` 不是以 `nil` 结尾的列表，它只是一个 pair）
    
- `#t`
    

### 2. 引用与求值

写出结果：

- `'(+ 1 2)`
    
- `(list '+ 1 2)`
    
- `(eval (list '+ 1 2))`（假设 `eval` 可用）


ans:

- `(+ 1 2)`（一个包含符号 `+` 和数字的列表）
    
- `(+ 1 2)`（同样，因为 `list` 对参数求值，`'+` 得到符号 `+`，数字自求值）
    
- `3`（`eval` 将列表 `(+ 1 2)` 作为表达式求值）
    


### 3. 列表处理

用 `map`、`filter` 和 `apply` 实现一个函数 `(sum-of-squares-of-evens lst)`，计算列表中所有偶数的平方和。


```scheme

(define (sum-of-squares-of-evens lst)
  (apply + (map (lambda (x) (* x x))
                (filter even? lst))))

```

### 4. 偶数子集优化

解释为什么直接递归奇偶分离的方案效率可能低于“先生成所有子集再过滤”的方案。


直接递归方案对每个子问题都递归调用两次 `(cdr s)`，导致大量重复计算，时间复杂度 O(2^n)。先生成所有子集也是 O(2^n)，但代码简单且容易优化（例如用记忆化）。在实际中，两者复杂度相当，但过滤方案更简洁易懂。


### 5. 思考题

如何修改 `even-subsets-filter`，使其返回的子集保持与原列表相同的顺序（即不能像 `(5 7)` 和 `(7 5)` 那样乱序）？我们的实现已经保持了顺序，因为递归生成子集时保持了元素的相对顺序。请验证。



我们的 `subsets` 函数在递归中始终将首元素放在生成的子集前面，因此保持了原列表的顺序。例如 `(3 5)` 会出现，而 `(5 3)` 不会出现。




---

## 八、总结与展望

本节课我们深入探索了 Scheme 列表的方方面面：

- 链表结构（`cons`、`car`、`cdr`、`nil`）。
    
- 列表的创建、判断和可视化。
    
- 符号引用机制及其在元编程中的应用。
    
- 强大的高阶列表处理函数（`append`、`map`、`filter`、`apply`）。
    
- 通过偶数子集问题，综合运用递归和函数式思维解决问题。
    

Scheme 列表不仅是数据容器，更是 Lisp 语言“代码即数据”哲学的核心体现。掌握这些知识，你将能理解许多函数式编程语言的精髓，并为后续学习解释器、宏等高级主题打下坚实基础。
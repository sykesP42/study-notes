# 📘 Lecture 4：高阶函数与抽象

> 本笔记从斐波那契数列的迭代实现开始，探讨控制语句与函数的本质区别，深入逻辑运算符的短路特性，并系统性地引入高阶函数——将函数作为参数和返回值。这是函数式编程思想的基石，帮助你写出更抽象、复用性更强的代码。

---

## 一、斐波那契数列

### 1. 定义与起源

**斐波那契数列**（Fibonacci sequence）定义为：

- 第0项：`0`
    
- 第1项：`1`
    
- 第 n项（n≥2）：前两项之和
    

即：0,1,1,2,3,5,8,13,21,34,…

> 📜 历史：斐波那契（Leonardo Fibonacci）在13世纪通过《算盘书》将此数列引入西方，但早在印度数学中已有记载。数列与黄金比例、自然现象（如花瓣数、螺旋结构）密切相关。

### 2. 索引规则

- 采用 **从0开始** 的索引：`fib(0) = 0`，`fib(1) = 1`，`fib(5) = 5`。
    
- 这与Python列表索引一致，但需注意日常生活中的“第几个”有时从1开始，容易混淆。
    

### 3. 黄金螺旋

用斐波那契数作为正方形边长拼接，可绘制出**黄金螺旋**（近似）。这种螺旋在自然界（如鹦鹉螺壳、向日葵种子排列）中常见，被认为具有美学平衡感。

### 4. 迭代实现：`while` 循环

```python

def fib(n):
    """返回第n个斐波那契数（n>=0）"""
    pred, curr = 0, 1   # 第0项和第1项
    k = 1               # 当前已经计算到第k项（curr是第k项）
    while k < n:
        pred, curr = curr, pred + curr
        k = k + 1
    return curr

```
#### 执行过程追踪（以 `fib(5)` 为例）：

|迭代次数|`k` (循环前)|`pred`|`curr`|条件 `k < 5`|更新后 `pred, curr`|更新后 `k`|
|---|---|---|---|---|---|---|
|初始|1|0|1|True|1, 1|2|
|1|2|1|1|True|1, 2|3|
|2|3|1|2|True|2, 3|4|
|3|4|2|3|True|3, 5|5|
|4|5|3|5|False|循环结束，返回 `curr=5`||

> ✅ 该实现能正确处理 `n=0` 吗？  
> 当 `n=0` 时，`k=1`，条件 `1 < 0` 为假，循环不执行，返回 `curr=1`，但正确结果应为 `0`。因此该版本**不适用于 n=0**。

### 5. 改进版本：兼容 `n=0`

```python

def fib(n):
    pred, curr = 1, 0   # 注意初始值交换
    k = 0
    while k < n:
        pred, curr = curr, pred + curr
        k = k + 1
    return curr
```
- 初始 `pred=1, curr=0` 使得 `k=0` 时返回 `curr=0`（即第0项）。
    
- 对 `n>=1`，迭代次数与原始版本相同，结果一致。
    

> 💡 两种实现的数学等价性：通过变换初始状态，可以统一边界条件。

---

## 二、控制语句的作用

控制语句（如 `if`、`while`）与函数有本质区别：

- **函数**：接收参数，返回值，对参数求值后执行函数体。
    
- **控制语句**：**控制代码的执行路径**（是否执行、执行多少次），不进行参数求值，而是直接根据条件决定。
    

理论上可以用函数模拟控制流（如用三目运算符），但会牺牲可读性和效率。控制语句是编程语言提供的基础设施，让我们能清晰表达分支和循环。

---

## 三、if 语句

### 1. 语法结构

```python

if <条件>:
    <代码块>
elif <条件>:
    <代码块>
else:
    <代码块>
```
- `if` 是必需部分。
    
- `elif` 可以有0个或多个。
    
- `else` 最多一个，且必须放在最后。
    

### 2. 执行规则

1. 按顺序评估每个条件表达式（在布尔上下文中）。
    
2. 遇到第一个为**真值**的条件，执行对应的代码块，然后跳过剩余子句。
    
3. 若所有条件都为假，执行 `else` 代码块（如果存在）。
    

> ⚠️ **关键**：条件表达式是**短路求值**的，一旦找到真值，后续条件不再评估。

### 3. 函数实现的局限性

考虑用函数模拟 `if`：

```python

def if_(condition, true_func, false_func):
    if condition:
        return true_func()
    else:
        return false_func()
```
但调用 `if_` 时，`true_func()` 和 `false_func()` 作为参数，在进入函数体**之前**就已经被求值了！这会导致两个分支都被执行，可能引发错误（例如对负数开平方）。这就是为什么我们需要语言内置的 `if` 语句——它只执行选中的分支。

---

## 四、逻辑运算符的短路特性

### 1. `and` 运算符

```python

<左表达式> and <右表达式>
```
求值规则：

- 先求左表达式。
    
- 若左表达式为假，直接返回该假值（不计算右表达式）。
    
- 否则，求右表达式并返回其结果。
    

#### 示例

```python

0 and 3      # 返回 0
2 and 3      # 返回 3
'' and 5     # 返回 ''
```
### 2. `or` 运算符

```python

<左表达式> or <右表达式>
```
求值规则：

- 先求左表达式。
    
- 若左表达式为真，直接返回该真值（不计算右表达式）。
    
- 否则，求右表达式并返回其结果。
    

#### 示例

```python

2 or 3       # 返回 2
0 or 3       # 返回 3
'' or 5      # 返回 5
```
### 3. 真值系统

Python 中所有值都可以在布尔上下文中解释为真或假：

- **假值**：`False`、`0`、`0.0`、`''`（空字符串）、`None`、`[]`（空列表）、`{}`（空字典）等。
    
- **真值**：所有其他值。
    

> 💡 逻辑运算符返回的是**实际值**（不强制转换为布尔型），这使得它们可以用于条件赋值。

### 4. 应用示例：短路保护

#### 示例1：安全地计算大平方根

```python

def has_big_sqrt(x):
    """如果 x 有实数平方根且平方根大于10，返回True，否则返回False"""
    return x > 0 and (x ** 0.5) > 10
```
- 如果 `x <= 0`，左表达式为假，直接返回 `False`，不会计算 `x ** 0.5`，避免了负数开平方的错误。
    

测试：

```python

has_big_sqrt(1)      # False
has_big_sqrt(1000)   # True
has_big_sqrt(-1000)  # False（不会报错）
```
#### 示例2：避免除零错误

```python

def reasonable(n):
    """判断 n 是否“合理”：n 不为0且 1/n 不等于0（对于极大数可能舍入为0）"""
    return n == 0 or 1/n != 0
```
- 如果 `n == 0`，左表达式为真，直接返回 `True`，不会计算 `1/n`，避免了除零错误。
    
- 当 `n` 极大时，`1/n` 可能被舍入为 `0`，此时 `1/n != 0` 为假，整个表达式返回 `False`。
    

---

## 五、高阶函数

### 1. 概括模式：从具体到抽象

观察三个几何图形的面积公式：

- 正方形：area=1⋅r2area=1⋅r2
    
- 圆形：area=π⋅r2area=π⋅r2
    
- 正六边形：area=332⋅r2area=233​​⋅r2
    

它们具有**共同结构**：`常数 * r^2`。不同之处仅在于常数因子。我们可以写一个通用函数，将常数作为参数传入：

```python

def area(length, constant):
    """计算规则图形的面积，其中 constant 是形状特定的系数"""
    assert length > 0, "长度必须为正"
    return constant * length ** 2
```
这样，正方形面积：`area(5, 1)`，圆形面积：`area(5, math.pi)`，六边形面积：`area(5, 3 * math.sqrt(3) / 2)`。

> ✅ 这种**参数化**是抽象的第一步：将共同模式提取出来，差异部分作为参数。

### 2. 更强大的抽象：将**计算过程**作为参数

假设我们要计算：

- 前 n 个自然数的和：1+2+⋯+n1+2+⋯+n
    
- 前 n 个自然数的立方和：13+23+⋯+n313+23+⋯+n3
    
- 一个逼近 π 的无穷级数：∑k=1∞8(4k−3)(4k−1)∑k=1∞​(4k−3)(4k−1)8​
    

这些求和过程具有相同的**控制结构**：从 1 到 n 迭代，累加每个项的值。唯一不同的是**如何计算每一项**。

我们可以将“计算每一项”的函数作为参数传入，从而写一个通用的求和函数：

```python

def summation(n, term):
    """返回 term(1) + term(2) + ... + term(n) 的和"""
    total = 0
    k = 1
    while k <= n:
        total = total + term(k)
        k = k + 1
    return total
```
#### 使用示例

```python

def identity(k):
    return k
def cube(k):
    return k ** 3
def pi_term(k):
    return 8 / ((4*k - 3) * (4*k - 1))
summation(5, identity)   # 1+2+3+4+5 = 15
summation(5, cube)       # 1+8+27+64+125 = 225
summation(1000000, pi_term)  # 约等于 3.141592153589902
```
> ⭐ **高阶函数**：`summation` 接收一个函数作为参数，因此它是一个**高阶函数**。

### 3. 函数作为返回值

高阶函数也可以**返回一个函数**。这允许我们动态创建定制化的函数。

#### 示例：`make_adder`

```python

def make_adder(n):
    """返回一个函数，该函数接收参数 k，返回 k + n"""
    def adder(k):
        return k + n
    return adder
```
- `make_adder(3)` 返回一个新函数，该函数内部“记住”了 `n=3`。
    
- 这个返回的函数可以赋值给变量，然后调用：
    

```python

add_three = make_adder(3)
add_three(4)   # 返回 7
```
#### 执行过程分析

1. 调用 `make_adder(3)`：
    
    - 创建局部帧，形参 `n` 绑定到 `3`。
        
    - 执行 `def adder(k):`，在局部帧中定义函数 `adder`（其代码体中引用了 `n`）。
        
    - 返回 `adder` 函数对象，局部帧保留（因为返回的函数需要访问 `n`）。
        
2. `add_three` 绑定到返回的 `adder` 函数。
    
3. 调用 `add_three(4)`：
    
    - 创建新帧（`adder` 的局部帧），形参 `k` 绑定到 `4`。
        
    - 在该帧中查找 `n`：当前帧找不到，到父帧（`make_adder` 的局部帧）找到 `n=3`。
        
    - 计算 `4+3`，返回 `7`。
        

> 💡 这种“函数携带外部环境”的机制称为**闭包**（closure）。内部函数可以访问外部函数的变量，即使外部函数已经返回。

### 4. 局部定义函数的作用域

- 在函数内部定义的函数，其名称绑定在**该函数的局部帧**中。
    
- 内部函数可以访问外部函数的参数和局部变量（通过词法作用域）。
    
- 每次调用外部函数，都会创建新的内部函数（如果定义在内部），并捕获当时的变量值。
    

### 5. 调用表达式作为操作符

调用表达式的操作符本身可以是一个返回函数的表达式。例如：

```python

make_adder(1)(2)
```
求值过程：

1. `make_adder(1)` 返回一个函数（`adder`）。
    
2. 然后将该函数应用于 `2`，即调用 `adder(2)`，返回 `3`。
    

这种连续调用方式简洁地表达了函数组合。

---

## 六、高阶函数的用途

### 1. 函数是一等公民

在Python中，函数与其他数据类型（数字、字符串、列表）具有同等地位：

- 可以赋值给变量
    
- 可以作为参数传递
    
- 可以作为返回值返回
    
- 可以存储在数据结构中
    

### 2. 高阶函数的定义

> **高阶函数**：接收函数作为参数，或者返回函数作为结果的函数。

### 3. 高阶函数的优势

- **表达通用计算方法**：将算法骨架与具体细节分离。
    
- **代码复用**：一次实现求和，多种用途（自然数和、立方和、π级数）。
    
- **关注点分离**：高阶函数处理循环逻辑，参数函数处理单项计算。
    
- **组合性**：可以通过组合简单函数构建复杂行为。
    

#### 示例：函数工厂

`make_adder` 是一个函数工厂，可以根据不同增量生成不同加法器。这种模式在配置化编程中非常常见。

---

## 七、知识点总结表（含扩展说明）

|知识点|核心内容|详细说明 / 示例|常见错误 / 易混淆点|难度|
|---|---|---|---|---|
|**斐波那契迭代实现**|用两个变量追踪前两项，while循环更新|`pred, curr = 0,1; while k<n: pred,curr = curr,pred+curr`|边界条件 n=0 的处理|⭐⭐⭐|
|**控制语句 vs 函数**|语句控制执行路径，函数先求值所有参数|`if` 只执行选中的分支，函数参数总会求值|误用函数模拟控制流导致提前求值|⭐⭐⭐|
|**逻辑短路**|`and`/`or` 根据左值决定是否求右值|`x>0 and sqrt(x)>10` 避免负数错误|混淆真假值，返回值是实际值而非布尔|⭐⭐|
|**高阶函数**|函数作为参数或返回值|`summation(n, term)`、`make_adder(n)`|不理解闭包中变量的捕获|⭐⭐⭐|
|**局部函数**|在函数内部定义函数，可访问外部变量|`def adder(k): return k+n`|忘记返回内部函数名|⭐⭐|
|**闭包**|函数携带定义时的环境|`add_three` 记住 `n=3`|误认为外部函数返回后局部变量消失|⭐⭐⭐|
|**函数作为操作符**|调用表达式中的操作符可以是函数调用结果|`make_adder(1)(2)`|分不清求值顺序|⭐⭐|

---

## 八、自测题 —— 检验理解

### 1. 斐波那契变体

修改 `fib` 函数，使其返回第 n 个斐波那契数，但使用 `for` 循环而不是 `while`。



```python

def fib(n):
    pred, curr = 1, 0
    for _ in range(n):
        pred, curr = curr, pred + curr
    return curr

```

### 2. 短路逻辑预测

写出以下表达式的值，并说明求值过程：

- `3 and 0 and 5`
    
- `0 or '' or 7`
    
- `2 or 1/0`
    
ans:

- `3 and 0 and 5`：先算 `3 and 0` → 返回 `0`（短路），整个表达式值为 `0`。
    
- `0 or '' or 7`：先算 `0 or ''` → 返回 `''`（因为 `0` 假，求 `''`，`''` 假，继续），再算 `'' or 7` → 返回 `7`。
    
- `2 or 1/0`：左 `2` 为真，直接返回 `2`，不会计算 `1/0`，因此无错误。
    


### 3. 实现 `map` 风格的函数

编写一个高阶函数 `apply_to_each(lst, func)`，它接收一个列表和一个函数，返回一个新列表，其中每个元素是原元素应用 `func` 后的结果。


```python

def apply_to_each(lst, func):
    return [func(x) for x in lst]
```

### 4. 闭包练习

以下代码输出什么？

```python

def outer(x):
    def inner(y):
        return x + y
    return inner
f = outer(5)
g = outer(10)
print(f(3), g(3))
```
<details> <summary>答案</summary> `8 13`。`f` 记住 `x=5`，`g` 记住 `x=10`，分别加 `3` 得到 `8` 和 `13`。 </details>

### 5. 思考题

为什么需要高阶函数？试举一个现实中的例子，说明将函数作为参数传递如何简化代码。

<details> <summary>提示</summary> 例如，在数据排序中，我们可以传递一个函数作为排序的键（key）。Python 的 `sorted(lst, key=len)` 就是高阶函数的应用。它让我们可以复用排序算法，只定制如何提取比较值。 </details>

---

## 九、总结与展望

本节课我们从斐波那契数列的迭代实现，过渡到控制语句的本质，再到逻辑短路，最终系统性地引入了高阶函数。你学会了：

- 如何用循环和变量更新实现递推关系。
    
- 条件语句与函数求值时的差异。
    
- 逻辑运算符的短路特性及其在错误防护中的应用。
    
- 将函数作为参数传递，实现通用求和。
    
- 将函数作为返回值，创建带有记忆的函数（闭包）。
    

高阶函数是函数式编程的核心，也是后续学习装饰器、迭代器、生成器的基础。在下一讲中，我们将进一步探讨递归与树形递归，以及如何用高阶函数处理复杂数据结构。
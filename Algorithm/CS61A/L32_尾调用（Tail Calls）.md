# 📘 Lecture 32：尾调用（Tail Calls）

> 尾调用是函数式编程中一种重要的优化技术。当一个函数的最后一步操作是调用另一个函数（或自身）时，这个调用称为“尾调用”。如果编程语言的实现支持尾调用优化（Tail Call Optimization, TCO），那么尾递归函数可以在常数空间内执行，从而避免递归深度过大导致的栈溢出。本节课将带你深入理解尾调用的概念、识别方法、优化原理，并通过大量示例展示如何将非尾递归函数改写为尾递归形式。

---

## 一、函数式编程的优势

### 1.1 纯函数与不可变性

函数式编程的核心是使用**纯函数**：

- 没有重新赋值（no re-assignment）
    
- 没有可变数据类型（no mutable data types）
    
- 名称-值绑定是永久的（permanent）
    

这意味着一旦一个名称绑定到一个值，该绑定就永远不会改变。这种限制带来了重要的优势。

### 1.2 引用透明性与求值顺序无关性

**引用透明**（Referential Transparency）是指：表达式的值只取决于其子表达式的值，而不依赖于任何外部状态或求值顺序。因此，我们可以用子表达式的值替换该子表达式，而不改变整个表达式的值。

由此导出一个重要性质：**表达式的值与子表达式的求值顺序无关**。这意味着：

- 我们可以自由选择先求值哪个子表达式。
    
- 适合并行计算：在多处理器环境下，可以同时求值多个子表达式。
    
- 支持惰性求值：可以延迟子表达式的求值，直到真正需要结果时才计算。
    
- 记忆化安全：由于表达式值不会改变，可以安全地缓存结果，不必担心缓存失效。
    

---

## 二、递归与迭代的对比

### 2.1 阶乘函数的两种实现

**Python 递归版本（非尾递归）**：

```python

def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)
```
- 时间复杂度：O(n)
    
- 空间复杂度：O(n)，因为每次递归调用都会创建新的栈帧，直到基准情况才开始返回。
    

**Python 迭代版本**：

```python

def factorial_iter(n):
    result = 1
    while n > 0:
        result *= n
        n -= 1
    return result
```
- 时间复杂度：O(n)
    
- 空间复杂度：O(1)，只用了常数个变量。
    

**Scheme 尾递归版本（带累加器）**：

```scheme

(define (factorial n k)
  (if (= n 0)
      k
      (factorial (- n 1) (* k n))))
```
这里 `k` 是累加器，保存了当前累积的乘积。初始调用 `(factorial 4 1)` 会依次：

- `(factorial 3 4)`
    
- `(factorial 2 12)`
    
- `(factorial 1 24)`
    
- `(factorial 0 24)` → 返回 24
    

**关键观察**：在尾递归版本中，递归调用结束后直接返回结果，没有额外的操作。如果语言支持尾调用优化，这个递归版本可以像迭代一样在常数空间内运行。

---

## 三、尾递归（Tail Recursion）

### 3.1 定义

**尾递归**是一种特殊的递归形式，其中**所有递归调用都处于尾调用上下文中**。这意味着递归调用是函数执行过程中最后一步操作，且其返回值直接作为当前函数的返回值，不做任何额外处理。

Scheme 语言规范要求所有实现必须是“properly tail recursive”，即能够将尾递归优化为常数空间内的迭代过程。

### 3.2 尾调用优化机制

在传统的递归中，每次函数调用都会在内存中分配一个新的栈帧（stack frame），用于存储局部变量和返回地址。当递归深度很大时，会耗尽栈空间，导致栈溢出。

尾调用优化的核心思想是：**当调用是尾调用时，当前函数的栈帧不再需要保留**。因为调用结束后没有更多操作，我们可以**重用**当前栈帧，或者直接跳转到被调用函数，而不分配新帧。这样，递归过程的空间复杂度就从 O(n) 降为 O(1)。

#### 示例：阶乘尾递归的执行过程

调用 `(factorial 4 1)`：

- 帧 f1：`n=4, k=1`，执行 `(factorial 3 4)` —— 这是尾调用，可以重用 f1。
    
- 重用 f1：`n=3, k=4`，执行 `(factorial 2 12)`。
    
- 重用 f1：`n=2, k=12`，执行 `(factorial 1 24)`。
    
- 重用 f1：`n=1, k=24`，执行 `(factorial 0 24)`。
    
- 重用 f1：`n=0, k=24`，返回 24。
    

整个过程始终只有一个帧，空间复杂度 O(1)。

### 3.3 非尾调用示例

```scheme

(define (factorial n)
  (if (= n 0)
      1
      (* n (factorial (- n 1)))))   ; 递归调用后还有乘法操作
```
这里 `(factorial (- n 1))` 的返回值需要乘以 `n` 后才能返回，因此**不是**尾调用。每次调用都必须保留当前帧，以便递归返回后执行乘法。

---

## 四、如何识别尾调用

### 4.1 尾上下文（Tail Context）

一个表达式是否处于“尾上下文”取决于它在程序中的位置。对于 Scheme 的 `lambda` 体：

- `lambda` 体的最后一个子表达式处于尾上下文。
    
- `if` 表达式的**两个分支**（consequent 和 alternative）都处于尾上下文（前提是 `if` 本身处于尾上下文）。
    
- `begin` 的最后一个子表达式处于尾上下文。
    
- `cond` 的每个子句的结果部分处于尾上下文。
    

#### 示例：阶乘的尾递归分析

```scheme

(define (factorial n k)
  (if (= n 0)          ; if 表达式是整个体的最后一个表达式，处于尾上下文
      k                ; 分支1：处于尾上下文
      (factorial (- n 1) (* k n))))   ; 分支2：处于尾上下文，且递归调用是最后一个操作
```
由于递归调用 `(factorial (- n 1) (* k n))` 是 `if` 的一个分支，而该分支处于尾上下文，且调用后没有额外操作，因此它是尾调用。

### 4.2 列表长度函数的两种版本

**非尾递归版本**：

```scheme

(define (length s)
  (if (null? s)
      0
      (+ 1 (length (cdr s)))))   ; 递归调用后还有 +1 操作，不是尾调用
```
**尾递归版本**（带累加器）：

```scheme

(define (length s)
  (define (length-iter s n)
    (if (null? s)
        n
        (length-iter (cdr s) (+ n 1))))   ; 尾调用
  (length-iter s 0))
```
这里 `length-iter` 的递归调用是最后一个操作，且处于尾上下文，因此是尾递归。空间复杂度 O(1)。

---

## 五、更多尾递归示例

### 5.1 `contains` 函数

判断元素是否在列表中：

```scheme

(define (contains s v)
  (cond ((null? s) #f)
        ((equal? (car s) v) #t)
        (else (contains (cdr s) v))))   ; 尾调用
```
这个函数是尾递归的，因为 `cond` 的 `else` 子句中的调用处于尾上下文。

### 5.2 `has-repeat` 函数

检查列表中是否有重复元素（借助 `contains`）：

```scheme

(define (has-repeat s)
  (if (null? s)
      #f
      (if (contains (cdr s) (car s))
          #t
          (has-repeat (cdr s)))))   ; 尾调用
```
虽然 `has-repeat` 调用 `contains`（不是尾调用），但 `has-repeat` 自身的递归调用是尾调用。尾递归只要求函数自身的递归调用是尾调用，不要求调用的其他函数是尾调用。

### 5.3 斐波那契函数的尾递归实现

非尾递归的斐波那契：

```scheme

(define (fib n)
  (if (< n 2)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))   ; 两个递归调用都不是尾调用
```
尾递归版本（使用两个累加器）：

```scheme

(define (fib n)
  (define (fib-iter a b count)
    (if (= count 0)
        a
        (fib-iter b (+ a b) (- count 1))))   ; 尾调用
  (fib-iter 0 1 n))
```
这个版本在常数空间内计算斐波那契数，时间复杂度 O(n)。

---

## 六、高阶函数的尾递归实现

### 6.1 `reduce` 函数

`reduce` 将一个二元过程依次应用到列表元素上，从初始值开始累积。

```scheme

(define (reduce fn s start)
  (if (null? s)
      start
      (reduce fn (cdr s) (fn start (car s)))))   ; 尾调用
```
示例：

- `(reduce * '(3 4 5) 2)` 计算 `2*3*4*5 = 120`
    
- `(reduce (lambda (x y) (cons y x)) '(3 4 5) '(2))` 得到 `(5 4 3 2)`
    

注意：`reduce` 是尾递归的，但它的空间复杂度取决于 `fn` 是否创建新结构。如果 `fn` 在常数空间内工作，那么整个 `reduce` 也在常数空间内。

### 6.2 `map` 函数的自然定义（非尾递归）

```scheme

(define (map proc s)
  (if (null? s)
      nil
      (cons (proc (car s))
            (map proc (cdr s)))))   ; 递归调用后还有 cons 操作，不是尾调用
```
这个版本是递归的，但不是尾递归，因此空间复杂度 O(n)。

### 6.3 `map` 的尾递归实现（构建-反转模式）

我们可以通过先构建逆序列表，最后反转来实现尾递归的 `map`：

```scheme

(define (map proc s)
  (reverse (map-reverse proc s nil)))
(define (map-reverse proc s result)
  (if (null? s)
      result
      (map-reverse proc
                   (cdr s)
                   (cons (proc (car s)) result))))   ; 尾调用
```
这里 `map-reverse` 是尾递归的，它逐步将处理后的元素 `cons` 到 `result` 的前面，最终得到一个逆序的结果列表。最后调用 `reverse` 得到正确顺序。

**执行过程**：以 `(map (lambda (x) (- 5 x)) '(1 2))` 为例：

- 初始：`map-reverse` 处理列表 `(1 2)`，`result = nil`
    
- 第一次迭代：处理 `1`，`result = (4)`
    
- 第二次迭代：处理 `2`，`result = (3 4)`
    
- 最后 `reverse` 得到 `(4 3)`
    

### 6.4 `reverse` 的尾递归实现

```scheme

(define (reverse s)
  (define (reverse-iter s r)
    (if (null? s)
        r
        (reverse-iter (cdr s) (cons (car s) r))))   ; 尾调用
  (reverse-iter s nil))
```
这也是一个经典的尾递归例子，利用累加器 `r` 来存储已反转的部分。

---

## 七、尾调用优化的实际意义

### 7.1 防止栈溢出

在 Python 等不支持尾调用优化的语言中，递归深度过大会导致 `RecursionError`。而在支持 TCO 的语言（如 Scheme、某些函数式语言）中，尾递归可以处理任意深度的递归，只要累加器能容纳数据。

例如，计算 `(factorial 10000 1)` 在 Scheme 中不会栈溢出，但 Python 的递归版本在 n=1000 左右就会崩溃。

### 7.2 性能对比

- **时间**：尾递归和迭代版本都是 O(n)。
    
- **空间**：非尾递归版本 O(n)，尾递归版本 O(1)（经优化后）。
    

尾调用优化将递归的空间效率提升到与迭代相当，同时保留了递归的表达清晰性。

---

## 八、解释器作为通用计算机

### 8.1 程序即机器

一个程序定义了“小机器”的逻辑。例如，阶乘函数的定义可以看作是一台机器的规格：

- 如果输入是 1，输出 1
    
- 否则输出输入乘以 (输入-1) 的阶乘
    

### 8.2 解释器是通用机器

我们编写的 Scheme 解释器是一个**通用机器**（universal machine）：

- 它接受两个输入：待执行的**程序**（源代码）和程序的**输入数据**。
    
- 通过组合这两个输入，它可以模拟任何特定的机器。
    

解释器本身只是一组求值规则，但它能够执行任何我们定义的 Scheme 程序。这正是“元循环求值器”（metacircular evaluator）的意义：用一门语言实现该语言自身的解释器。

---

## 九、知识点总结表

|知识点|核心内容|考试重点 / 易混淆点|难度|
|---|---|---|---|
|**函数式编程优势**|引用透明性、求值顺序无关、并行计算、记忆化安全|与命令式编程的对比|⭐⭐|
|**尾递归定义**|递归调用是函数的最后一步操作，且直接返回其值|识别尾调用上下文（如 `if` 分支）|⭐⭐⭐|
|**尾调用优化**|重用当前栈帧，空间复杂度从 O(n) 降为 O(1)|优化前后的空间对比；语言是否支持 TCO|⭐⭐⭐|
|**非尾递归示例**|阶乘 `(* n (factorial (- n 1)))`|递归后还有操作|⭐|
|**尾递归示例**|阶乘带累加器、长度带累加器、`contains`、`has-repeat`|累加器的设计；尾上下文判断|⭐⭐|
|**斐波那契尾递归**|两个累加器 `a, b`，迭代状态|理解状态转移|⭐⭐⭐|
|**`reduce` 尾递归**|二元过程依次应用，尾调用|与 `fold` 的类比|⭐⭐|
|**`map` 尾递归**|构建-反转模式，`map-reverse` 尾递归|注意最终需要 `reverse`|⭐⭐⭐|
|**`reverse` 尾递归**|累加器 `r`，依次 `cons`|经典实现|⭐⭐|
|**解释器通用性**|解释器是通用机器，可模拟任意程序|元循环求值器概念|⭐⭐|

---

## 十、自测题

### 1. 尾调用识别

判断以下 Scheme 函数中的递归调用是否为尾调用：

```scheme

(define (f x)
  (if (> x 0)
      (g x)
      (h x)))
(define (g y)
  (+ y 1))
(define (h z)
  (f (- z 1)))
```
- `f` 调用 `g` 和 `h` 是否是尾调用？
    
- `g` 和 `h` 中的递归呢？
    

ans:
- 在 `f` 中，`(g x)` 和 `(h x)` 都处于 `if` 分支中，而 `if` 是整个 `f` 体的最后一个表达式（假设 `f` 体只有这个 `if`），所以两个分支都处于尾上下文，因此对 `g` 和 `h` 的调用是尾调用。
    
- `g` 中没有递归调用。
    
- `h` 中对 `(f (- z 1))` 的调用是 `h` 体的最后一个表达式，因此是尾调用。
    


### 2. 转换为尾递归

将以下函数改写为尾递归形式：

```scheme

(define (sum s)
  (if (null? s)
      0
      (+ (car s) (sum (cdr s)))))
```


ans:
```scheme

(define (sum s)
  (define (sum-iter s acc)
    (if (null? s)
        acc
        (sum-iter (cdr s) (+ acc (car s)))))
  (sum-iter s 0))

```
### 3. 空间复杂度分析

对于以下两个版本的 `length` 函数，当输入列表长度为 10^6 时，哪个会栈溢出？为什么？

```scheme

;; 版本 A
(define (len-a s)
  (if (null? s)
      0
      (+ 1 (len-a (cdr s)))))
;; 版本 B
(define (len-b s)
  (define (iter s n)
    (if (null? s)
        n
        (iter (cdr s) (+ n 1))))
  (iter s 0))
```
<details> <summary>答案</summary>

版本 A 会栈溢出，因为它不是尾递归，需要 O(n) 的栈空间。版本 B 是尾递归，如果解释器支持 TCO，它将在常数空间内运行，不会溢出。

</details>

### 4. `map` 尾递归的缺陷

尾递归版本的 `map` 使用了 `reverse`，这增加了额外的时间开销。这个开销是多少？能否避免？

<details> <summary>答案</summary>

`reverse` 本身是 O(n) 操作，因此尾递归 `map` 的总时间复杂度仍然是 O(n)，但常数因子比非尾递归版本稍大（多了一次遍历）。无法完全避免，因为我们需要保持结果顺序，而尾递归构建时是逆序的。不过，在支持惰性求值的语言中，这个开销可以被消除。

</details>

### 5. 思考题

Python 为什么不支持尾调用优化？查阅资料并简述理由。

<details> <summary>提示</summary>

Python 的设计哲学强调清晰的栈回溯信息以便调试。尾调用优化会丢失调用链信息，使调试复杂化。此外，Python 的栈帧包含较多信息（如局部变量、行号等），重用帧的技术实现较为复杂。Guido van Rossum 曾明确表示 Python 不会支持尾递归优化。

</details>

---

## 十一、总结与展望

本节课我们深入探讨了尾调用这一函数式编程中的重要优化技术。你学会了：

- 函数式编程的引用透明性带来的优势。
    
- 如何识别尾调用和尾递归。
    
- 尾调用优化的原理和效果。
    
- 将非尾递归函数改写为尾递归的常见模式（累加器、构建-反转）。
    
- `reduce`、`map`、`reverse` 等高阶函数的尾递归实现。
    
- 解释器作为通用机器的哲学意义。
    

尾递归是函数式语言中实现高效循环的基础，也是理解编译器优化的关键一步。在后续课程中，你将看到更多利用尾递归实现的算法，并可能自己实现一个支持尾调用优化的解释器。
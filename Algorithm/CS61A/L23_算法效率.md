# 📘 Lecture 23：算法效率

> 算法的效率是计算机科学的核心问题之一。本节课将带你深入理解如何衡量算法的性能，包括时间复杂度和空间复杂度。你将学习如何使用计数器装饰器统计函数调用次数，如何通过记忆化优化递归算法，比较不同指数计算方法的效率，并掌握大O、大Theta记号的数学定义。最后，我们还将探讨递归算法的空间消耗。

---

## 一、为什么要关心效率？

在编写程序时，我们不仅希望结果正确，还希望程序能够快速运行，并且不占用过多内存。特别是当处理大规模数据时，低效的算法可能导致程序运行数小时甚至无法完成。因此，学会分析和优化算法效率至关重要。

---

## 二、性能测量：计数器装饰器

为了直观地比较不同算法的效率，我们可以编写一个装饰器，用来统计函数的调用次数。

### 2.1 计数器装饰器实现

```python

def counted(f):
    """返回一个包装函数，记录对原始函数 f 的调用次数。"""
    def wrapped(*args):
        wrapped.call_count += 1
        return f(*args)
    wrapped.call_count = 0
    return wrapped
```
使用示例：

```python

@counted
def fib(n):
    if n == 0 or n == 1:
        return n
    else:
        return fib(n-1) + fib(n-2)
fib(5)
print(fib.call_count)   # 输出 15
fib(5)                   # 再次调用
print(fib.call_count)   # 输出 30（累加）
```
**注意**：计数器是累计的，如果希望每次独立统计，需要在每次运行前重置 `call_count`。

### 2.2 分析斐波那契递归的调用次数

对于 `fib(5)`，调用树如下：

```text

                     fib(5)
                    /      \
               fib(4)      fib(3)
              /    \       /    \
          fib(3)  fib(2) fib(2) fib(1)
          /   \    /  \   /  \
      fib(2) fib(1) ... ...
```
总调用次数为 15。可以证明，`fib(n)` 的调用次数约为 ϕnϕn（指数级），其中 ϕ≈1.618ϕ≈1.618。例如 `fib(30)` 会产生 269 万次调用！这显然是不可接受的。

---

## 三、记忆化（Memoization）

### 3.1 原理

记忆化是一种优化技术，通过缓存函数的计算结果，避免重复计算相同的输入。它适用于**纯函数**（无副作用，相同输入总是相同输出）。

### 3.2 记忆化装饰器

```python

def memo(f):
    """返回一个记忆化版本的函数 f。"""
    cache = {}
    def memoized(n):
        if n not in cache:
            cache[n] = f(n)
        return cache[n]
    return memoized
```
### 3.3 优化斐波那契

将 `fib` 用记忆化装饰：

```python

@memo
def fib(n):
    if n == 0 or n == 1:
        return n
    else:
        return fib(n-1) + fib(n-2)
```
现在，计算 `fib(30)` 时，每个 `n` 只计算一次，总调用次数为 `n+1`（即 31 次）。这是因为每个 `fib(k)` 在第一次被需要时计算，之后直接从缓存中获取。

**调用过程**（以 `fib(5)` 为例）：

- 调用 `fib(5)`，缓存未命中，递归调用 `fib(4)` 和 `fib(3)`。
    
- `fib(4)` 未命中，调用 `fib(3)` 和 `fib(2)`。
    
- 如此下去，最终所有值被计算并缓存，后续相同的参数直接返回缓存值。
    

**性能对比**：普通递归 `fib(30)` 需要 269 万次调用，记忆化后仅需 31 次。即使计算 `fib(300)` 也能瞬间完成（前提是整数能容纳）。

---

## 四、指数计算的两种方法

计算 bnbn 有两种常见递归方法：线性递归和快速幂（对数递归）。

### 4.1 线性递归（慢速）

```python

def exp_slow(b, n):
    if n == 0:
        return 1
    else:
        return b * exp_slow(b, n-1)
```
- 时间复杂度：Θ(n)Θ(n)，因为需要 n 次乘法。
    
- 当 n 很大时（如 10^6），这非常慢。
    

### 4.2 快速幂（对数递归）

利用指数性质：

- 若 n 为偶数：bn=(bn/2)2bn=(bn/2)2
    
- 若 n 为奇数：bn=b⋅bn−1bn=b⋅bn−1
    

```python

def exp_fast(b, n):
    if n == 0:
        return 1
    elif n % 2 == 0:
        return square(exp_fast(b, n//2))
    else:
        return b * exp_fast(b, n-1)
def square(x):
    return x * x
```
- 时间复杂度：Θ(log⁡n)Θ(logn)，因为每次递归将问题规模减半（偶数情况）或减一（奇数情况），但奇数情况后下一步必然为偶数，所以总体步骤数约为 2log⁡2n2log2​n。
    
- 例如，计算 2100021000 只需约 20 次乘法，而线性递归需要 1000 次。
    

**性能对比**：对于 n=400n=400，线性递归耗时可能为 1ms，而快速幂仅需 0.4ms（实际差异随 n 增大而显著）。

---

## 五、增长量级的数学定义

为了严格描述算法效率，我们使用渐进记号。

### 5.1 大 Theta（ΘΘ）

Θ(g(n))表示函数的增长速率与g(n) 相同，即存在正常数c1​,c2​ 和 n0，使得对于所有 n≥n0​，有：

$$c1g(n)≤f(n)≤c2g(n)$$

例如，3n2+5n+2=Θ(n2)

### 5.2 大 O（OO）

O(g(n)) 表示函数的增长速率不超过 g(n)，即存在正常数 c 和 n0​，使得对于所有 n≥n0，有：

$$f(n)≤cg(n)$$

例如，2n+10=O(n2，但更精确地说它是 O(n)。

**区别**：大 O 只提供上界，大 Theta 同时提供上下界。在算法分析中，我们通常关心最坏情况的上界，所以常用大 O。

### 5.3 常见增长阶数

| 阶数        | 名称   | 示例算法      | 增长速度     |
| --------- | ---- | --------- | -------- |
| Θ(1)      | 常数时间 | 访问数组元素    | 不随输入规模变化 |
| Θ(log⁡n)  | 对数时间 | 二分查找      | 增长非常慢    |
| Θ(n       | 线性时间 | 遍历列表      | 与输入规模成正比 |
| Θ(nlog⁡n) | 线性对数 | 快速排序（平均）  | 比线性稍快    |
| Θ(n2)     | 二次时间 | 嵌套循环      | 增长较快     |
| Θ(2n)     | 指数时间 | 未经优化的斐波那契 | 增长极快     |

---

## 六、二次时间示例

考虑一个函数，计算两个列表的重叠元素个数（每个元素对比较一次）：

```python

def count_overlap(a, b):
    count = 0
    for x in a:
        for y in b:
            if x == y:
                count += 1
    return count
```
若 `a` 和 `b` 长度均为 n，则比较次数为 n2，时间复杂度 Θ(n2)。当 n 从 20 增加到 200，时间从 2ms 增加到 8ms（实际上 2002/202=100，应为 200ms，但可能因为常数因素而显示为 8ms，此处为示例）。

---

## 七、指数时间示例

未经优化的斐波那契递归是指数时间的典型。其递推关系：

$$T(n)=T(n−1)+T(n−2)+1$$

解为 T(n)≈ϕn，其中 ϕ 是黄金分割比。

**关键特征**：输入规模 n 增加 1，时间乘以常数倍（约 1.618）。因此，n 稍大就不可行。

---

## 八、空间消耗与活动环境

除了时间，我们还需关注内存使用，即空间复杂度。

### 8.1 空间消耗来源

- 存储的值：如列表、字典等数据结构。
    
- 函数调用产生的环境帧（栈帧）：每个未返回的函数调用都占用内存。
    

**活动环境**：指当前正在执行但尚未返回的函数调用集合。这些帧必须保留，以便返回后继续执行。

### 8.2 斐波那契递归的空间复杂度

以普通递归 `fib(n)` 为例，其调用链深度为 nn（因为每次递归一个分支，但有两个分支同时存在？实际上，递归树中同时存在的最大帧数等于树的高度，即 nn）。例如，`fib(5)` 在计算最左路径时，帧栈为：`fib(5) → fib(4) → fib(3) → fib(2) → fib(1)`，深度为 5。因此空间复杂度为 Θ(n)Θ(n)。

**注意**：虽然总调用次数很多，但同一时刻最多只有 nn 个帧存在，因为当一个子调用返回后，其帧被释放。

### 8.3 计数器装饰器扩展：统计最大帧数

我们可以修改计数器装饰器，记录同时打开的帧数最大值：

```python

def count_frames(f):
    def wrapped(n):
        wrapped.open_count += 1
        if wrapped.open_count > wrapped.max_count:
            wrapped.max_count = wrapped.open_count
        result = f(n)
        wrapped.open_count -= 1
        return result
    wrapped.open_count = 0
    wrapped.max_count = 0
    return wrapped
```
对 `fib` 使用此装饰器，可以观察递归深度。例如 `fib(20)` 的最大帧数应为 20。

---

## 九、知识点总结表

|知识点|核心内容|考试重点 / 易混淆点|难度|
|---|---|---|---|
|**计数器装饰器**|通过闭包统计函数调用次数|装饰器的写法；调用次数的累积|⭐⭐|
|**记忆化**|缓存计算结果，避免重复计算|适用于纯函数；缓存字典的键为参数|⭐⭐⭐|
|**线性递归指数**|bn=b⋅bn−1bn=b⋅bn−1，Θ(n)Θ(n)|直观但低效|⭐|
|**快速幂**|利用偶数性质，Θ(log⁡n)Θ(logn)|正确处理奇偶情况；避免重复计算|⭐⭐⭐|
|**大 O / 大 Theta**|描述渐进上界 / 紧确界|区别与联系；常见阶数|⭐⭐⭐|
|**二次时间**|嵌套循环，如 n2n2|识别嵌套循环|⭐|
|**指数时间**|如未经优化的斐波那契|识别树递归|⭐⭐|
|**空间复杂度**|递归调用栈深度|同时存在的帧数 vs 总调用次数|⭐⭐⭐|

---

## 十、自测题

### 1. 计数器装饰器

编写一个装饰器 `count_calls`，记录函数被调用的次数，并提供一个方法 `reset()` 重置计数器。

```python

def count_calls(f):
    def wrapped(*args):
        wrapped.count += 1
        return f(*args)
    wrapped.count = 0
    wrapped.reset = lambda: setattr(wrapped, 'count', 0)
    return wrapped

```

### 2. 记忆化限制

为什么记忆化不适用于带有副作用的函数？请举例说明。

<details> <summary>答案</summary>

记忆化依赖于相同输入产生相同输出。如果函数有副作用（如打印、修改全局变量、修改输入对象），则缓存结果可能导致后续调用不再执行副作用，从而改变程序行为。例如，一个打印参数的函数被记忆化后，第二次调用不会打印。

</details>

### 3. 快速幂实现

写出快速幂的迭代版本（不使用递归）。

```python

def exp_fast_iter(b, n):
    result = 1
    while n > 0:
        if n % 2 == 1:
            result *= b
        b *= b
        n //= 2
    return result
```

### 4. 时间复杂度分析

分析以下函数的时间复杂度（用大 O 表示）：

```python

def foo(n):
    i = 1
    while i < n:
        j = n
        while j > 0:
            j //= 2
        i *= 2
```

答案

外层循环 `i` 每次加倍，执行约 log⁡2n 次；内层循环 `j` 每次减半，也执行 log2​n 次。总复杂度 O(log⁡n⋅log⁡n)=O(log⁡2n)。



### 5. 空间复杂度

考虑以下递归函数：

```python

def g(n):
    if n <= 1:
        return 1
    return g(n-1) + g(n-1)
```
其空间复杂度是多少？为什么？

<details> <summary>答案</summary>

空间复杂度为 O(n)。虽然总调用次数是指数级，但递归深度最大为 n（例如一直走左分支），所以同时存在的帧最多 n 个。

</details>

### 6. 思考题

为什么说大 O 记号只关心“足够大的 n”？这对实际编程有什么指导意义？

<details> <summary>提示</summary>

对于小规模输入，常数因子和低阶项可能起主导作用。大 O 忽略了这些，只关注增长趋势。因此，一个 O(n2) 的算法可能在 n 很小时比 O(nlogn) 的算法更快，但 n 增大后则相反。实际编程中，需要根据预期输入规模选择合适的算法。

</details>

---

## 十一、总结与展望

本节课我们学习了如何衡量和分析算法的效率。你掌握了：

- 使用计数器装饰器统计函数调用次数。
    
- 用记忆化优化递归算法，将指数时间降为线性时间。
    
- 比较了线性递归和快速幂两种指数计算方法。
    
- 理解了渐进记号大 O 和大 Theta 的定义及常见增长阶数。
    
- 分析了二次时间和指数时间的典型算法。
    
- 了解了递归算法的空间复杂度（调用栈深度）。
    

这些知识是算法设计和优化的基础。在后续课程中，你将学习更多高效的数据结构和算法（如二分搜索树、哈希表、排序算法等），并运用这些分析工具评估它们的性能。
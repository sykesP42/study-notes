# 📘 Lecture 9：递归

> 本笔记从课程通知开始，然后深入递归的世界。你将学习自我引用函数、递归的基本结构、如何用环境图理解递归、卢恩算法中的互递归，以及递归与迭代的相互转换。递归是计算机科学的核心思想之一，掌握它将为你打开解决问题的新视角。

---

## 一、课程通知与学习建议

### 1. 考试恢复政策

- 如果期中考试成绩不理想，可以通过期末成绩追回最多 **90%** 的期中分数。
    
- 这意味着一次考试不会决定最终成绩，你有机会在期末证明自己。
    

### 2. 项目截止与提前提交奖励

- **Hog 项目**截止时间：周三 9/13 晚上 11:59。
    
- 提前提交奖励：如果在周二 9/12 前完成，可获得额外加分。
    

### 3. 替代课程选项

- **Data C88C**：与 61A 内容重叠约 3/4，采用学期制教学。
    
- **CS 10**：仍有少量空位，适合需要更多支持的初学者。
    

### 4. 如何寻求帮助

- 在 ed 平台发帖提问。
    
- 直接联系课程工作人员或教授。
    
- 无论是否转换课程，有任何疑问都可寻求帮助。
    

### 5. 对考试成绩的建议

- **不满意**：保持与课程同步或超前，充分利用实验课和讨论课，确保掌握语言规则和问题解决方法。
    
- **满意**：不要松懈，课程大部分内容尚未教授，历史上有人因期中后放松而期末下滑。按时完成作业，尽早开始任务。
    

---

## 二、自我引用函数

在正式介绍递归之前，先看一种特殊的函数：它返回自身，但并不无限递归。

### 1. 示例：`print_all`


```python

def print_all(x):
    print(x)
    return print_all
```
- 这个函数打印参数 `x`，然后返回函数本身。
    
- 调用 `print_all(1)` 打印 `1`，返回 `print_all` 函数。
    
- 因此可以链式调用：`print_all(1)(3)(5)` 会依次打印 `1, 3, 5`。
    

#### 环境图解析

- 全局帧中 `print_all` 绑定到该函数。
    
- 每次调用创建新帧，参数 `x` 独立存储。
    
- 返回值始终是同一个函数对象，因此可以连续调用。
    

> 💡 这展示了函数作为一等公民的特性：函数可以返回自身，形成链式调用，但不会自动无限循环，因为每次调用都需要显式写出。

### 2. 带记忆功能的链式调用：`print_sums`

```python

def print_sums(x):
    print(x)
    def next_sum(y):
        return print_sums(x + y)
    return next_sum
```
- `print_sums(1)` 打印 `1`，返回 `next_sum` 函数（闭包，记住了 `x=1`）。
    
- `next_sum(3)` 计算 `1+3=4`，然后调用 `print_sums(4)`，打印 `4`，返回新的 `next_sum`（记住 `x=4`）。
    
- 继续 `next_sum(5)` 打印 `4+5=9`，等等。
    

调用链：`print_sums(1)(3)(5)` 输出：

```text

1
4
9
```
**关键**：通过嵌套函数和闭包，我们能够在多次调用中维护状态（累加和），而不使用全局变量。这是函数式编程中常见的模式。

---

## 三、递归函数

### 1. 定义

> **递归函数**是指在函数体中直接或间接调用自身的函数。

- **直接递归**：函数直接调用自己。
    
- **间接递归**：函数通过其他函数调用自己（如 `A` 调用 `B`，`B` 调用 `A`）。
    

递归不仅存在于编程中，也广泛存在于艺术（如埃舍尔的画）、自然（如螺旋）和数学（如谢尔宾斯基三角形）中。

### 2. 第一个例子：数字各位求和

**问题**：计算一个非负整数的各位数字之和。例如 `2013` 的和为 `2+0+1+3=6`。

#### 数学性质

- 如果一个数能被 9 整除，那么它的各位数字之和也能被 9 整除（可用于验证计算）。
    
- 实际应用：信用卡号等长数字的输入错误检测（卢恩算法）。
    

#### 辅助函数 `split`

```python

def split(n):
    """返回 (n 去掉最后一位, 最后一位)"""
    return n // 10, n % 10
```
#### 递归实现 `sum_digits`

```python

def sum_digits(n):
    """返回正整数 n 的各位数字之和"""
    if n < 10:
        return n
    else:
        all_but_last, last = split(n)
        return sum_digits(all_but_last) + last
```
**执行过程**（以 `sum_digits(2013)` 为例）：

- `sum_digits(2013) = sum_digits(201) + 3`
    
- `sum_digits(201) = sum_digits(20) + 1`
    
- `sum_digits(20) = sum_digits(2) + 0`
    
- `sum_digits(2) = 2` （基本情况）
    
- 回溯：`2 + 0 = 2`，`2 + 1 = 3`，`3 + 3 = 6`。
    

### 3. 递归函数的解剖

每个递归函数都应包含两个部分：

- **基本情况**（Base Case）：最简单的实例，可以直接求解，不需要递归调用。例如 `n < 10` 时直接返回 `n`。
    
- **递归情况**（Recursive Case）：将问题分解为更小的子问题，通过递归调用解决子问题，然后组合结果。例如 `sum_digits(all_but_last) + last`。
    

**关键原则**：

1. 必须有一个或多个基本情况，确保递归终止。
    
2. 每次递归调用必须向基本情况靠近（通常通过减少参数规模）。
    
3. 递归调用解决的是规模更小的相同问题。
    

### 4. 递归的环境图：以阶乘为例

阶乘的递归定义：

```text

fact(n) = 1                 如果 n == 0
          n * fact(n-1)     否则
```
代码：

```python

def fact(n):
    if n == 0:
        return 1
    else:
        return n * fact(n-1)
result = fact(3)
```
#### 环境图逐步分析

1. **调用 `fact(3)`**：
    
    - 创建帧 `f1`，`n=3`，父帧为全局。
        
    - 执行 `return 3 * fact(2)`，需要先求值 `fact(2)`。
        
2. **调用 `fact(2)`**：
    
    - 创建帧 `f2`，`n=2`，父帧为全局。
        
    - 执行 `return 2 * fact(1)`，需要先求值 `fact(1)`。
        
3. **调用 `fact(1)`**：
    
    - 创建帧 `f3`，`n=1`，父帧为全局。
        
    - 执行 `return 1 * fact(0)`，需要先求值 `fact(0)`。
        
4. **调用 `fact(0)`**：
    
    - 创建帧 `f4`，`n=0`，父帧为全局。
        
    - 执行 `if n == 0: return 1`，返回 `1`，帧 `f4` 销毁。
        
5. **回到 `f3`**：
    
    - `fact(0)` 结果为 `1`，计算 `1 * 1 = 1`，返回 `1`，帧 `f3` 销毁。
        
6. **回到 `f2`**：
    
    - `fact(1)` 结果为 `1`，计算 `2 * 1 = 2`，返回 `2`，帧 `f2` 销毁。
        
7. **回到 `f1`**：
    
    - `fact(2)` 结果为 `2`，计算 `3 * 2 = 6`，返回 `6`，帧 `f1` 销毁。
        
8. 全局帧中 `result` 绑定到 `6`。
    

**调用栈**：递归调用会创建一叠帧，直到达到基本情况，然后逐层返回。环境图清晰地展示了这一过程。

### 5. 递归思维：信念跃迁

要正确编写和理解递归，需要采用一种“信念跃迁”：

1. **验证基本情况**：确保对于最小的问题，函数能直接返回正确结果。
    
2. **相信递归调用**：假设递归调用能正确处理规模更小的子问题（比如 `fact(n-1)` 能正确返回 `(n-1)!`）。
    
3. **构造递归情况**：基于这个假设，证明当前层的结果正确（如 `n * fact(n-1)` 等于 `n!`）。
    
4. **归纳证明**：这类似于数学归纳法——基础情况成立，且如果对 `n-1` 成立则对 `n` 成立，那么对所有自然数成立。
    

**示例**：对于 `fact(4)`，相信 `fact(3)` 返回 `6`，那么 `4 * 6 = 24` 正确。

---

## 四、卢恩算法（Luhn Algorithm）

卢恩算法用于验证信用卡号等数字串的有效性，能检测单个数字错误和大多数相邻数字交换错误。

### 1. 算法步骤

1. 从最右边的校验位（最后一位）开始，向左移动，每隔一位将数字加倍。
    
2. 如果加倍后的结果大于 9，则将其各位数字相加（例如 `7×2=14` → `1+4=5`）。
    
3. 将所有数字（包括未加倍的）相加，得到总和。
    
4. 如果总和是 10 的倍数，则号码有效。
    

**示例**：数字 `138743`（假设最后一位是校验位）

- 从右向左：3（不变）、4（加倍→8）、7（不变）、8（加倍→16→1+6=7）、3（不变）、1（加倍→2）
    
- 总和：2 + 3 + 7 + 7 + 8 + 3 = 30 → 是 10 的倍数，有效。
    

### 2. 互递归实现

我们可以用两个相互递归的函数来实现：一个处理普通位，一个处理需要加倍的位。

首先需要 `split` 和 `sum_digits` 函数。

```python

def split(n):
    return n // 10, n % 10
def sum_digits(n):
    if n < 10:
        return n
    else:
        all_but_last, last = split(n)
        return sum_digits(all_but_last) + last
```
然后定义 `luhn_sum` 和 `luhn_sum_double`：

```python

def luhn_sum(n):
    """返回卢恩算法下的数字和（从右向左，最后一位不加倍）"""
    if n < 10:
        return n
    else:
        all_but_last, last = split(n)
        return luhn_sum_double(all_but_last) + last
def luhn_sum_double(n):
    """返回卢恩算法下的数字和，但当前最后一位需要加倍"""
    all_but_last, last = split(n)
    # 加倍 last，如果结果 >9 则求数字和
    luhn_digit = sum_digits(2 * last)
    if n < 10:   # 这里 n 是当前剩余数字，如果只有一位，直接返回加倍后的结果
        return luhn_digit
    else:
        return luhn_sum(all_but_last) + luhn_digit
```
**注意**：`luhn_sum_double` 的返回值逻辑：先加倍最后一位并处理成单个数字，然后加上对剩余部分（去掉最后一位）调用 `luhn_sum`（因为下一轮又变成普通位）。两个函数相互调用，直到数字被处理完。

**测试**：

- `luhn_sum(2)` → 2
    
- `luhn_sum(32)` → 8（3 加倍→6，+ 2 = 8？不对，32 从右向左：2 不变，3 加倍→6，和 = 6+2=8，正确）
    
- `luhn_sum(138743)` → 30（有效）
    
- `luhn_sum(5105105105105100)` → 20（这是一个有效的信用卡号样例）
    

**理解互递归**：

- 两个函数交替调用，每次处理一位，并切换“加倍模式”。
    
- 基本情况是当数字只有一位时，根据当前模式直接返回处理后的值。
    

---

## 五、递归与迭代的关系

递归和迭代是两种基本的控制结构，它们可以相互转换。

### 1. 递归转迭代

**核心思想**：找出递归过程中需要维护的状态（即哪些变量在递归调用中变化），然后在循环中显式更新这些状态。

**示例**：将 `sum_digits` 转换为迭代版本。

递归版本的状态：

- 参数 `n`：剩余需要求和的数字。
    
- 返回值：累加的和（通过递归调用传递）。
    

迭代需要维护：

- `n`：当前剩余数字。
    
- `total`：已经累积的和。
    

```python

def sum_digits_iter(n):
    total = 0
    while n > 0:
        n, last = split(n)
        total += last
    return total
```
注意：循环体内 `n` 被更新为去掉最后一位的值，同时将最后一位加到 `total`。当 `n` 变为 0 时，循环结束，返回 `total`。

### 2. 迭代转递归

**核心思想**：将循环中跨迭代维护的状态作为递归函数的参数，循环条件变为递归的基本情况。

**示例**：将上面的迭代版本转换回递归版本，但这次我们显式地将 `total` 作为参数。

```python

def sum_digits_rec(n, total=0):
    if n == 0:
        return total
    else:
        n, last = split(n)
        return sum_digits_rec(n, total + last)
```
- 初始调用 `sum_digits_rec(2013)` 相当于 `sum_digits_rec(2013, 0)`。
    
- 每次递归调用，`n` 减少一位，`total` 增加最后一位。
    
- 当 `n == 0` 时返回累积的 `total`。
    

这种形式的递归称为**尾递归**（递归调用是函数的最后一步），在某些语言中可以优化为迭代，但 Python 不支持尾递归优化。

---

## 六、知识点总结表

|知识点|核心内容|考试重点 / 易混淆点|难度|
|---|---|---|---|
|**自我引用函数**|函数返回自身，可链式调用但不自动递归|区分返回自身与调用自身；闭包记忆状态|⭐⭐|
|**递归定义**|函数直接或间接调用自身|必须包含基本情况和递归情况|⭐⭐|
|**数字求和递归**|`sum_digits(n) = sum_digits(n//10) + n%10`|正确使用 split 和基本情况|⭐⭐|
|**阶乘与环境图**|递归调用创建多个帧，逐层返回|帧的创建与销毁顺序；返回值传递|⭐⭐⭐|
|**递归信念跃迁**|相信递归调用能解决子问题，类似于数学归纳|验证基本情况和递归构造的正确性|⭐⭐⭐|
|**卢恩算法**|隔位加倍并可能拆位，用互递归实现|交替调用两个函数；正确处理加倍后数字|⭐⭐⭐⭐|
|**互递归**|两个函数相互调用，交替处理|确定何时切换模式；基本情况设计|⭐⭐⭐⭐|
|**递归转迭代**|分析递归状态，用循环显式更新|识别需要维护的变量|⭐⭐⭐|
|**迭代转递归**|将状态作为参数，循环条件变基本情况|尾递归形式；参数初始化|⭐⭐⭐|

---

## 七、自测题

### 1. 自我引用函数

写出以下代码的输出：

```python

def fun(x):
    print(x)
    return fun
fun(2)(4)(6)
```
<details> <summary>答案</summary> 输出： ``` 2 4 6 ``` 每次调用打印参数并返回自身，因此可以连续调用。 </details>

### 2. 带记忆的链式调用

```python

def add(x):
    def inner(y):
        return add(x + y)
    return inner
```
调用 `add(1)(2)(3)` 返回什么？是一个函数还是数字？

<details> <summary>答案</summary> 返回一个函数（`add` 的返回值是 `inner`，而 `inner` 返回的是 `add(x+y)`，即再次返回 `inner`）。所以最终结果是一个函数，不是数字。若要得到数字，需要最终调用一个不返回函数的函数，或者设计一个终止条件。 </details>

### 3. 递归数字求和

不使用 `split`，直接用算术运算符实现 `sum_digits`。

ans:
```python

def sum_digits(n):
    if n < 10:
        return n
    return sum_digits(n // 10) + n % 10

```

### 4. 互递归练习

实现一个函数 `is_even(n)` 和 `is_odd(n)`，它们相互递归地判断一个非负整数的奇偶性（不使用 `%` 运算符）。

```python

def is_even(n):
    if n == 0:
        return True
    else:
        return is_odd(n-1)
def is_odd(n):
    if n == 0:
        return False
    else:
        return is_even(n-1)

```

### 5. 递归转迭代

将下面的递归函数转换为迭代版本：

```python

def power(x, n):
    if n == 0:
        return 1
    else:
        return x * power(x, n-1)
        
```
ans:
```python

def power_iter(x, n):
    result = 1
    while n > 0:
        result *= x
        n -= 1
    return result

```

### 6. 迭代转递归

将下面的迭代函数转换为递归版本（使用尾递归形式）：

```python

def factorial(n):
    result = 1
    while n > 0:
        result *= n
        n -= 1
    return result
```

ans:
```python

def factorial_rec(n, acc=1):
    if n == 0:
        return acc
    else:
        return factorial_rec(n-1, acc * n)

```

### 7. 卢恩算法手算

验证数字 `79927398713` 是否有效（最后一位是校验位）。提示：这是一个著名的例子，有效的结果应为 70（10 的倍数）。

ans:
数字：7 9 9 2 7 3 9 8 7 1 3（从右向左）

- 3 不变 → 3
    
- 1 加倍 → 2 → 2
    
- 7 不变 → 7
    
- 8 加倍 → 16 → 1+6=7
    
- 9 不变 → 9
    
- 3 加倍 → 6 → 6
    
- 7 不变 → 7
    
- 2 加倍 → 4 → 4
    
- 9 不变 → 9
    
- 9 加倍 → 18 → 1+8=9
    
- 7 不变 → 7  
    总和：3+2+7+7+9+6+7+4+9+9+7 = 70 → 有效。
    


---

## 八、总结与展望

本节课我们从自我引用函数开始，逐步深入递归的核心概念。你学会了：

- 如何用函数返回自身实现链式调用。
    
- 递归的基本结构：基本情况和递归情况。
    
- 通过环境图理解递归的调用栈。
    
- 用信念跃迁的方式编写和验证递归。
    
- 卢恩算法中的互递归应用。
    
- 递归与迭代的相互转换。
    

递归是计算机科学中极其重要的思想，它让你能够用简洁的代码解决复杂问题（如树遍历、分治算法等）。在后续课程中，你将看到递归在数据结构（如链表、树）和算法（如快速排序）中的广泛应用。
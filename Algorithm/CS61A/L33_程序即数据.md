# 📘 Lecture 33：程序即数据

> Lisp 语言家族（包括 Scheme）最独特的特征之一是**同像性**（homoiconicity）：程序本身就是语言中的数据结构。这意味着我们可以像操作列表一样操作程序，在运行时动态生成、分析和修改代码。这种元编程能力让 Lisp 成为编写“生成程序的程序”的理想语言。本节课将带你深入理解这一思想，并掌握如何使用准引用（quasiquote）优雅地构造代码。

---

## 一、Scheme 表达式就是 Scheme 列表

### 1.1 基本概念

在 Scheme 中，程序由表达式组成。这些表达式可以是：

- **原始表达式**：数字（如 `2`、`3.3`）、布尔值（`#t`、`#f`）、符号（如 `+`、`quotient`）。
    
- **组合表达式**：以括号包围的列表，如 `(quotient 10 2)`、`(not #t)`。
    

关键点：**组合表达式本身就是 Scheme 的链表数据结构**。也就是说，代码和数据使用同一种表示方式。

### 1.2 用 `list` 构造表达式

我们可以使用 `list` 函数来构造一个看起来像代码的列表：

```scheme

> (list 'quotient 10 2)
(quotient 10 2)
```
这里 `'quotient` 是符号，`10` 和 `2` 是数字，组合成的列表正好是一个合法的 Scheme 调用表达式。

### 1.3 `eval` 函数：执行生成的代码

Scheme 提供了内置函数 `eval`，它接受一个表达式（以列表或原始值形式）并在当前环境中求值，返回结果。

```scheme

> (eval (list 'quotient 10 2))
5
```
`eval` 让我们能够执行动态构造的代码。这开启了元编程的大门。

#### 注意：

- `eval` 在求值时使用的是调用 `eval` 时的环境（在 Scheme 中通常是全局环境）。不同 Scheme 实现对 `eval` 的环境参数可能有不同处理，但基本概念一致。
    
- 过度使用 `eval` 可能导致代码难以理解和维护，但在某些场景下（如构建解释器、代码生成器）它不可或缺。
    

---

## 二、返回表达式的函数

一个更有趣的应用是：定义一个函数，它**返回一个表示计算的表达式**，而不是直接计算结果。这样我们可以先构造代码，稍后再求值，或者对代码进行分析和转换。

### 2.1 阶乘示例

先看传统的阶乘函数（直接计算）：

```scheme

(define (fact n)
  (if (= n 0)
      1
      (* n (fact (- n 1)))))
```
现在，我们定义一个函数 `fact-exp`，它**返回一个计算阶乘的表达式**（一个嵌套的乘法表达式）：

```scheme

(define (fact-exp n)
  (if (= n 0)
      1
      (list '* n (fact-exp (- n 1)))))
```
**测试**：

```scheme

> (fact-exp 5)
(* 5 (* 4 (* 3 (* 2 1))))
> (eval (fact-exp 5))
120
```
`fact-exp` 生成的是一个纯粹的算术表达式，不包含任何函数调用（除了 `*`）。我们可以用 `eval` 求值它，或者对它进行其他操作（例如化简、打印等）。

### 2.2 斐波那契数列示例

类似地，我们可以为斐波那契函数定义一个返回表达式的版本：

```scheme

(define (fib n)
  (if (<= n 1)
      n
      (+ (fib (- n 1)) (fib (- n 2)))))
(define (fib-exp n)
  (if (<= n 1)
      n
      (list '+ (fib-exp (- n 1)) (fib-exp (- n 2)))))
```

```scheme

> (fib-exp 6)
(+ (+ (+ 1 0) (+ 1 0)) (+ (+ 1 0) 1))
> (eval (fib-exp 6))
8
```
可以看到，生成的表达式非常冗长，但它精确地描述了计算过程。这种能力在符号计算、程序分析等领域非常有用。

---

## 三、准引用（Quasiquote）

### 3.1 问题：手动构造列表太繁琐

使用 `list` 构造复杂的嵌套表达式会变得冗长且易错。例如构造 `(* 5 (+ 3 4))` 需要：

```scheme

(list '* 5 (list '+ 3 4))
```
如果表达式很大，这种写法难以阅读。

### 3.2 准引用的语法

Scheme 提供了**准引用**（quasiquote）机制，使用反引号 `` ` `` 表示，它类似于引用（`'`），但允许部分表达式被“取消引用”并求值，用逗号 `,` 标记。

- `` `(a b c) `` 等价于 `'(a b c)`，完全引用。
    
- `` `(a ,(+ 1 2) c) `` 中，`,(+ 1 2)` 会被求值，结果插入到列表中，得到 `(a 3 c)`。
    

**示例**：

```scheme

> (define b 4)
> `(a ,(+ b 1) c)
(a 5 c)
```
### 3.3 准引用 vs 引用

- 引用 `'` 完全阻止求值，所有子表达式都视为字面数据。
    
- 准引用 `` ` `` 允许通过逗号 `,` 打开“求值窗口”，将表达式的结果嵌入到引用的结构中。
    

准引用特别适合动态生成代码，因为它让我们可以写出几乎像代码模板一样的表达式，同时又能嵌入运行时的值。

### 3.4 用准引用重写 `fact-exp`

使用准引用，`fact-exp` 可以写得更清晰：

```scheme

(define (fact-exp n)
  (if (= n 0)
      1
      `(* ,n ,(fact-exp (- n 1)))))
```
注意 `,n` 和 `,(fact-exp (- n 1))` 会被求值并插入到生成的 `(* ...)` 表达式中。这不仅可读性更强，而且不易出错。

---

## 四、应用案例：生成 `while` 循环表达式

### 4.1 问题背景

Scheme 本身没有 `while` 循环（通常用递归实现）。我们可以定义一个函数，它接受循环的初始值、条件、累加表达式和更新表达式，然后自动生成一个等价的递归函数定义，并返回其表达式。

### 4.2 设计 `sum-while` 函数

我们希望实现这样一个功能：计算小于10的偶数的平方和，即 `2^2 + 4^2 + 6^2 + 8^2 = 120`。如果用传统的递归，我们可以这样写：

```scheme

(define (sum-while start condition accumulate update)
  (define (loop x result)
    (if (condition x)
        (loop (update x) (accumulate x result))
        result))
  (loop start 0))
```
但这里 `condition`、`accumulate`、`update` 都是函数。另一种思路是：我们生成一个**表达式**，该表达式定义了所需的递归函数并调用它，然后用 `eval` 求值。

### 4.3 使用准引用生成 `while` 表达式

我们可以编写一个函数 `make-while`，它返回一个完整的 `while` 循环的表达式（用递归实现）。例如，对于上述问题，我们希望生成的表达式类似：

```scheme

(let loop ((x 2) (result 0))
  (if (< x 10)
      (loop (+ x 2) (+ result (* x x)))
      result))
```
用准引用动态构造：

```scheme

(define (make-while start condition update accumulate initial)
  `(let loop ((x ,start) (result ,initial))
     (if ,condition
         (loop ,update (+ result ,accumulate))
         result)))
```
其中 `condition`、`update`、`accumulate` 都是**表达式**，它们会直接嵌入到生成的代码中。注意 `condition` 应该是一个返回布尔值的表达式，例如 `(< x 10)`；`update` 是更新 `x` 的表达式，如 `(+ x 2)`；`accumulate` 是累加到 `result` 的表达式，如 `(* x x)`。

### 4.4 使用示例

```scheme

> (define while-expr
    (make-while 2
                '(< x 10)
                '(+ x 2)
                '(* x x)
                0))
> while-expr
(let loop ((x 2) (result 0))
  (if (< x 10)
      (loop (+ x 2) (+ result (* x x)))
      result))
> (eval while-expr)
120
```
我们成功生成了一个 Scheme 表达式，它实现了我们想要的循环，并通过 `eval` 得到了正确结果。

### 4.5 更通用的 `sum-while` 函数

我们可以将上述过程封装成一个函数，它直接接受参数并返回计算结果：

```scheme

(define (sum-while start condition-expr update-expr accumulate-expr)
  (eval (make-while start condition-expr update-expr accumulate-expr 0)))
```
然后直接调用：

```scheme

> (sum-while 2 '(< x 10) '(+ x 2) '(* x x))
120
```
这种方式将代码生成和求值合二为一，非常强大。

---

## 五、为什么人们会使用这种语言？

Lisp 家族（Scheme、Common Lisp、Clojure 等）因其“代码即数据”的特性，在以下领域具有独特优势：

- **元编程**：可以在运行时生成和优化代码，例如编译器、解释器、领域特定语言（DSL）的构建。
    
- **符号计算**：处理数学表达式、公式推导、计算机代数系统。
    
- **自适应系统**：程序可以根据运行时信息修改自身行为。
    
- **教育**：用 Lisp 学习编程语言原理，因为它的核心极其简洁。
    

尽管现代语言也提供一定程度的元编程（如 Python 的 `eval`、`exec`），但 Lisp 的准引用和同像性使得代码生成变得极其自然，如同“代码模板”一样。

---

## 六、知识点总结表

|知识点|核心内容|考试重点 / 易混淆点|难度|
|---|---|---|---|
|**程序即数据**|Scheme 程序本身就是链表结构，可用 `list` 构造|区分代码和数据；`'` 引用 vs 普通列表|⭐⭐|
|**`eval` 函数**|接受表达式并求值，返回结果|`eval` 的环境；可以执行动态生成的代码|⭐⭐|
|**生成表达式的函数**|返回表达式而非直接计算结果（如 `fact-exp`）|递归构造嵌套列表；最终需用 `eval` 求值|⭐⭐⭐|
|**准引用（quasiquote）**|`` ` `` 引用模板，`,expr` 插入求值结果 \| 与普通引用的区别；逗号只能出现在准引用内 \| ⭐⭐⭐ \||||
|**代码生成示例**|`make-while` 生成递归实现的 `while` 循环表达式|理解如何用递归替代循环；准引用中的变量替换|⭐⭐⭐⭐|
|**元编程意义**|运行时代码生成、DSL 构建、程序分析|Lisp 与其他语言元编程能力的对比|⭐⭐|

---

## 七、自测题

### 1. 基础 `eval` 理解

写出以下表达式的结果：

```scheme

(eval (list '+ 1 2 3))
```
<details> <summary>答案</summary> 6 </details>

### 2. 准引用练习

已知 `x = 3`，写出以下准引用表达式的结果：

```scheme

`(a ,x b)
```
<details> <summary>答案</summary> `(a 3 b)` </details>

### 3. 构造代码

使用准引用写一个表达式，生成 `(* 5 (+ 3 4))` 这个列表（即不直接手写 `'(* 5 (+ 3 4))`，而是用变量动态构造）。

```scheme 
(let ((a 5) (b 3) (c 4)) `(* ,a (+ ,b ,c))) 
``` 

### 4. 生成斐波那契表达式

用准引用重写 `fib-exp` 函数。

```scheme 

(define (fib-exp n) (if (<= n 1) n `(+ ,(fib-exp (- n 1)) ,(fib-exp (- n 2))))) 

``` 

### 5. `make-while` 变体

修改 `make-while` 函数，使其生成的 `let` 循环中的累加器 `result` 初始值可以由用户指定（目前是硬编码为 `0`）。我们已经有了 `initial` 参数，实际上 `make-while` 定义中已经使用了 `initial`，所以正确。原函数 `(make-while start condition update accumulate initial)` 已包含 `initial`。请验证。

```scheme 
(define (make-while start condition update accumulate initial) `(let loop ((x ,start) (result ,initial)) (if ,condition (loop ,update (+ result ,accumulate)) result))) 
``` 

### 6. 思考题

为什么说“程序即数据”是 Lisp 家族最独特的特征？它带来了哪些其他语言难以实现的编程范式？

<details> <summary>提示</summary>

它允许程序在运行时像操作数据一样操作代码，从而实现宏系统、代码生成、DSL 嵌入等。这使得 Lisp 非常适合编写“编写程序的程序”，例如编译器、解释器、规则引擎等。其他语言（如 Python）虽然也有 `eval`，但缺乏语言级别的代码模板机制（如准引用），代码生成往往更笨拙。

</details>

---

## 八、总结与展望

本节课我们探索了 Scheme 中“程序即数据”的核心理念：

- Scheme 表达式本身就是列表，可以用 `list` 构造。
    
- `eval` 函数让动态生成的代码得以执行。
    
- 我们可以编写返回表达式的函数，从而实现代码生成。
    
- 准引用（quasiquote）提供了一种优雅的代码模板机制，极大地简化了代码生成过程。
    
- 通过 `make-while` 示例，我们看到了如何将控制结构（如循环）用递归实现，并动态生成其表达式。
    

这些技术不仅是 Scheme 语言魅力的体现，也为后续学习宏系统、解释器构建、编译原理打下了坚实基础。在接下来的课程中，我们将看到如何利用这些思想构建更强大的抽象。
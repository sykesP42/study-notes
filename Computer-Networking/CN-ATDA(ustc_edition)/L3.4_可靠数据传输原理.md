## 一、可靠数据传输概述

### 1. 核心任务

- **目标**：在下层服务**不可靠**的情况下，通过协议机制向上层提供**可靠**的数据传输服务。
    
- **实现层次**：可在应用层、传输层（TCP）和数据链路层实现，但最常见于传输层（TCP）。
    
- **关键挑战**：信道可能出现的**错误**（error）、**丢失**（loss）、**乱序**（out-of-order）。
    

### 2. 抽象模型

- **接口**：
    
    - `rdt_send()`：本层与上层接口（发送方接收数据）
        
    - `deliver_data()`：本层与上层接口（接收方交付数据）
        
    - `udt_send()` / `udt_receive()`：本层与下层接口（不可靠信道）
        

### 3. 可靠性的四个特性

- **不出错**（error-free）
    
- **不重复**（no duplication）
    
- **不失序**（in-order）
    
- **不丢失**（no loss）
    

> 💡 **设计哲学**：协议复杂性取决于底层信道的不可靠程度。从理想信道开始，逐步增加现实约束，逐层添加机制。

---

## 二、有限状态机

协议行为可用**有限状态机**（FSM）形式化描述：

- **状态**：协议实体所处的特定阶段
    
- **事件**：触发状态迁移的外部输入（如上层调用、分组到达、超时）
    
- **动作**：状态迁移中执行的操作（如封装、发送、启动定时器）
    

表示法：状态为节点，迁移为边，边上标注“事件/动作”。

---

## 三、逐步完善的可靠数据传输协议

### 1. RDT 1.0 —— 完全可靠信道

**信道假设**：

- 无比特错误，无分组丢失
    
- 发送的PDU能完整到达接收方
    

**协议行为**：

- 发送方：等待上层调用 → 封装数据 → 发送
    
- 接收方：等待下层分组 → 解封装 → 交付上层
    

**特点**：仅完成封装/解封装，无额外可靠性保障。

---

### 2. RDT 2.0 —— 引入比特差错检测

**信道假设变化**：允许比特翻转，但无分组丢失。

**核心机制**：

- **差错检测**：通过**校验和**（checksum）识别错误
    
- **反馈控制**：ACK/NAK 确认机制
    

**发送方行为**：

1. 计算校验和，封装数据并发送
    
2. **等待**ACK或NAK
    
3. 若收到NAK，重传；若收到ACK，发送新数据
    

**接收方行为**：

- 校验通过 → 发送ACK，交付数据
    
- 校验失败 → 发送NAK，触发重传
    

**问题**：如果ACK/NAK本身出错，发送方无法判断接收方状态。

---

### 3. RDT 2.1 —— 引入序号解决ACK/NAK出错

**解决方案**：在分组中加入**序号**（sequence number），发送方在ACK/NAK出错时统一重传当前分组，接收方通过序号识别重复分组并丢弃。

**设计要点**：

- 采用 **0/1交替序号**（1-bit序列号）
    
- 发送方和接收方各有两个状态（分别对应发送0和发送1）
    

**发送方FSM**（简化）：

- 状态 `等待调用0`：发送序号0的分组，等待确认；若收到损坏或不确定的ACK/NAK，重传；正确收到ACK0后转到 `等待调用1`。
    
- 状态 `等待调用1`：对称处理序号1的分组。
    

**接收方FSM**：

- 状态 `等待0`：期望接收序号0；若收到正确0号分组，交付并发送ACK0，转到 `等待1`；若收到损坏或乱序分组（如序号1），发送ACK1（针对上一个正确分组）并保持状态。
    

---

### 4. RDT 2.2 —— 无NAK协议

**改进**：用**编号ACK**替代NAK，接收方对最后正确接收的分组发ACK（ACK中包含期望的下一个序号）。

**语义转换**：

- 对当前分组的NAK → 发送对前一分组的ACK（例如收到错误分组1时发送ACK0）
    
- 发送方收到重复ACK（如ACK0）时，理解为需要重传当前分组（序号1）
    

**优势**：

- 协议简化，确认信息减少一半
    
- 为后续流水线协议（一次发送多个分组）做好准备
    

---

### 5. RDT 3.0 —— 引入分组丢失与超时

**信道假设变化**：允许分组丢失（包括数据分组和ACK丢失）。

**核心机制**：**超时重传** + **序号去重**。

**发送方新增组件**：**倒计数定时器**（每个未确认分组一个定时器，或所有未确认分组共用一个定时器——取决于实现）。

**关键行为**：

- 发送分组后**启动定时器**
    
- 收到有效ACK后**停止定时器**
    
- **超时事件**触发分组重传（并重启定时器）
    

**处理场景**：

- **分组丢失**：发送方超时重传，接收方通过序号去重。
    
- **ACK丢失**：发送方超时重传，接收方再次发送对应ACK。
    
- **过早超时**：若定时器设置过短（小于实际RTT），导致不必要的重传，但序号机制保证最终正确性，仅降低效率。
    

**超时时间设置原则**：

- 应略大于估计的RTT，避免过早超时
    
- 互联网环境RTT波动大，需采用**自适应**算法（如TCP的动态RTO计算）
    

---

### 6. 停止等待协议的性能分析

**停等协议**：每次只发送一个未确认分组，发送方必须等待ACK才能发送下一个。

**信道利用率公式**：

Usender=L/RRTT+L/RUsender​=RTT+L/RL/R​

- LL：分组长度（bits）
    
- RR：链路带宽（bps）
    
- RTTRTT：往返时间
    

**示例**：L=1 KBL=1 KB，R=1 GbpsR=1 Gbps，RTT=15 msRTT=15 ms，则 L/R=8 μsL/R=8 μs，利用率 U≈0.053%U≈0.053%，**极低**！这说明停等协议不适合高带宽-长延迟网络。

---

## 四、流水线协议与滑动窗口

### 1. 流水线思想

**改进原理**：允许发送方在未收到确认的情况下**连续发送多个分组**，将多个分组“流水”般注入管道，提高信道利用率。

**利用率提升**：

U=N⋅L/RRTT+L/RU=RTT+L/RN⋅L/R​

当窗口大小 NN 足够大时，利用率可接近100%。

**实现要求**：

- 需要更大的序号空间（多位序列号）
    
- 发送方/接收方需维护**缓冲区**
    
- 两种典型实现：**回退N帧**（Go-Back-N, GBN）和**选择重传**（Selective Repeat, SR）
    

---

### 2. 滑动窗口机制

#### 发送窗口

- **定义**：发送缓冲区中已发送但未确认的分组序号范围。
    
- **动态特性**：
    
    - **前沿移动**：每发送一个新分组，前沿前移
        
    - **后沿移动**：收到ACK后，后沿前移（窗口“滑动”）
        
    - **窗口大小** = 前沿 - 后沿，不能超过发送缓冲区容量
        

#### 接收窗口

- **定义**：接收方可以接收的分组序号范围。
    
- **作用**：控制哪些分组可以被接收，并对乱序分组进行缓存（或丢弃）。
    
- **窗口大小**：
    
    - **GBN**：接收窗口 = 1，只能顺序接收
        
    - **SR**：接收窗口 > 1，可缓存乱序分组
        

#### 窗口滑动条件

- **发送窗口滑动**：收到ACK，且ACK序号 >= 窗口后沿。
    
- **接收窗口滑动**：收到窗口下沿的分组（最低序号），交付上层后整体前移。
    

---

## 五、两种典型流水线协议

### 1. 回退N帧协议

|特性|描述|
|---|---|
|**发送窗口**|Ws>1Ws​>1，可连续发送多个未确认分组|
|**接收窗口**|Wr=1Wr​=1，只能顺序接收|
|**确认方式**|**累计确认**：ACKn 表示 n 及之前所有分组已正确接收|
|**定时器**|整个发送窗口共用一个定时器|
|**丢包处理**|若某分组丢失，后续到达的分组被丢弃，发送方超时后**重传所有已发送但未确认的分组**（从丢失处开始全部回退）|
|**优点**|实现简单，接收方无需缓存，资源消耗少|
|**缺点**|重传效率低，尤其在高带宽-长延迟网络中浪费严重|

**GBN发送方FSM**：

- 条件：`nextseqnum < base + N` 时才能发送，否则阻塞
    
- 超时处理：重传从 `base` 开始的所有分组
    
- ACK处理：`base = getacknum(rcvpkt) + 1`
    

**GBN接收方FSM**：

- 仅接收序号等于 `expectedseqnum` 的分组
    
- 否则丢弃，并重发最近按序ACK
    

---

### 2. 选择重传协议

|特性|描述|
|---|---|
|**发送窗口**|Ws>1Ws​>1，与GBN类似|
|**接收窗口**|Wr>1Wr​>1，可缓存乱序分组|
|**确认方式**|**独立确认**：每个正确接收的分组单独发送ACK|
|**定时器**|每个未确认分组有独立定时器|
|**丢包处理**|仅重传**超时的特定分组**，其他已到达的分组被缓存|
|**优点**|重传效率高，节省带宽|
|**缺点**|实现复杂，需维护多个定时器和缓冲区，窗口大小受序号空间限制|

**SR接收方行为**：

- 收到分组，若序号在窗口内：
    
    - 缓存并发送ACK
        
    - 若序号等于窗口下沿，则将该分组及之前连续缓存的分组一并交付上层，窗口滑动
        
- 若序号小于窗口下沿，发送ACK（但丢弃）
    
- 若序号大于窗口上沿，丢弃
    

**窗口大小限制**：

- 使用 n 比特序号时，GBN 最大窗口为 2n−12n−1，SR 最大窗口为 2n−12n−1（避免新旧数据混淆）
    

---

### 3. GBN vs SR 对比

|对比项|GBN|SR|
|---|---|---|
|**接收窗口**|1|>1|
|**确认方式**|累计确认|独立确认|
|**定时器**|单个|每个分组独立|
|**乱序处理**|丢弃|缓存|
|**重传范围**|整个窗口|单个分组|
|**实现复杂度**|低|高|
|**适用场景**|错误率低、短延迟网络|错误率高、长延迟网络（如无线、卫星）|
|**序号空间需求**|2n−12n−1|2n−12n−1|

---

## 六、运行实例对比

### GBN示例

发送窗口大小=4，接收窗口=1。

1. 发送0,1,2,3；接收方收到0，发ACK0，窗口滑动。
    
2. 分组2丢失；接收方收到3（期待1），丢弃3，发ACK1（累计）。
    
3. 发送方超时，重传2,3,4,5（即使3可能已到，但被丢弃），效率低。
    

### SR示例

发送窗口=4，接收窗口=4。

1. 发送0,1,2,3；分组2丢失。
    
2. 接收方缓存3,4,5（若窗口允许），分别发独立ACK。
    
3. 发送方仅重传2，收到2后接收方将2-5一次性交付上层。
    

---

## 七、协议选择考量

- **GBN**：适用于**低出错率**环境（如光纤骨干网），实现简单，资源消耗少。
    
- **SR**：适用于**高出错率**或**长延迟**环境（如无线网络、卫星链路），虽复杂但能显著提升带宽利用率。
    

---

## 八、知识小结

|知识点|核心内容|考试重点/易混淆点|难度|
|---|---|---|---|
|**RDT 1.0**|理想信道，仅封装/解封装|无可靠性机制|★|
|**RDT 2.0**|引入校验和 + ACK/NAK|处理比特错误|★★★|
|**RDT 2.1**|增加序号解决ACK/NAK出错|1-bit序号，重复检测|★★★|
|**RDT 2.2**|无NAK，用编号ACK替代|ACK携带期望序号|★★★|
|**RDT 3.0**|增加超时重传处理丢包|定时器设置原则|★★★★|
|**停等协议**|一次一个未确认分组|利用率公式|★★★|
|**流水线协议**|连续发送多个未确认分组|窗口机制|★★★★|
|**GBN**|累计确认，回退N步|接收窗口=1，全重传|★★★★★|
|**SR**|独立确认，选择性重传|接收窗口>1，乱序缓存|★★★★★|
|**窗口大小限制**|GBN: 2n−12n−1；SR: 2n−12n−1|防止序号歧义|★★★★|

---

> 📖 **核心启示**：可靠数据传输协议的演进，本质是在**信道不可靠性**与**协议复杂度/效率**之间不断权衡的过程。从RDT 1.0到3.0，我们逐步添加了校验和、序号、确认、超时等机制；从停等到流水线，我们用窗口机制换取高带宽利用率；GBN和SR则代表了两种不同的丢包恢复哲学。理解这些基础，就为深入理解TCP的滑动窗口、拥塞控制等复杂机制铺平了道路。
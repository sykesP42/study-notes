# 2.2 Web与HTTP协议 - 计算机网络笔记

---

## 一、Web应用概述

### 1. 什么是Web对象？

- **Web页**（Web page）不是单一文件，而是由**多个对象**组成的文档。
    
- **对象**（Object）可以是：HTML文件、JPEG图像、Java小程序、音频/视频剪辑、CSS样式表、JavaScript脚本等。
    
- **核心设计**：基本HTML文件通过**URL（统一资源定位符）** 引用其他对象，而不是将对象直接嵌入HTML中。这使得对象可独立存储、单独更新，并在不同页面间复用。
    

### 2. URL结构详解

**标准格式**：

text

协议://用户名:密码@主机名:端口/路径/文件名?参数#片段

|组成部分|示例|说明|是否必选|
|---|---|---|---|
|**协议**|`http`、`https`、`ftp`|指定访问资源所使用的应用层协议|✔️|
|**认证信息**|`user:psw@`|匿名访问时省略；仅部分协议（如FTP）需要|❌|
|**主机名**|`www.someschool.edu`|服务器的域名或IP地址|✔️|
|**端口**|`:80`|默认HTTP为80，HTTPS为443；省略时使用默认端口|❌|
|**路径**|`/someDept/`|资源在服务器文件系统中的目录路径|❌（根目录）|
|**文件名**|`pic.gif`|具体资源名称|❌（可能由服务器默认页面决定）|
|**参数**|`?id=123&page=2`|GET方法传递的查询字符串，键值对形式|❌|
|**片段**|`#section1`|直接定位到HTML文档内的锚点，不发送到服务器|❌|

**💡 初学者易混淆**：URL中的参数（Query String）仅适用于GET请求；POST请求提交的数据在报文**实体主体**中，不会显示在URL里。

---

## 二、HTTP协议基础

### 1. HTTP协议版本演进

|版本|发表年份|RFC文档|**关键特性**|当前状态|
|---|---|---|---|---|
|**HTTP/0.9**|1991|无（非正式）|只有GET方法；纯文本；无头部；无状态码|已废弃|
|**HTTP/1.0**|1996|RFC 1945|支持多种方法、头部字段、状态码；**非持久连接**（每个请求一个TCP连接）|很少使用|
|**HTTP/1.1**|1997|RFC 2068 (后由2616、723x更新)|**持久连接**（默认）；管道化请求；分块传输编码；Host头部（必须）；更多方法（PUT、DELETE等）|**主流使用**|
|**HTTP/2**|2015|RFC 7540|二进制分帧；多路复用；头部压缩；服务器推送|逐渐普及|
|**HTTP/3**|2022|RFC 9114|基于QUIC（UDP）；0-RTT；更好的拥塞控制|新兴标准|

> **重点**：HTTP/1.0与HTTP/1.1最显著的差异是**连接管理**策略。这直接影响网页加载性能。

### 2. HTTP连接类型

#### (1) 非持久连接（HTTP/1.0 默认）

- **每个TCP连接仅传输一个对象**。
    
- 流程（以单对象为例）：
    
    1. 客户端发起TCP连接（三次握手）—— **1 RTT**（往返时间）
        
    2. 客户端发送HTTP请求报文
        
    3. 服务器接收请求并返回响应报文
        
    4. 服务器**立即关闭**TCP连接
        
- **总耗时** = 1 RTT（建立连接） + 1 RTT（请求/响应） + 文件传输时间 = **2 RTT + 传输时间**
    

**⚠️ 性能缺陷**：

- 若一个HTML页面包含10张图片，共需 **11个TCP连接**。
    
- 每个连接都需要2 RTT，累计22 RTT！此外，每次连接建立/拆除消耗服务器资源（端口、内存）。
    
- **非持久连接是早期“World Wide Wait”现象的元凶之一**。
    

#### (2) 持久连接（HTTP/1.1 默认）

- **单个TCP连接可传输多个对象**。
    
- 连接在传输完一个响应后**保持打开**，用于后续请求。
    

**两种工作模式**：

|模式|工作机制|性能|特点|
|---|---|---|---|
|**非流水线**|发送一个请求 → 收到响应 → 再发下一个请求|**串行**，每次仍有1 RTT等待时间|简单，避免服务器端队头阻塞|
|**流水线**|一次发送所有请求（无需等待响应）|**并行**，多个对象重叠传输|理论耗时仅1 RTT + 传输时间；但实现复杂，部分代理/服务器不支持|

**📌 流水线原理**：

- 客户端解析HTML后，**立即连续发送**所有嵌入式对象的请求。
    
- 服务器按接收顺序依次返回响应。
    
- 只要带宽充足，总耗时 ≈ **1 RTT（连接建立） + 1 RTT（首个对象请求/响应） + 传输时间**（后续对象请求与传输重叠）。
    

> **现实**：由于代理服务器兼容性问题，现代浏览器**通常不启用流水线**，而是**并行建立多个持久连接**（通常6~8个），同时下载资源，以达到类似流水线的效果。

---

## 三、HTTP报文格式详解

HTTP报文是**纯文本**（ASCII）格式，可直接阅读，便于开发和调试。

### 1. 请求报文


```text

请求行      GET /somedir/page.html HTTP/1.1
首部行      Host: www.someschool.edu
            User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
            Accept-Language: zh-CN,en-US
            Connection: keep-alive
空行        （回车换行）
实体主体    （仅POST请求时有数据）
```
#### (1) 请求方法

|方法|含义|是否包含主体|幂等性|典型场景|
|---|---|---|---|---|
|**GET**|请求资源|否|✔️|获取网页、图片|
|**POST**|提交数据给服务器处理|是|❌|表单提交、上传文件|
|**HEAD**|类似GET，但**只返回响应头**|否|✔️|爬虫检查链接有效性；获取资源元信息|
|**PUT**|将实体主体上传到指定URL（覆盖）|是|✔️|网站发布工具|
|**DELETE**|删除指定URL的资源|否|✔️|网站管理|
|**OPTIONS**|查询服务器支持哪些方法|否|✔️|CORS预检请求|

**💡 GET vs POST 本质区别**：

- **数据位置**：GET参数在URL中，POST数据在报文实体中。
    
- **安全性**：GET参数可被浏览器历史、服务器日志记录；POST相对安全（但仍需HTTPS）。
    
- **长度限制**：GET受URL长度限制（浏览器不同，约2KB~8KB）；POST理论上无限制。
    
- **编码**：GET只支持ASCII；POST支持多种编码（multipart/form-data用于文件上传）。
    

#### (2) 重要首部字段

|首部字段|作用|示例|
|---|---|---|
|**Host**|**必须**，指定目标服务器域名（HTTP/1.1要求）|`Host: www.example.com`|
|**User-Agent**|标识客户端软件类型|`User-Agent: Mozilla/5.0...`|
|**Accept**|告知服务器客户端能处理的媒体类型|`Accept: text/html,application/xhtml+xml`|
|**Accept-Language**|客户端支持的语言|`Accept-Language: zh-CN,en-US`|
|**Accept-Encoding**|客户端支持的压缩格式|`Accept-Encoding: gzip, deflate, br`|
|**Connection**|控制连接管理|`Connection: keep-alive` 或 `close`|
|**Referer**|请求来源页面|`Referer: https://www.google.com/`|
|**If-Modified-Since**|**条件GET**，与响应中的Last-Modified配合|`If-Modified-Since: Mon, 22 Jun 1998 12:00:00 GMT`|
|**Cookie**|携带服务器先前设置的Cookie值|`Cookie: sessionId=1678; userId=abc123`|

---

### 2. 响应报文

```text

状态行     HTTP/1.1 200 OK
首部行     Date: Thu, 06 Aug 1998 12:00:15 GMT
           Server: Apache/1.3.0 (Unix)
           Last-Modified: Mon, 22 Jun 1998 09:23:24 GMT
           Content-Length: 6821
           Content-Type: text/html
           Connection: close
空行       （回车换行）
实体体     （实际的HTML内容）
```
#### (1) 状态码分类

|分类|含义|常见状态码|
|---|---|---|
|**1xx**|信息性响应|100 Continue|
|**2xx**|成功|**200 OK**（请求成功）|
|**3xx**|重定向|**301 Moved Permanently**（永久重定向）、**304 Not Modified**（缓存有效）|
|**4xx**|客户端错误|**400 Bad Request**（请求语法错误）、**404 Not Found**（资源不存在）|
|**5xx**|服务器错误|**500 Internal Server Error**、**503 Service Unavailable**|

**💡 304 Not Modified**：

- 用于**条件GET**。客户端发送 `If-Modified-Since`，若资源未更新，服务器返回304，**不包含实体体**。
    
- 大大节省带宽，是Web缓存的核心机制。
    

#### (2) 重要首部字段

|首部字段|作用|示例|
|---|---|---|
|**Date**|报文创建时间（GMT标准）|`Date: Thu, 06 Aug 1998 12:00:15 GMT`|
|**Server**|服务器软件信息|`Server: Apache/2.4.41 (Unix)`|
|**Last-Modified**|资源最后修改时间（版本标识）|`Last-Modified: Mon, 22 Jun 1998 09:23:24 GMT`|
|**Content-Length**|实体体长度（字节）|**TCP不维护报文边界，此字段用于拆分报文**|
|**Content-Type**|实体体的MIME类型|`Content-Type: text/html; charset=utf-8`|
|**Content-Encoding**|实体体的压缩算法|`Content-Encoding: gzip`|
|**Set-Cookie**|服务器向客户端设置Cookie|`Set-Cookie: sessionId=1678; Path=/; HttpOnly`|
|**Cache-Control**|缓存策略（优先级高于Expires）|`Cache-Control: max-age=3600, private`|

---

## 四、HTTP协议特性深度解析

### 1. 无状态协议

**定义**：HTTP协议本身**不保留**任何关于客户端之前请求的信息。每个请求都是独立、隔离的。

**为什么设计为无状态？**

- **简化服务器设计**：无需为每个用户维护会话状态，减少内存开销。
    
- **高可扩展性**：请求可被任意服务器处理（负载均衡），无需“会话粘滞”。
    
- **容错性**：客户端崩溃后重新请求，服务器无需恢复状态。
    

**无状态的代价**：无法“记住”用户（如购物车、登录状态）。  
**解决方案**：**Cookie技术**（在HTTP之上添加状态层）。

---

### 2. Cookie机制——为无状态协议添加记忆

#### (1) Cookie的四个组件

1. **响应报文中的 `Set-Cookie` 首部行**：服务器向客户端发送Cookie。
    
2. **请求报文中的 `Cookie` 首部行**：客户端向服务器携带已存储的Cookie。
    
3. **客户端本地的Cookie文件**：浏览器管理的键值对存储。
    
4. **服务器后端的数据库**：通过Cookie中的唯一标识（如sessionId）关联用户状态。
    

#### (2) 工作流程（以首次访问购物网站为例）

```text

[客户端]                                   [服务器]
   |                                            |
   |-------- 1. HTTP请求（无Cookie） ---------->|
   |                                            | 生成唯一ID（如1678）
   |<------- 2. HTTP响应 + Set-Cookie: 1678 ----|
   |                                            |
   | 存储Cookie                                 |
   |                                            |
   |-------- 3. HTTP请求 + Cookie: 1678 ------>|
   |                                            | 通过ID查询购物车
   |<------- 4. HTTP响应（个性化内容） ---------|
```
#### (3) Cookie的典型应用

|应用场景|实现方式|示例|
|---|---|---|
|**用户认证**|登录成功后生成认证令牌（sessionId）|自动登录、记住我|
|**购物车**|服务器以Cookie ID为键存储购物车内容|添加商品后刷新页面购物车仍在|
|**个性化推荐**|分析Cookie关联的浏览历史|“猜你喜欢”|
|**用户行为追踪**|第三方Cookie记录跨站访问记录|广告精准投放|

#### (4) Cookie的隐私与安全

**⚠️ 争议**：

- Cookie使网站能够**长期跟踪**用户行为。即使未登录，浏览器也会发送该站点的所有Cookie。
    
- 第三方Cookie（不同域设置的Cookie）可用于跨站追踪，是隐私泄露的主要途径。
    

**现代浏览器对策**：

- 限制第三方Cookie（Safari ITP、Chrome逐步淘汰）。
    
- 提供“清除Cookie”功能。
    
- 推出替代技术（如Google的FLoC、Topics API）。
    

> 💡 **理解**：Cookie本身不是“病毒”或“恶意软件”，它只是HTTP扩展。其“善恶”取决于使用方式。

---

## 五、Web缓存机制

### 1. 什么是Web缓存？

- **Web缓存**（Web cache）又称**代理服务器**（proxy server），是位于客户端和原始服务器之间的网络实体。
    
- **作用**：保存最近请求过的文档副本，当相同请求再次出现时，直接从缓存返回，无需访问原始服务器。
    

### 2. 缓存工作流程

```text

[客户端] --> [代理缓存] --> [原始服务器]
    |            |              |
    |            |-- 未命中 --->|
    |            |<-- 响应 -----|
    |            |（存储副本）  |
    |<-- 响应 ---|              |
    |            |              |
    |-- 请求 --> |              |
    |            |-- 命中 ----->|（直接返回，不访问服务器）
    |<-- 响应 ---|              |
```
### 3. 缓存的核心优势

|受益方|优势|量化示例|
|---|---|---|
|**客户端**|**降低响应时间**|本地命中延迟≈10ms，远程访问需2秒+|
|**机构网络**|**减少接入链路带宽消耗**|流量强度从99%降至58%|
|**原始服务器**|**减轻负载**|请求量减少40%，服务器压力下降|
|**ISP/运营商**|**降低骨干网流量**|热点内容本地服务，节省跨网结算费用|

### 4. 条件GET——保持缓存一致性的关键

**问题**：缓存中的副本可能过时（原始服务器资源已更新）。  
**解决方案**：**条件GET**（Conditional GET），利用 `If-Modified-Since` 首部。

**工作过程**：

1. **首次请求**：
    
    - 代理缓存向原始服务器请求资源。
        
    - 服务器返回 `200 OK` + 资源 + `Last-Modified: [时间戳]`。
        
    - 缓存存储资源**及**该时间戳。
        
2. **后续请求**（缓存命中但需验证有效性）：
    
    - 代理缓存向原始服务器发送**条件GET**请求：
        
        text
        
        GET /somefile.html HTTP/1.1
        Host: www.someschool.edu
        If-Modified-Since: [存储的时间戳]
        
    - **情形A**：资源未修改 → 服务器返回 `304 Not Modified`（**无实体体**）。
        
        - 代理缓存**直接使用本地副本**返回客户端。
            
    - **情形B**：资源已修改 → 服务器返回 `200 OK` + **新资源** + 新 `Last-Modified`。
        
        - 代理缓存**更新本地副本**并转发给客户端。
            

**🎯 优势**：

- 即使每次请求都验证，也**仅发送头部**（几十字节），而非整个资源（可能几MB）。
    
- 对于未修改的资源，**传输量几乎为0**，极大节省带宽。
    

---

## 六、经典案例：缓存 vs 带宽升级

### 1. 问题场景

某机构网络：

- **LAN速率**：100 Mbps（本地时延≈10ms）
    
- **接入链路**：1.544 Mbps (T1线路)
    
- **Internet往返时延**：2秒
    
- **用户行为**：平均请求率15次/秒，平均对象大小100 KB（即800 Kb）
    
- **总流量** = 15 × 800 Kb = 12 Mbps
    
- **接入链路流量强度** = 12 Mbps / 1.544 Mbps ≈ **0.99 (99%)**
    
- **排队延迟理论公式**：当利用率ρ=0.99时，延迟 ≈ 传输时间 / (1-ρ) → 分钟级响应（“World Wide Wait”）
    

### 2. 方案A：升级带宽（“土豪方案”）

- 将接入链路升级至154 Mbps（100倍）。
    
- 流量强度降至 12/154 ≈ 0.078 (7.8%) → 排队延迟几乎为0。
    
- **响应时间** = LAN时延(10ms) + 接入时延(可忽略) + Internet时延(2s) ≈ **2.01秒**。
    
- **代价**：月租费增加约**100倍**（从几百美元到数万美元），成本不可接受。
    

### 3. 方案B：部署本地缓存（“聪明方案”）

- 在机构网络中部署代理缓存。
    
- 假设**命中率40%**（热点内容访问规律）。
    
- **接入链路流量**：
    
    - 未命中部分：12 Mbps × 60% = 7.2 Mbps
        
    - 流量强度 = 7.2 / 1.544 ≈ 0.47 (47%) → **排队延迟可忽略**。
        
- **平均响应时间**：
    
    - 缓存命中：10 ms
        
    - 缓存未命中：10 ms + 2 s = 2010 ms
        
    - **加权平均** = 0.4 × 10 + 0.6 × 2010 ≈ **1210 ms (1.21秒)**。
        
- **结果**：**比升级带宽更快（1.21秒 < 2.01秒）**，且成本仅为一次性部署缓存服务器。
    

**🎉 启示**：

- 在瓶颈链路上，**减少流量比增加带宽更经济、更有效**。
    
- 缓存利用**访问局部性**（80/20原则），以极低成本实现大幅性能提升。
    

---

## 七、知识小结（精华版）

|知识点|核心内容|考试重点/易混淆点|难度|
|---|---|---|---|
|**URL结构**|`协议://主机[:端口]/路径[?参数][#片段]`|参数属于GET方法，POST数据在实体中|★★|
|**HTTP版本**|HTTP/1.0非持久；HTTP/1.1默认持久+流水线|**非持久连接每个对象需2RTT**|★★★|
|**RTT与延迟**|1 RTT = 小分组往返时间（不含传输时间）|持久连接+流水线：总延迟≈1RTT+传输时间|★★★★|
|**请求报文**|ASCII文本，含请求行、首部行、空行、实体|**Host字段必须**；GET无实体，POST有实体|★★★|
|**响应报文**|状态行、首部行、空行、实体|**状态码记忆**：200/301/304/404/505|★★★|
|**无状态特性**|服务器不记忆客户端历史|优点：简单、可扩展；**Cookie弥补状态**|★★★|
|**Cookie机制**|Set-Cookie响应头 + Cookie请求头|**四要素**：响应头、请求头、本地存储、后端DB|★★★★|
|**Web缓存**|代理服务器存储副本，减少访问延迟和带宽|**条件GET**（If-Modified-Since + 304）|★★★★★|
|**缓存计算**|接入链路流量强度、排队延迟、平均响应时间|**命中率对性能影响巨大**|★★★★★|

---

> **📘 本章心法**：
> 
> 1. **HTTP是无状态的，Cookie是其“外挂”状态层**——理解这一点，就理解了Web状态管理的本质。
>     
> 2. **连接管理是HTTP/1.1性能优化的核心**——持久连接+并行连接，至今仍是Web性能优化的基础。
>     
> 3. **缓存是互联网的“杠杆”**——用最小的成本撬动最大的性能提升，CDN是其现代形态。
>